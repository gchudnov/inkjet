/*
 * inkjet - JPEG-image decoding, encoding & EXIF reading library for browser and node.js
 * @version v3.0.0
 * @author Grigorii Chudnov <g.chudnov@gmail.com> (https://github.com/gchudnov)
 * @link https://github.com/gchudnov/inkjet
 * @license MIT
 */
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.inkjet = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){
'use strict';

var objectAssign = require('object-assign');

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:
// NB: The URL to the CommonJS spec is kept just for tradition.
//     node-assert has evolved a lot since then, both in API and behavior.

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util/');
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = (function () {
  return function foo() {}.name === 'foo';
}());
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function(err) { if (err) throw err; };

// Expose a strict only variant of assert
function strict(value, message) {
  if (!value) fail(value, true, message, '==', strict);
}
assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"object-assign":17,"util/":4}],2:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],3:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],4:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":3,"_process":30,"inherits":2}],5:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],6:[function(require,module,exports){

},{}],7:[function(require,module,exports){
(function (process,Buffer){
'use strict';
/* eslint camelcase: "off" */

var assert = require('assert');

var Zstream = require('pako/lib/zlib/zstream');
var zlib_deflate = require('pako/lib/zlib/deflate.js');
var zlib_inflate = require('pako/lib/zlib/inflate.js');
var constants = require('pako/lib/zlib/constants');

for (var key in constants) {
  exports[key] = constants[key];
}

// zlib modes
exports.NONE = 0;
exports.DEFLATE = 1;
exports.INFLATE = 2;
exports.GZIP = 3;
exports.GUNZIP = 4;
exports.DEFLATERAW = 5;
exports.INFLATERAW = 6;
exports.UNZIP = 7;

var GZIP_HEADER_ID1 = 0x1f;
var GZIP_HEADER_ID2 = 0x8b;

/**
 * Emulate Node's zlib C++ layer for use by the JS layer in index.js
 */
function Zlib(mode) {
  if (typeof mode !== 'number' || mode < exports.DEFLATE || mode > exports.UNZIP) {
    throw new TypeError('Bad argument');
  }

  this.dictionary = null;
  this.err = 0;
  this.flush = 0;
  this.init_done = false;
  this.level = 0;
  this.memLevel = 0;
  this.mode = mode;
  this.strategy = 0;
  this.windowBits = 0;
  this.write_in_progress = false;
  this.pending_close = false;
  this.gzip_id_bytes_read = 0;
}

Zlib.prototype.close = function () {
  if (this.write_in_progress) {
    this.pending_close = true;
    return;
  }

  this.pending_close = false;

  assert(this.init_done, 'close before init');
  assert(this.mode <= exports.UNZIP);

  if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {
    zlib_deflate.deflateEnd(this.strm);
  } else if (this.mode === exports.INFLATE || this.mode === exports.GUNZIP || this.mode === exports.INFLATERAW || this.mode === exports.UNZIP) {
    zlib_inflate.inflateEnd(this.strm);
  }

  this.mode = exports.NONE;

  this.dictionary = null;
};

Zlib.prototype.write = function (flush, input, in_off, in_len, out, out_off, out_len) {
  return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);
};

Zlib.prototype.writeSync = function (flush, input, in_off, in_len, out, out_off, out_len) {
  return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);
};

Zlib.prototype._write = function (async, flush, input, in_off, in_len, out, out_off, out_len) {
  assert.equal(arguments.length, 8);

  assert(this.init_done, 'write before init');
  assert(this.mode !== exports.NONE, 'already finalized');
  assert.equal(false, this.write_in_progress, 'write already in progress');
  assert.equal(false, this.pending_close, 'close is pending');

  this.write_in_progress = true;

  assert.equal(false, flush === undefined, 'must provide flush value');

  this.write_in_progress = true;

  if (flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK) {
    throw new Error('Invalid flush value');
  }

  if (input == null) {
    input = Buffer.alloc(0);
    in_len = 0;
    in_off = 0;
  }

  this.strm.avail_in = in_len;
  this.strm.input = input;
  this.strm.next_in = in_off;
  this.strm.avail_out = out_len;
  this.strm.output = out;
  this.strm.next_out = out_off;
  this.flush = flush;

  if (!async) {
    // sync version
    this._process();

    if (this._checkError()) {
      return this._afterSync();
    }
    return;
  }

  // async version
  var self = this;
  process.nextTick(function () {
    self._process();
    self._after();
  });

  return this;
};

Zlib.prototype._afterSync = function () {
  var avail_out = this.strm.avail_out;
  var avail_in = this.strm.avail_in;

  this.write_in_progress = false;

  return [avail_in, avail_out];
};

Zlib.prototype._process = function () {
  var next_expected_header_byte = null;

  // If the avail_out is left at 0, then it means that it ran out
  // of room.  If there was avail_out left over, then it means
  // that all of the input was consumed.
  switch (this.mode) {
    case exports.DEFLATE:
    case exports.GZIP:
    case exports.DEFLATERAW:
      this.err = zlib_deflate.deflate(this.strm, this.flush);
      break;
    case exports.UNZIP:
      if (this.strm.avail_in > 0) {
        next_expected_header_byte = this.strm.next_in;
      }

      switch (this.gzip_id_bytes_read) {
        case 0:
          if (next_expected_header_byte === null) {
            break;
          }

          if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {
            this.gzip_id_bytes_read = 1;
            next_expected_header_byte++;

            if (this.strm.avail_in === 1) {
              // The only available byte was already read.
              break;
            }
          } else {
            this.mode = exports.INFLATE;
            break;
          }

        // fallthrough
        case 1:
          if (next_expected_header_byte === null) {
            break;
          }

          if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {
            this.gzip_id_bytes_read = 2;
            this.mode = exports.GUNZIP;
          } else {
            // There is no actual difference between INFLATE and INFLATERAW
            // (after initialization).
            this.mode = exports.INFLATE;
          }

          break;
        default:
          throw new Error('invalid number of gzip magic number bytes read');
      }

    // fallthrough
    case exports.INFLATE:
    case exports.GUNZIP:
    case exports.INFLATERAW:
      this.err = zlib_inflate.inflate(this.strm, this.flush

      // If data was encoded with dictionary
      );if (this.err === exports.Z_NEED_DICT && this.dictionary) {
        // Load it
        this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);
        if (this.err === exports.Z_OK) {
          // And try to decode again
          this.err = zlib_inflate.inflate(this.strm, this.flush);
        } else if (this.err === exports.Z_DATA_ERROR) {
          // Both inflateSetDictionary() and inflate() return Z_DATA_ERROR.
          // Make it possible for After() to tell a bad dictionary from bad
          // input.
          this.err = exports.Z_NEED_DICT;
        }
      }
      while (this.strm.avail_in > 0 && this.mode === exports.GUNZIP && this.err === exports.Z_STREAM_END && this.strm.next_in[0] !== 0x00) {
        // Bytes remain in input buffer. Perhaps this is another compressed
        // member in the same archive, or just trailing garbage.
        // Trailing zero bytes are okay, though, since they are frequently
        // used for padding.

        this.reset();
        this.err = zlib_inflate.inflate(this.strm, this.flush);
      }
      break;
    default:
      throw new Error('Unknown mode ' + this.mode);
  }
};

Zlib.prototype._checkError = function () {
  // Acceptable error states depend on the type of zlib stream.
  switch (this.err) {
    case exports.Z_OK:
    case exports.Z_BUF_ERROR:
      if (this.strm.avail_out !== 0 && this.flush === exports.Z_FINISH) {
        this._error('unexpected end of file');
        return false;
      }
      break;
    case exports.Z_STREAM_END:
      // normal statuses, not fatal
      break;
    case exports.Z_NEED_DICT:
      if (this.dictionary == null) {
        this._error('Missing dictionary');
      } else {
        this._error('Bad dictionary');
      }
      return false;
    default:
      // something else.
      this._error('Zlib error');
      return false;
  }

  return true;
};

Zlib.prototype._after = function () {
  if (!this._checkError()) {
    return;
  }

  var avail_out = this.strm.avail_out;
  var avail_in = this.strm.avail_in;

  this.write_in_progress = false;

  // call the write() cb
  this.callback(avail_in, avail_out);

  if (this.pending_close) {
    this.close();
  }
};

Zlib.prototype._error = function (message) {
  if (this.strm.msg) {
    message = this.strm.msg;
  }
  this.onerror(message, this.err

  // no hope of rescue.
  );this.write_in_progress = false;
  if (this.pending_close) {
    this.close();
  }
};

Zlib.prototype.init = function (windowBits, level, memLevel, strategy, dictionary) {
  assert(arguments.length === 4 || arguments.length === 5, 'init(windowBits, level, memLevel, strategy, [dictionary])');

  assert(windowBits >= 8 && windowBits <= 15, 'invalid windowBits');
  assert(level >= -1 && level <= 9, 'invalid compression level');

  assert(memLevel >= 1 && memLevel <= 9, 'invalid memlevel');

  assert(strategy === exports.Z_FILTERED || strategy === exports.Z_HUFFMAN_ONLY || strategy === exports.Z_RLE || strategy === exports.Z_FIXED || strategy === exports.Z_DEFAULT_STRATEGY, 'invalid strategy');

  this._init(level, windowBits, memLevel, strategy, dictionary);
  this._setDictionary();
};

Zlib.prototype.params = function () {
  throw new Error('deflateParams Not supported');
};

Zlib.prototype.reset = function () {
  this._reset();
  this._setDictionary();
};

Zlib.prototype._init = function (level, windowBits, memLevel, strategy, dictionary) {
  this.level = level;
  this.windowBits = windowBits;
  this.memLevel = memLevel;
  this.strategy = strategy;

  this.flush = exports.Z_NO_FLUSH;

  this.err = exports.Z_OK;

  if (this.mode === exports.GZIP || this.mode === exports.GUNZIP) {
    this.windowBits += 16;
  }

  if (this.mode === exports.UNZIP) {
    this.windowBits += 32;
  }

  if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW) {
    this.windowBits = -1 * this.windowBits;
  }

  this.strm = new Zstream();

  switch (this.mode) {
    case exports.DEFLATE:
    case exports.GZIP:
    case exports.DEFLATERAW:
      this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
      break;
    case exports.INFLATE:
    case exports.GUNZIP:
    case exports.INFLATERAW:
    case exports.UNZIP:
      this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);
      break;
    default:
      throw new Error('Unknown mode ' + this.mode);
  }

  if (this.err !== exports.Z_OK) {
    this._error('Init error');
  }

  this.dictionary = dictionary;

  this.write_in_progress = false;
  this.init_done = true;
};

Zlib.prototype._setDictionary = function () {
  if (this.dictionary == null) {
    return;
  }

  this.err = exports.Z_OK;

  switch (this.mode) {
    case exports.DEFLATE:
    case exports.DEFLATERAW:
      this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);
      break;
    default:
      break;
  }

  if (this.err !== exports.Z_OK) {
    this._error('Failed to set dictionary');
  }
};

Zlib.prototype._reset = function () {
  this.err = exports.Z_OK;

  switch (this.mode) {
    case exports.DEFLATE:
    case exports.DEFLATERAW:
    case exports.GZIP:
      this.err = zlib_deflate.deflateReset(this.strm);
      break;
    case exports.INFLATE:
    case exports.INFLATERAW:
    case exports.GUNZIP:
      this.err = zlib_inflate.inflateReset(this.strm);
      break;
    default:
      break;
  }

  if (this.err !== exports.Z_OK) {
    this._error('Failed to reset stream');
  }
};

exports.Zlib = Zlib;
}).call(this,require('_process'),require("buffer").Buffer)

},{"_process":30,"assert":1,"buffer":9,"pako/lib/zlib/constants":20,"pako/lib/zlib/deflate.js":22,"pako/lib/zlib/inflate.js":24,"pako/lib/zlib/zstream":28}],8:[function(require,module,exports){
(function (process){
'use strict';

var Buffer = require('buffer').Buffer;
var Transform = require('stream').Transform;
var binding = require('./binding');
var util = require('util');
var assert = require('assert').ok;
var kMaxLength = require('buffer').kMaxLength;
var kRangeErrorMessage = 'Cannot create final Buffer. It would be larger ' + 'than 0x' + kMaxLength.toString(16) + ' bytes';

// zlib doesn't provide these, so kludge them in following the same
// const naming scheme zlib uses.
binding.Z_MIN_WINDOWBITS = 8;
binding.Z_MAX_WINDOWBITS = 15;
binding.Z_DEFAULT_WINDOWBITS = 15;

// fewer than 64 bytes per chunk is stupid.
// technically it could work with as few as 8, but even 64 bytes
// is absurdly low.  Usually a MB or more is best.
binding.Z_MIN_CHUNK = 64;
binding.Z_MAX_CHUNK = Infinity;
binding.Z_DEFAULT_CHUNK = 16 * 1024;

binding.Z_MIN_MEMLEVEL = 1;
binding.Z_MAX_MEMLEVEL = 9;
binding.Z_DEFAULT_MEMLEVEL = 8;

binding.Z_MIN_LEVEL = -1;
binding.Z_MAX_LEVEL = 9;
binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;

// expose all the zlib constants
var bkeys = Object.keys(binding);
for (var bk = 0; bk < bkeys.length; bk++) {
  var bkey = bkeys[bk];
  if (bkey.match(/^Z/)) {
    Object.defineProperty(exports, bkey, {
      enumerable: true, value: binding[bkey], writable: false
    });
  }
}

// translation table for return codes.
var codes = {
  Z_OK: binding.Z_OK,
  Z_STREAM_END: binding.Z_STREAM_END,
  Z_NEED_DICT: binding.Z_NEED_DICT,
  Z_ERRNO: binding.Z_ERRNO,
  Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
  Z_DATA_ERROR: binding.Z_DATA_ERROR,
  Z_MEM_ERROR: binding.Z_MEM_ERROR,
  Z_BUF_ERROR: binding.Z_BUF_ERROR,
  Z_VERSION_ERROR: binding.Z_VERSION_ERROR
};

var ckeys = Object.keys(codes);
for (var ck = 0; ck < ckeys.length; ck++) {
  var ckey = ckeys[ck];
  codes[codes[ckey]] = ckey;
}

Object.defineProperty(exports, 'codes', {
  enumerable: true, value: Object.freeze(codes), writable: false
});

exports.Deflate = Deflate;
exports.Inflate = Inflate;
exports.Gzip = Gzip;
exports.Gunzip = Gunzip;
exports.DeflateRaw = DeflateRaw;
exports.InflateRaw = InflateRaw;
exports.Unzip = Unzip;

exports.createDeflate = function (o) {
  return new Deflate(o);
};

exports.createInflate = function (o) {
  return new Inflate(o);
};

exports.createDeflateRaw = function (o) {
  return new DeflateRaw(o);
};

exports.createInflateRaw = function (o) {
  return new InflateRaw(o);
};

exports.createGzip = function (o) {
  return new Gzip(o);
};

exports.createGunzip = function (o) {
  return new Gunzip(o);
};

exports.createUnzip = function (o) {
  return new Unzip(o);
};

// Convenience methods.
// compress/decompress a string or buffer in one step.
exports.deflate = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Deflate(opts), buffer, callback);
};

exports.deflateSync = function (buffer, opts) {
  return zlibBufferSync(new Deflate(opts), buffer);
};

exports.gzip = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Gzip(opts), buffer, callback);
};

exports.gzipSync = function (buffer, opts) {
  return zlibBufferSync(new Gzip(opts), buffer);
};

exports.deflateRaw = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new DeflateRaw(opts), buffer, callback);
};

exports.deflateRawSync = function (buffer, opts) {
  return zlibBufferSync(new DeflateRaw(opts), buffer);
};

exports.unzip = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Unzip(opts), buffer, callback);
};

exports.unzipSync = function (buffer, opts) {
  return zlibBufferSync(new Unzip(opts), buffer);
};

exports.inflate = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Inflate(opts), buffer, callback);
};

exports.inflateSync = function (buffer, opts) {
  return zlibBufferSync(new Inflate(opts), buffer);
};

exports.gunzip = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Gunzip(opts), buffer, callback);
};

exports.gunzipSync = function (buffer, opts) {
  return zlibBufferSync(new Gunzip(opts), buffer);
};

exports.inflateRaw = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new InflateRaw(opts), buffer, callback);
};

exports.inflateRawSync = function (buffer, opts) {
  return zlibBufferSync(new InflateRaw(opts), buffer);
};

function zlibBuffer(engine, buffer, callback) {
  var buffers = [];
  var nread = 0;

  engine.on('error', onError);
  engine.on('end', onEnd);

  engine.end(buffer);
  flow();

  function flow() {
    var chunk;
    while (null !== (chunk = engine.read())) {
      buffers.push(chunk);
      nread += chunk.length;
    }
    engine.once('readable', flow);
  }

  function onError(err) {
    engine.removeListener('end', onEnd);
    engine.removeListener('readable', flow);
    callback(err);
  }

  function onEnd() {
    var buf;
    var err = null;

    if (nread >= kMaxLength) {
      err = new RangeError(kRangeErrorMessage);
    } else {
      buf = Buffer.concat(buffers, nread);
    }

    buffers = [];
    engine.close();
    callback(err, buf);
  }
}

function zlibBufferSync(engine, buffer) {
  if (typeof buffer === 'string') buffer = Buffer.from(buffer);

  if (!Buffer.isBuffer(buffer)) throw new TypeError('Not a string or buffer');

  var flushFlag = engine._finishFlushFlag;

  return engine._processChunk(buffer, flushFlag);
}

// generic zlib
// minimal 2-byte header
function Deflate(opts) {
  if (!(this instanceof Deflate)) return new Deflate(opts);
  Zlib.call(this, opts, binding.DEFLATE);
}

function Inflate(opts) {
  if (!(this instanceof Inflate)) return new Inflate(opts);
  Zlib.call(this, opts, binding.INFLATE);
}

// gzip - bigger header, same deflate compression
function Gzip(opts) {
  if (!(this instanceof Gzip)) return new Gzip(opts);
  Zlib.call(this, opts, binding.GZIP);
}

function Gunzip(opts) {
  if (!(this instanceof Gunzip)) return new Gunzip(opts);
  Zlib.call(this, opts, binding.GUNZIP);
}

// raw - no header
function DeflateRaw(opts) {
  if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);
  Zlib.call(this, opts, binding.DEFLATERAW);
}

function InflateRaw(opts) {
  if (!(this instanceof InflateRaw)) return new InflateRaw(opts);
  Zlib.call(this, opts, binding.INFLATERAW);
}

// auto-detect header.
function Unzip(opts) {
  if (!(this instanceof Unzip)) return new Unzip(opts);
  Zlib.call(this, opts, binding.UNZIP);
}

function isValidFlushFlag(flag) {
  return flag === binding.Z_NO_FLUSH || flag === binding.Z_PARTIAL_FLUSH || flag === binding.Z_SYNC_FLUSH || flag === binding.Z_FULL_FLUSH || flag === binding.Z_FINISH || flag === binding.Z_BLOCK;
}

// the Zlib class they all inherit from
// This thing manages the queue of requests, and returns
// true or false if there is anything in the queue when
// you call the .write() method.

function Zlib(opts, mode) {
  var _this = this;

  this._opts = opts = opts || {};
  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;

  Transform.call(this, opts);

  if (opts.flush && !isValidFlushFlag(opts.flush)) {
    throw new Error('Invalid flush flag: ' + opts.flush);
  }
  if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush)) {
    throw new Error('Invalid flush flag: ' + opts.finishFlush);
  }

  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;
  this._finishFlushFlag = typeof opts.finishFlush !== 'undefined' ? opts.finishFlush : binding.Z_FINISH;

  if (opts.chunkSize) {
    if (opts.chunkSize < exports.Z_MIN_CHUNK || opts.chunkSize > exports.Z_MAX_CHUNK) {
      throw new Error('Invalid chunk size: ' + opts.chunkSize);
    }
  }

  if (opts.windowBits) {
    if (opts.windowBits < exports.Z_MIN_WINDOWBITS || opts.windowBits > exports.Z_MAX_WINDOWBITS) {
      throw new Error('Invalid windowBits: ' + opts.windowBits);
    }
  }

  if (opts.level) {
    if (opts.level < exports.Z_MIN_LEVEL || opts.level > exports.Z_MAX_LEVEL) {
      throw new Error('Invalid compression level: ' + opts.level);
    }
  }

  if (opts.memLevel) {
    if (opts.memLevel < exports.Z_MIN_MEMLEVEL || opts.memLevel > exports.Z_MAX_MEMLEVEL) {
      throw new Error('Invalid memLevel: ' + opts.memLevel);
    }
  }

  if (opts.strategy) {
    if (opts.strategy != exports.Z_FILTERED && opts.strategy != exports.Z_HUFFMAN_ONLY && opts.strategy != exports.Z_RLE && opts.strategy != exports.Z_FIXED && opts.strategy != exports.Z_DEFAULT_STRATEGY) {
      throw new Error('Invalid strategy: ' + opts.strategy);
    }
  }

  if (opts.dictionary) {
    if (!Buffer.isBuffer(opts.dictionary)) {
      throw new Error('Invalid dictionary: it should be a Buffer instance');
    }
  }

  this._handle = new binding.Zlib(mode);

  var self = this;
  this._hadError = false;
  this._handle.onerror = function (message, errno) {
    // there is no way to cleanly recover.
    // continuing only obscures problems.
    _close(self);
    self._hadError = true;

    var error = new Error(message);
    error.errno = errno;
    error.code = exports.codes[errno];
    self.emit('error', error);
  };

  var level = exports.Z_DEFAULT_COMPRESSION;
  if (typeof opts.level === 'number') level = opts.level;

  var strategy = exports.Z_DEFAULT_STRATEGY;
  if (typeof opts.strategy === 'number') strategy = opts.strategy;

  this._handle.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);

  this._buffer = Buffer.allocUnsafe(this._chunkSize);
  this._offset = 0;
  this._level = level;
  this._strategy = strategy;

  this.once('end', this.close);

  Object.defineProperty(this, '_closed', {
    get: function () {
      return !_this._handle;
    },
    configurable: true,
    enumerable: true
  });
}

util.inherits(Zlib, Transform);

Zlib.prototype.params = function (level, strategy, callback) {
  if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {
    throw new RangeError('Invalid compression level: ' + level);
  }
  if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) {
    throw new TypeError('Invalid strategy: ' + strategy);
  }

  if (this._level !== level || this._strategy !== strategy) {
    var self = this;
    this.flush(binding.Z_SYNC_FLUSH, function () {
      assert(self._handle, 'zlib binding closed');
      self._handle.params(level, strategy);
      if (!self._hadError) {
        self._level = level;
        self._strategy = strategy;
        if (callback) callback();
      }
    });
  } else {
    process.nextTick(callback);
  }
};

Zlib.prototype.reset = function () {
  assert(this._handle, 'zlib binding closed');
  return this._handle.reset();
};

// This is the _flush function called by the transform class,
// internally, when the last chunk has been written.
Zlib.prototype._flush = function (callback) {
  this._transform(Buffer.alloc(0), '', callback);
};

Zlib.prototype.flush = function (kind, callback) {
  var _this2 = this;

  var ws = this._writableState;

  if (typeof kind === 'function' || kind === undefined && !callback) {
    callback = kind;
    kind = binding.Z_FULL_FLUSH;
  }

  if (ws.ended) {
    if (callback) process.nextTick(callback);
  } else if (ws.ending) {
    if (callback) this.once('end', callback);
  } else if (ws.needDrain) {
    if (callback) {
      this.once('drain', function () {
        return _this2.flush(kind, callback);
      });
    }
  } else {
    this._flushFlag = kind;
    this.write(Buffer.alloc(0), '', callback);
  }
};

Zlib.prototype.close = function (callback) {
  _close(this, callback);
  process.nextTick(emitCloseNT, this);
};

function _close(engine, callback) {
  if (callback) process.nextTick(callback);

  // Caller may invoke .close after a zlib error (which will null _handle).
  if (!engine._handle) return;

  engine._handle.close();
  engine._handle = null;
}

function emitCloseNT(self) {
  self.emit('close');
}

Zlib.prototype._transform = function (chunk, encoding, cb) {
  var flushFlag;
  var ws = this._writableState;
  var ending = ws.ending || ws.ended;
  var last = ending && (!chunk || ws.length === chunk.length);

  if (chunk !== null && !Buffer.isBuffer(chunk)) return cb(new Error('invalid input'));

  if (!this._handle) return cb(new Error('zlib binding closed'));

  // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag
  // (or whatever flag was provided using opts.finishFlush).
  // If it's explicitly flushing at some other time, then we use
  // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression
  // goodness.
  if (last) flushFlag = this._finishFlushFlag;else {
    flushFlag = this._flushFlag;
    // once we've flushed the last of the queue, stop flushing and
    // go back to the normal behavior.
    if (chunk.length >= ws.length) {
      this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;
    }
  }

  this._processChunk(chunk, flushFlag, cb);
};

Zlib.prototype._processChunk = function (chunk, flushFlag, cb) {
  var availInBefore = chunk && chunk.length;
  var availOutBefore = this._chunkSize - this._offset;
  var inOff = 0;

  var self = this;

  var async = typeof cb === 'function';

  if (!async) {
    var buffers = [];
    var nread = 0;

    var error;
    this.on('error', function (er) {
      error = er;
    });

    assert(this._handle, 'zlib binding closed');
    do {
      var res = this._handle.writeSync(flushFlag, chunk, // in
      inOff, // in_off
      availInBefore, // in_len
      this._buffer, // out
      this._offset, //out_off
      availOutBefore); // out_len
    } while (!this._hadError && callback(res[0], res[1]));

    if (this._hadError) {
      throw error;
    }

    if (nread >= kMaxLength) {
      _close(this);
      throw new RangeError(kRangeErrorMessage);
    }

    var buf = Buffer.concat(buffers, nread);
    _close(this);

    return buf;
  }

  assert(this._handle, 'zlib binding closed');
  var req = this._handle.write(flushFlag, chunk, // in
  inOff, // in_off
  availInBefore, // in_len
  this._buffer, // out
  this._offset, //out_off
  availOutBefore); // out_len

  req.buffer = chunk;
  req.callback = callback;

  function callback(availInAfter, availOutAfter) {
    // When the callback is used in an async write, the callback's
    // context is the `req` object that was created. The req object
    // is === this._handle, and that's why it's important to null
    // out the values after they are done being used. `this._handle`
    // can stay in memory longer than the callback and buffer are needed.
    if (this) {
      this.buffer = null;
      this.callback = null;
    }

    if (self._hadError) return;

    var have = availOutBefore - availOutAfter;
    assert(have >= 0, 'have should not go down');

    if (have > 0) {
      var out = self._buffer.slice(self._offset, self._offset + have);
      self._offset += have;
      // serve some output to the consumer.
      if (async) {
        self.push(out);
      } else {
        buffers.push(out);
        nread += out.length;
      }
    }

    // exhausted the output buffer, or used all the input create a new one.
    if (availOutAfter === 0 || self._offset >= self._chunkSize) {
      availOutBefore = self._chunkSize;
      self._offset = 0;
      self._buffer = Buffer.allocUnsafe(self._chunkSize);
    }

    if (availOutAfter === 0) {
      // Not actually done.  Need to reprocess.
      // Also, update the availInBefore to the availInAfter value,
      // so that if we have to hit it a third (fourth, etc.) time,
      // it'll have the correct byte counts.
      inOff += availInBefore - availInAfter;
      availInBefore = availInAfter;

      if (!async) return true;

      var newReq = self._handle.write(flushFlag, chunk, inOff, availInBefore, self._buffer, self._offset, self._chunkSize);
      newReq.callback = callback; // this same function
      newReq.buffer = chunk;
      return;
    }

    if (!async) return false;

    // finished with the chunk.
    cb();
  }
};

util.inherits(Deflate, Zlib);
util.inherits(Inflate, Zlib);
util.inherits(Gzip, Zlib);
util.inherits(Gunzip, Zlib);
util.inherits(DeflateRaw, Zlib);
util.inherits(InflateRaw, Zlib);
util.inherits(Unzip, Zlib);
}).call(this,require('_process'))

},{"./binding":7,"_process":30,"assert":1,"buffer":9,"stream":45,"util":51}],9:[function(require,module,exports){
(function (Buffer){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this,require("buffer").Buffer)

},{"base64-js":5,"buffer":9,"ieee754":12}],10:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

},{"../../is-buffer/index.js":15}],11:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var objectCreate = Object.create || objectCreatePolyfill
var objectKeys = Object.keys || objectKeysPolyfill
var bind = Function.prototype.bind || functionBindPolyfill

function EventEmitter() {
  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
    this._events = objectCreate(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

var hasDefineProperty;
try {
  var o = {};
  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
  hasDefineProperty = o.x === 0;
} catch (err) { hasDefineProperty = false }
if (hasDefineProperty) {
  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      // check whether the input is a positive number (whose value is zero or
      // greater and not a NaN).
      if (typeof arg !== 'number' || arg < 0 || arg !== arg)
        throw new TypeError('"defaultMaxListeners" must be a positive number');
      defaultMaxListeners = arg;
    }
  });
} else {
  EventEmitter.defaultMaxListeners = defaultMaxListeners;
}

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    if (arguments.length > 1)
      er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Unhandled "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
      // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
      // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = objectCreate(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
          listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
            existing.length + ' "' + String(type) + '" listeners ' +
            'added. Use emitter.setMaxListeners() to ' +
            'increase limit.');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        if (typeof console === 'object' && console.warn) {
          console.warn('%s: %s', w.name, w.message);
        }
      }
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    switch (arguments.length) {
      case 0:
        return this.listener.call(this.target);
      case 1:
        return this.listener.call(this.target, arguments[0]);
      case 2:
        return this.listener.call(this.target, arguments[0], arguments[1]);
      case 3:
        return this.listener.call(this.target, arguments[0], arguments[1],
            arguments[2]);
      default:
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i)
          args[i] = arguments[i];
        this.listener.apply(this.target, args);
    }
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = bind.call(onceWrapper, state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = objectCreate(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else
          spliceOne(list, position);

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = objectKeys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = objectCreate(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (!events)
    return [];

  var evlistener = events[type];
  if (!evlistener)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function objectCreatePolyfill(proto) {
  var F = function() {};
  F.prototype = proto;
  return new F;
}
function objectKeysPolyfill(obj) {
  var keys = [];
  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
    keys.push(k);
  }
  return k;
}
function functionBindPolyfill(context) {
  var fn = this;
  return function () {
    return fn.apply(context, arguments);
  };
}

},{}],12:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],13:[function(require,module,exports){
(function (Buffer){
function readUInt32(buffer, offset, bigEndian) {
	if (buffer.readUInt32) {
		return buffer.readUInt32(offset, bigEndian);
	}

	var value;
	if (bigEndian) {
		if (buffer.readUInt32BE) {
			return buffer.readUInt32BE(offset);
		}
		value = (buffer[offset] << 24) + (buffer[offset+1] << 16) + (buffer[offset+2] << 8) + buffer[offset+3];
	}
	else {
		if (buffer.readUInt32LE) {
			return buffer.readUInt32LE(offset);
		}
		value = buffer[offset] + (buffer[offset+1] << 8) + (buffer[offset+2] << 16) + (buffer[offset+3] << 24);
	}
	return value;
}

function readUInt16(buffer, offset, bigEndian) {
	if (buffer.readUInt16) {
		return buffer.readUInt16(offset, bigEndian);
	}

	var value;
	if (bigEndian) {
		if (buffer.readUInt16BE) {
			return buffer.readUInt16BE(offset);
		}
		value = (buffer[offset] << 8) + buffer[offset+1];
	}
	else {
		if (buffer.readUInt16LE) {
			return buffer.readUInt16LE(offset);
		}
		value = buffer[offset] + (buffer[offset+1] << 8);
	}
	return value;
}

function readBit(buffer, offset, bitOffset) {
	if (bitOffset > 7) {
		offset += Math.floor(bitOffset / 8);
		bitOffset = bitOffset % 8;
	}

	var b = buffer[offset];
	if (bitOffset < 7) {
		b >>>= (7 - bitOffset);
	}

	var val = b & 0x01;
	return val;
}

function readBits(buffer, offset, bitOffset, bitLen, signed) {
	var val = 0;
	
	var neg = false;
	if (signed) {
		if (readBit(buffer, offset, bitOffset) > 0) {
			neg = true;
		}
		bitLen--;
		bitOffset++;
	}

	var bytes = [];
	for (var i = 0; i < bitLen; i++) {
		var b = readBit(buffer, offset, bitOffset + i);
		if (i>0 && (bitLen - i) % 8 == 0) {
			bytes.push(val);
			val = 0;
		}
		val <<= 1;
		val |= b;
	}
	bytes.push(val);

	val = new Buffer(bytes);
	val.negative = neg?true:false;
	return val;
}

function imageInfoPng(buffer) {
	var imageHeader = [0x49, 0x48, 0x44, 0x52],
		pos = 12;

	if (!checkSig(buffer, pos, imageHeader)) {
		return false;
	}

	pos += 4;
	return {
		type: 'image',
		format: 'PNG',
		mimeType: 'image/png',
		width: readUInt32(buffer, pos, true),
		height: readUInt32(buffer, pos+4, true),
	};
}

function imageInfoJpg(buffer) {
	var pos = 2,
		len = buffer.length,
		sizeSig = [0xff, [0xc0, 0xc2]];

	while (pos < len) {
		if (checkSig(buffer, pos, sizeSig)) {
			pos += 5;
			return {
				type: 'image',
				format: 'JPG',
				mimeType: 'image/jpeg',
				width: readUInt16(buffer, pos+2, true),
				height: readUInt16(buffer, pos, true),
			};
		}

		pos += 2;
		var size = readUInt16(buffer, pos, true);
		pos += size;
	}
}

function imageInfoGif(buffer) {
	var pos = 6;

	return {
		type: 'image',
		format: 'GIF',
		mimeType: 'image/gif',
		width: readUInt16(buffer, pos, false),
		height: readUInt16(buffer, pos+2, false),
	};
}

function imageInfoSwf(buffer) {
	var pos = 8,
		bitPos = 0,
		val;

	if (buffer[0] === 0x43) {
		try {
			// If you have zlib available ( npm install zlib ) then we can read compressed flash files
			buffer = require('zlib').inflate(buffer.slice(8, 100));
			pos = 0;
		}
		catch (ex) {
			// Can't get width/height of compressed flash files... yet (need zlib)
			return {
				type: 'flash',
				format: 'SWF',
				mimeType: 'application/x-shockwave-flash',
				width: null,
				height: null,
			}
		}
	}

	var numBits = readBits(buffer, pos, bitPos, 5)[0];
	bitPos += 5;
	
	val = readBits(buffer, pos, bitPos, numBits, true);
	var xMin = (numBits > 9 ? readUInt16(val, 0, true) : val[0]) * (val.negative ? -1 : 1);
	bitPos += numBits;

	val = readBits(buffer, pos, bitPos, numBits, true);
	var xMax = (numBits > 9 ? readUInt16(val, 0, true) : val[0]) * (val.negative ? -1 : 1);
	bitPos += numBits;

	val = readBits(buffer, pos, bitPos, numBits, true);
	var yMin = (numBits > 9 ? readUInt16(val, 0, true) : val[0]) * (val.negative ? -1 : 1);
	bitPos += numBits;

	val = readBits(buffer, pos, bitPos, numBits, true);
	var yMax = (numBits > 9 ? readUInt16(val, 0, true) : val[0]) * (val.negative ? -1 : 1);

	return {
		type: 'flash',
		format: 'SWF',
		mimeType: 'application/x-shockwave-flash',
		width: Math.ceil((xMax - xMin) / 20),
		height: Math.ceil((yMax - yMin) / 20),
	};
}

function checkSig(buffer, offset, sig) {
	var len = sig.length;
	for (var i = 0; i < len; i++) {
		var b = buffer[i+offset],
			s = sig[i],
			m = false;

		if ('number' == typeof s) {
			m = s === b;
		}
		else {
			for (var k in s) {
				var o = s[k];
				if (o === b) {
					m = true;
				}
			}
		}

		if (!m) {
			return false;
		}
	}

	return true;
}

module.exports = function imageInfo(buffer, path) {
	var pngSig = [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a];
	var jpgSig = [0xff, 0xd8, 0xff];
	var gifSig = [0x47, 0x49, 0x46, 0x38, [0x37, 0x39], 0x61];
	var swfSig = [[0x46, 0x43], 0x57, 0x53];

	if (checkSig(buffer, 0, pngSig)) return imageInfoPng(buffer);
	if (checkSig(buffer, 0, jpgSig)) return imageInfoJpg(buffer);
	if (checkSig(buffer, 0, gifSig)) return imageInfoGif(buffer);
	if (checkSig(buffer, 0, swfSig)) return imageInfoSwf(buffer);

	return false;
};


}).call(this,require("buffer").Buffer)

},{"buffer":9,"zlib":8}],14:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],15:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],16:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],17:[function(require,module,exports){
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

'use strict';
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],18:[function(require,module,exports){
'use strict';


var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
                (typeof Uint16Array !== 'undefined') &&
                (typeof Int32Array !== 'undefined');

function _has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) { return buf; }
  if (buf.subarray) { return buf.subarray(0, size); }
  buf.length = size;
  return buf;
};


var fnTyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    return [].concat.apply([], chunks);
  }
};


// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8  = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8  = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);

},{}],19:[function(require,module,exports){
'use strict';

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function adler32(adler, buf, len, pos) {
  var s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
}


module.exports = adler32;

},{}],20:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

},{}],21:[function(require,module,exports){
'use strict';

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
function makeTable() {
  var c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
}


module.exports = crc32;

},{}],22:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils   = require('../utils/common');
var trees   = require('./trees');
var adler32 = require('./adler32');
var crc32   = require('./crc32');
var msg     = require('./messages');

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
var Z_NO_FLUSH      = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
//var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;


/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION = -1;


var Z_FILTERED            = 1;
var Z_HUFFMAN_ONLY        = 2;
var Z_RLE                 = 3;
var Z_FIXED               = 4;
var Z_DEFAULT_STRATEGY    = 0;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;


/* The deflate compression method */
var Z_DEFLATED  = 8;

/*============================================================================*/


var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_MEM_LEVEL = 8;


var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
var LITERALS      = 256;
/* number of literal bytes 0..255 */
var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
var D_CODES       = 30;
/* number of distance codes */
var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
var MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

var PRESET_DICT = 0x20;

var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;

var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
var BS_BLOCK_DONE     = 2; /* block flush performed */
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
}

function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function flush_pending(strm) {
  var s = strm.state;

  //_tr_flush_bits(s);
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}


function flush_block_only(s, last) {
  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}


function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function putShortMSB(s, b) {
//  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  utils.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
}


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;      /* max hash chain length */
  var scan = s.strstart; /* current string */
  var match;                       /* matched string */
  var len;                           /* length of current match */
  var best_len = s.prev_length;              /* best match length so far */
  var nice_match = s.nice_match;             /* stop if match long enough */
  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1  = _win[scan + best_len - 1];
  var scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    var curr = s.strstart + s.lookahead;
//    var init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function deflate_fast(s, flush) {
  var hash_head;        /* head of the hash chain */
  var bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function deflate_slow(s, flush) {
  var hash_head;          /* head of hash chain */
  var bflush;              /* set if current block must be flushed */

  var max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
}


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function deflate_rle(s, flush) {
  var bflush;            /* set if current block must be flushed */
  var prev;              /* byte at distance one to match */
  var scan, strend;      /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function deflate_huff(s, flush) {
  var bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;

configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function lm_init(s) {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  trees._tr_init(s);
  return Z_OK;
}


function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}


function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  return Z_OK;
}


function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  var s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new utils.Buf8(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}


function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
        );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
      var level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}


exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

},{"../utils/common":18,"./adler32":19,"./crc32":21,"./messages":26,"./trees":27}],23:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
var BAD = 30;       /* got a data error -- remain here until reset */
var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  var state;
  var _in;                    /* local strm.input */
  var last;                   /* have enough input while in < last */
  var _out;                   /* local strm.output */
  var beg;                    /* inflate()'s initial strm.output */
  var end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  var dmax;                   /* maximum distance from zlib header */
//#endif
  var wsize;                  /* window size or zero if not using window */
  var whave;                  /* valid bytes in the window */
  var wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  var s_window;               /* allocated sliding window, if wsize != 0 */
  var hold;                   /* local strm.hold */
  var bits;                   /* local strm.bits */
  var lcode;                  /* local strm.lencode */
  var dcode;                  /* local strm.distcode */
  var lmask;                  /* mask for first level of length codes */
  var dmask;                  /* mask for first level of distance codes */
  var here;                   /* retrieved table entry */
  var op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  var len;                    /* match length, unused bytes */
  var dist;                   /* match distance */
  var from;                   /* where to copy match from */
  var from_source;


  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};

},{}],24:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils         = require('../utils/common');
var adler32       = require('./adler32');
var crc32         = require('./crc32');
var inflate_fast  = require('./inffast');
var inflate_table = require('./inftrees');

var CODES = 0;
var LENS = 1;
var DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var Z_DEFLATED  = 8;


/* STATES ====================================================================*/
/* ===========================================================================*/


var    HEAD = 1;       /* i: waiting for magic header */
var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
var    TIME = 3;       /* i: waiting for modification time (gzip) */
var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
var    NAME = 7;       /* i: waiting for end of file name (gzip) */
var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
var    HCRC = 9;       /* i: waiting for header crc (gzip) */
var    DICTID = 10;    /* i: waiting for dictionary check value */
var    DICT = 11;      /* waiting for inflateSetDictionary() call */
var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
var        STORED = 14;    /* i: waiting for stored size (length and complement) */
var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
var        LENLENS = 18;   /* i: waiting for code length code lengths */
var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
var            LEN = 21;       /* i: waiting for length/lit/eob code */
var            LENEXT = 22;    /* i: waiting for length extra bits */
var            DIST = 23;      /* i: waiting for distance code */
var            DISTEXT = 24;   /* i: waiting for distance extra bits */
var            MATCH = 25;     /* o: waiting for output space to copy string */
var            LIT = 26;       /* o: waiting for output space to write literal */
var    CHECK = 27;     /* i: waiting for 32-bit check value */
var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
var    DONE = 29;      /* finished check, done -- remain here until reset */
var    BAD = 30;       /* got a data error -- remain here until reset */
var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_WBITS = MAX_WBITS;


function zswap32(q) {
  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
}


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
  this.work = new utils.Buf16(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) { return Z_STREAM_ERROR; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var virgin = true;

var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;

    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);

    /* literal/length table */
    sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new utils.Buf8(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output;          // input/output buffers
  var next;                   /* next input INDEX */
  var put;                    /* next output INDEX */
  var have, left;             /* available input and output */
  var hold;                   /* bit buffer */
  var bits;                   /* bits in bit buffer */
  var _in, _out;              /* save starting available input and output */
  var copy;                   /* number of stored or match bytes to copy */
  var from;                   /* where to copy match bytes from */
  var from_source;
  var here = 0;               /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  var len;                    /* length to copy for repeats, bits to drop */
  var ret;                    /* return code */
  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
  var opts;

  var n; // temporary var for NEED_BITS

  var order = /* permutation of code lengths */
    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
          state.check = 0/*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        state.flags = 0;           /* expect zlib header */
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }
        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f)/*BITS(4)*/ + 8;
        if (state.wbits === 0) {
          state.wbits = len;
        }
        else if (len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }
        state.dmax = 1 << len;
        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }
        if (state.head) {
          state.head.text = ((hold >> 8) & 1);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
        /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          hbuf[2] = (hold >>> 16) & 0xff;
          hbuf[3] = (hold >>> 24) & 0xff;
          state.check = crc32(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
        /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = (hold & 0xff);
          state.head.os = (hold >> 8);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
        /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        else if (state.head) {
          state.head.extra = null/*Z_NULL*/;
        }
        state.mode = EXTRA;
        /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) { copy = have; }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Array(state.head.extra_len);
              }
              utils.arraySet(
                state.head.extra,
                input,
                next,
                // extra field is limited to 65536 bytes
                // - no need for additional size check
                copy,
                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                len
              );
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if (state.flags & 0x0200) {
              state.check = crc32(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) { break inf_leave; }
        }
        state.length = 0;
        state.mode = NAME;
        /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.name_max*/)) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
        /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.comm_max*/)) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
        /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = ((state.flags >> 9) & 1);
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
        /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT;
        }
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE;
        /* falls through */
      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = (hold & 0x01)/*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch ((hold & 0x03)/*BITS(2)*/) {
          case 0:                             /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:                             /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_;             /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:                             /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case COPY_:
        state.mode = COPY;
        /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) { copy = have; }
          if (copy > left) { copy = left; }
          if (copy === 0) { break inf_leave; }
          //--- zmemcpy(put, next, copy); ---
          utils.arraySet(output, input, next, copy, put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
//#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
        /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
        /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          }
          else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03);//BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            }
            else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07);//BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            }
            else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f);//BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD) { break; }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case LEN_:
        state.mode = LEN;
        /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inflate_fast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
        /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
        /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }
        state.offset = here_val;
        state.extra = (here_op) & 15;
        state.mode = DISTEXT;
        /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
//#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
        /* falls through */
      case MATCH:
        if (left === 0) { break inf_leave; }
        copy = _out - left;
        if (state.offset > copy) {         /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          }
          else {
            from = state.wnext - copy;
          }
          if (copy > state.length) { copy = state.length; }
          from_source = state.window;
        }
        else {                              /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) { copy = left; }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) { state.mode = LEN; }
        break;
      case LIT:
        if (left === 0) { break inf_leave; }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if (_out) {
            strm.adler = state.check =
                /*UPDATE(state.check, put - _out, _out);*/
                (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
        /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
        /* falls through */
      case DONE:
        ret = Z_STREAM_END;
        break inf_leave;
      case BAD:
        ret = Z_DATA_ERROR;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR;
      case SYNC:
        /* falls through */
      default:
        return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}

function inflateEnd(strm) {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR;
  }

  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var state;
  var dictid;
  var ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
}

exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/

},{"../utils/common":18,"./adler32":19,"./crc32":21,"./inffast":23,"./inftrees":25}],25:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = require('../utils/common');

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

var lbase = [ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
];

var lext = [ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
];

var dbase = [ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
];

var dext = [ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
{
  var bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  var len = 0;               /* a code's length in bits */
  var sym = 0;               /* index of code symbols */
  var min = 0, max = 0;          /* minimum and maximum code lengths */
  var root = 0;              /* number of index bits for root table */
  var curr = 0;              /* number of index bits for current table */
  var drop = 0;              /* code bits to drop for sub-table */
  var left = 0;                   /* number of prefix codes available */
  var used = 0;              /* code entries in table used */
  var huff = 0;              /* Huffman code */
  var incr;              /* for incrementing code, index */
  var fill;              /* index for replicating entries */
  var low;               /* low bits for current root entry */
  var mask;              /* mask for low root bits */
  var next;             /* next available space in table */
  var base = null;     /* base value table to use */
  var base_index = 0;
//  var shoextra;    /* extra bits table to use */
  var end;                    /* use base and extra for symbol > end */
  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;

  var here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};

},{"../utils/common":18}],26:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

},{}],27:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

/* eslint-disable space-unary-ops */

var utils = require('../utils/common');

/* Public constants ==========================================================*/
/* ===========================================================================*/


//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;
var Z_FIXED               = 4;
//var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
var Z_BINARY              = 0;
var Z_TEXT                = 1;
//var Z_ASCII             = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;

/*============================================================================*/


function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES    = 2;
/* The three kinds of block type */

var MIN_MATCH    = 3;
var MAX_MATCH    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS      = 256;
/* number of literal bytes 0..255 */

var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES       = 30;
/* number of distance codes */

var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS      = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK   = 256;
/* end of block literal code */

var REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
var extra_lbits =   /* extra bits for each length code */
  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];

var extra_dbits =   /* extra bits for each distance code */
  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];

var extra_blbits =  /* extra bits for each bit length code */
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];

var bl_order =
  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
var static_ltree  = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree  = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code    = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length   = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist     = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


var static_l_desc;
var static_d_desc;
var static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
function put_short(s, w) {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
}


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
function send_bits(s, value, length) {
  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
}


function send_code(s, c, tree) {
  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
}


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
function gen_bitlen(s, desc)
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree            = desc.dyn_tree;
  var max_code        = desc.max_code;
  var stree           = desc.stat_desc.static_tree;
  var has_stree       = desc.stat_desc.has_stree;
  var extra           = desc.stat_desc.extra_bits;
  var base            = desc.stat_desc.extra_base;
  var max_length      = desc.stat_desc.max_length;
  var h;              /* heap index */
  var n, m;           /* iterate over the tree elements */
  var bits;           /* bit length */
  var xbits;          /* extra bits */
  var f;              /* frequency */
  var overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
}


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
function gen_codes(tree, max_code, bl_count)
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  var code = 0;              /* running code value */
  var bits;                  /* bit index */
  var n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    var len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
function tr_static_init() {
  var n;        /* iterates over tree elements */
  var bits;     /* bit counter */
  var length;   /* length value */
  var code;     /* code value */
  var dist;     /* distance index */
  var bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
}


/* ===========================================================================
 * Initialize a new block.
 */
function init_block(s) {
  var n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
function bi_windup(s)
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
function copy_block(s, buf, len, header)
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
function smaller(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
}

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
function pqdownheap(s, tree, k)
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
}


// inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
function compress_block(s, ltree, dtree)
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist;           /* distance of matched string */
  var lc;             /* match length or unmatched char (if dist == 0) */
  var lx = 0;         /* running index in l_buf */
  var code;           /* the code to send */
  var extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
function build_tree(s, desc)
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree     = desc.dyn_tree;
  var stree    = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems    = desc.stat_desc.elems;
  var n, m;          /* iterate over heap elements */
  var max_code = -1; /* largest code with non zero frequency */
  var node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
}


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
function scan_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
function send_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
function build_bl_tree(s) {
  var max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
function send_all_trees(s, lcodes, dcodes, blcodes)
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
}


var static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
function _tr_init(s)
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
}


/* ===========================================================================
 * Send a stored block
 */
function _tr_stored_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
}


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
function _tr_flush_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  var max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
function _tr_tally(s, dist, lc)
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

exports._tr_init  = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block  = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;

},{"../utils/common":18}],28:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;

},{}],29:[function(require,module,exports){
(function (process){
'use strict';

if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


}).call(this,require('_process'))

},{"_process":30}],30:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],31:[function(require,module,exports){
module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":32}],32:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"./_stream_readable":34,"./_stream_writable":36,"core-util-is":10,"inherits":14,"process-nextick-args":29}],33:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":35,"core-util-is":10,"inherits":14}],34:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./_stream_duplex":32,"./internal/streams/BufferList":37,"./internal/streams/destroy":38,"./internal/streams/stream":39,"_process":30,"core-util-is":10,"events":11,"inherits":14,"isarray":16,"process-nextick-args":29,"safe-buffer":44,"string_decoder/":46,"util":6}],35:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":32,"core-util-is":10,"inherits":14}],36:[function(require,module,exports){
(function (process,global,setImmediate){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)

},{"./_stream_duplex":32,"./internal/streams/destroy":38,"./internal/streams/stream":39,"_process":30,"core-util-is":10,"inherits":14,"process-nextick-args":29,"safe-buffer":44,"timers":47,"util-deprecate":48}],37:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":44,"util":6}],38:[function(require,module,exports){
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":29}],39:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":11}],40:[function(require,module,exports){
module.exports = require('./readable').PassThrough

},{"./readable":41}],41:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":32,"./lib/_stream_passthrough.js":33,"./lib/_stream_readable.js":34,"./lib/_stream_transform.js":35,"./lib/_stream_writable.js":36}],42:[function(require,module,exports){
module.exports = require('./readable').Transform

},{"./readable":41}],43:[function(require,module,exports){
module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":36}],44:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":9}],45:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":11,"inherits":14,"readable-stream/duplex.js":31,"readable-stream/passthrough.js":40,"readable-stream/readable.js":41,"readable-stream/transform.js":42,"readable-stream/writable.js":43}],46:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":44}],47:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

},{"process/browser.js":30,"timers":47}],48:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],49:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"dup":2}],50:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"dup":3}],51:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":50,"_process":30,"inherits":49}],52:[function(require,module,exports){
var bundleFn = arguments[3];
var sources = arguments[4];
var cache = arguments[5];

var stringify = JSON.stringify;

module.exports = function (fn, options) {
    var wkey;
    var cacheKeys = Object.keys(cache);

    for (var i = 0, l = cacheKeys.length; i < l; i++) {
        var key = cacheKeys[i];
        var exp = cache[key].exports;
        // Using babel as a transpiler to use esmodule, the export will always
        // be an object with the default export as a property of it. To ensure
        // the existing api and babel esmodule exports are both supported we
        // check for both
        if (exp === fn || exp && exp.default === fn) {
            wkey = key;
            break;
        }
    }

    if (!wkey) {
        wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
        var wcache = {};
        for (var i = 0, l = cacheKeys.length; i < l; i++) {
            var key = cacheKeys[i];
            wcache[key] = key;
        }
        sources[wkey] = [
            'function(require,module,exports){' + fn + '(self); }',
            wcache
        ];
    }
    var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);

    var scache = {}; scache[wkey] = wkey;
    sources[skey] = [
        'function(require,module,exports){' +
            // try to call default if defined to also support babel esmodule exports
            'var f = require(' + stringify(wkey) + ');' +
            '(f.default ? f.default : f)(self);' +
        '}',
        scache
    ];

    var workerSources = {};
    resolveSources(skey);

    function resolveSources(key) {
        workerSources[key] = true;

        for (var depPath in sources[key][1]) {
            var depKey = sources[key][1][depPath];
            if (!workerSources[depKey]) {
                resolveSources(depKey);
            }
        }
    }

    var src = '(' + bundleFn + ')({'
        + Object.keys(workerSources).map(function (key) {
            return stringify(key) + ':['
                + sources[key][0]
                + ',' + stringify(sources[key][1]) + ']'
            ;
        }).join(',')
        + '},{},[' + stringify(skey) + '])'
    ;

    var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;

    var blob = new Blob([src], { type: 'text/javascript' });
    if (options && options.bare) { return blob; }
    var workerUrl = URL.createObjectURL(blob);
    var worker = new Worker(workerUrl);
    worker.objectURL = workerUrl;
    return worker;
};

},{}],53:[function(require,module,exports){
"use strict";

var _main = _interopRequireDefault(require("./main"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

module.exports = _main["default"];

},{"./main":69}],54:[function(require,module,exports){
(function (Buffer){
"use strict";

function _typeof2(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

(function webpackUniversalModuleDefinition(root, factory) {
  if ((typeof exports === "undefined" ? "undefined" : _typeof2(exports)) === 'object' && (typeof module === "undefined" ? "undefined" : _typeof2(module)) === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define([], factory);else if ((typeof exports === "undefined" ? "undefined" : _typeof2(exports)) === 'object') exports["ExifReader"] = factory();else root["ExifReader"] = factory();
})(typeof self !== 'undefined' ? self : void 0, function () {
  return (
    /******/
    function (modules) {
      // webpackBootstrap

      /******/
      // The module cache

      /******/
      var installedModules = {};
      /******/

      /******/
      // The require function

      /******/

      function __webpack_require__(moduleId) {
        /******/

        /******/
        // Check if module is in cache

        /******/
        if (installedModules[moduleId]) {
          /******/
          return installedModules[moduleId].exports;
          /******/
        }
        /******/
        // Create a new module (and put it into the cache)

        /******/


        var module = installedModules[moduleId] = {
          /******/
          i: moduleId,

          /******/
          l: false,

          /******/
          exports: {}
          /******/

        };
        /******/

        /******/
        // Execute the module function

        /******/

        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/

        /******/
        // Flag the module as loaded

        /******/

        module.l = true;
        /******/

        /******/
        // Return the exports of the module

        /******/

        return module.exports;
        /******/
      }
      /******/

      /******/

      /******/
      // expose the modules object (__webpack_modules__)

      /******/


      __webpack_require__.m = modules;
      /******/

      /******/
      // expose the module cache

      /******/

      __webpack_require__.c = installedModules;
      /******/

      /******/
      // define getter function for harmony exports

      /******/

      __webpack_require__.d = function (exports, name, getter) {
        /******/
        if (!__webpack_require__.o(exports, name)) {
          /******/
          Object.defineProperty(exports, name, {
            enumerable: true,
            get: getter
          });
          /******/
        }
        /******/

      };
      /******/

      /******/
      // define __esModule on exports

      /******/


      __webpack_require__.r = function (exports) {
        /******/
        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
          /******/
          Object.defineProperty(exports, Symbol.toStringTag, {
            value: 'Module'
          });
          /******/
        }
        /******/


        Object.defineProperty(exports, '__esModule', {
          value: true
        });
        /******/
      };
      /******/

      /******/
      // create a fake namespace object

      /******/
      // mode & 1: value is a module id, require it

      /******/
      // mode & 2: merge all properties of value into the ns

      /******/
      // mode & 4: return value when already ns object

      /******/
      // mode & 8|1: behave like require

      /******/


      __webpack_require__.t = function (value, mode) {
        /******/
        if (mode & 1) value = __webpack_require__(value);
        /******/

        if (mode & 8) return value;
        /******/

        if (mode & 4 && _typeof2(value) === 'object' && value && value.__esModule) return value;
        /******/

        var ns = Object.create(null);
        /******/

        __webpack_require__.r(ns);
        /******/


        Object.defineProperty(ns, 'default', {
          enumerable: true,
          value: value
        });
        /******/

        if (mode & 2 && typeof value != 'string') for (var key in value) {
          __webpack_require__.d(ns, key, function (key) {
            return value[key];
          }.bind(null, key));
        }
        /******/

        return ns;
        /******/
      };
      /******/

      /******/
      // getDefaultExport function for compatibility with non-harmony modules

      /******/


      __webpack_require__.n = function (module) {
        /******/
        var getter = module && module.__esModule ?
        /******/
        function getDefault() {
          return module['default'];
        } :
        /******/
        function getModuleExports() {
          return module;
        };
        /******/

        __webpack_require__.d(getter, 'a', getter);
        /******/


        return getter;
        /******/
      };
      /******/

      /******/
      // Object.prototype.hasOwnProperty.call

      /******/


      __webpack_require__.o = function (object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      /******/

      /******/
      // __webpack_public_path__

      /******/


      __webpack_require__.p = "";
      /******/

      /******/

      /******/
      // Load entry module and return exports

      /******/

      return __webpack_require__(__webpack_require__.s = "./src/exif-reader.js");
      /******/
    }(
    /************************************************************************/

    /******/
    {
      /***/
      "./src/byte-order.js":
      /*!***************************!*\
        !*** ./src/byte-order.js ***!
        \***************************/

      /*! exports provided: default */

      /***/
      function srcByteOrderJs(module, __webpack_exports__, __webpack_require__) {
        "use strict";

        __webpack_require__.r(__webpack_exports__);
        /* This Source Code Form is subject to the terms of the Mozilla Public
         * License, v. 2.0. If a copy of the MPL was not distributed with this
         * file, You can obtain one at https://mozilla.org/MPL/2.0/. */


        var LITTLE_ENDIAN = 0x4949;
        var BIG_ENDIAN = 0x4d4d;
        /* harmony default export */

        __webpack_exports__["default"] = {
          BIG_ENDIAN: BIG_ENDIAN,
          LITTLE_ENDIAN: LITTLE_ENDIAN,
          getByteOrder: getByteOrder
        };

        function getByteOrder(dataView, tiffHeaderOffset) {
          if (dataView.getUint16(tiffHeaderOffset) === LITTLE_ENDIAN) {
            return LITTLE_ENDIAN;
          } else if (dataView.getUint16(tiffHeaderOffset) === BIG_ENDIAN) {
            return BIG_ENDIAN;
          }

          throw new Error('Illegal byte order value. Faulty image.');
        }
        /***/

      },

      /***/
      "./src/constants.js":
      /*!**************************!*\
        !*** ./src/constants.js ***!
        \**************************/

      /*! exports provided: default */

      /***/
      function srcConstantsJs(module, __webpack_exports__, __webpack_require__) {
        "use strict";

        __webpack_require__.r(__webpack_exports__);
        /* This Source Code Form is subject to the terms of the Mozilla Public
         * License, v. 2.0. If a copy of the MPL was not distributed with this
         * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

        /* harmony default export */


        __webpack_exports__["default"] = {
          USE_FILE: true,
          USE_PNG_FILE: true,
          USE_EXIF: true,
          USE_IPTC: true,
          USE_XMP: true,
          USE_ICC: true,
          USE_THUMBNAIL: true,
          USE_TIFF: true,
          USE_JPEG: true,
          USE_PNG: true,
          USE_HEIC: true,
          USE_WEBP: true
        };
        /***/
      },

      /***/
      "./src/dataview.js":
      /*!*************************!*\
        !*** ./src/dataview.js ***!
        \*************************/

      /*! exports provided: default */

      /***/
      function srcDataviewJs(module, __webpack_exports__, __webpack_require__) {
        "use strict";

        __webpack_require__.r(__webpack_exports__);
        /* harmony export (binding) */


        __webpack_require__.d(__webpack_exports__, "default", function () {
          return DataView;
        });

        function _typeof(obj) {
          "@babel/helpers - typeof";

          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
          }

          return _typeof(obj);
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps) _defineProperties(Constructor.prototype, protoProps);
          if (staticProps) _defineProperties(Constructor, staticProps);
          return Constructor;
        }

        var DataView = /*#__PURE__*/function () {
          function DataView(buffer) {
            _classCallCheck(this, DataView);

            if (bufferTypeIsUnsupported(buffer)) {
              throw new Error('DataView: Passed buffer type is unsupported.');
            }

            this.buffer = buffer;
            this.byteLength = this.buffer.length;
          }

          _createClass(DataView, [{
            key: "getUint8",
            value: function getUint8(offset) {
              return this.buffer.readUInt8(offset);
            }
          }, {
            key: "getUint16",
            value: function getUint16(offset, littleEndian) {
              if (littleEndian) {
                return this.buffer.readUInt16LE(offset);
              }

              return this.buffer.readUInt16BE(offset);
            }
          }, {
            key: "getUint32",
            value: function getUint32(offset, littleEndian) {
              if (littleEndian) {
                return this.buffer.readUInt32LE(offset);
              }

              return this.buffer.readUInt32BE(offset);
            }
          }, {
            key: "getInt32",
            value: function getInt32(offset, littleEndian) {
              if (littleEndian) {
                return this.buffer.readInt32LE(offset);
              }

              return this.buffer.readInt32BE(offset);
            }
          }]);

          return DataView;
        }();

        function bufferTypeIsUnsupported(buffer) {
          return _typeof(buffer) !== 'object' || buffer.length === undefined || buffer.readUInt8 === undefined || buffer.readUInt16LE === undefined || buffer.readUInt16BE === undefined || buffer.readUInt32LE === undefined || buffer.readUInt32BE === undefined || buffer.readInt32LE === undefined || buffer.readInt32BE === undefined;
        }
        /***/

      },

      /***/
      "./src/dom-parser.js":
      /*!***************************!*\
        !*** ./src/dom-parser.js ***!
        \***************************/

      /*! exports provided: default */

      /***/
      function srcDomParserJs(module, __webpack_exports__, __webpack_require__) {
        "use strict";

        __webpack_require__.r(__webpack_exports__);
        /* This Source Code Form is subject to the terms of the Mozilla Public
         * License, v. 2.0. If a copy of the MPL was not distributed with this
         * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

        /* harmony default export */


        __webpack_exports__["default"] = {
          get: get
        };

        function get() {
          if (typeof DOMParser !== 'undefined') {
            return DOMParser;
          }

          try {
            return eval('require')('xmldom').DOMParser; // This stops Webpack from replacing the require with a generic import and bundling the module.
          } catch (error) {
            return undefined;
          }
        }
        /***/

      },

      /***/
      "./src/errors.js":
      /*!***********************!*\
        !*** ./src/errors.js ***!
        \***********************/

      /*! exports provided: default */

      /***/
      function srcErrorsJs(module, __webpack_exports__, __webpack_require__) {
        "use strict";

        __webpack_require__.r(__webpack_exports__);
        /* This Source Code Form is subject to the terms of the Mozilla Public
         * License, v. 2.0. If a copy of the MPL was not distributed with this
         * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

        /**
         * Thrown when no Exif metadata was found for the given image.
         *
         * @param {string} message The error message.
         */


        function MetadataMissingError(message) {
          this.name = 'MetadataMissingError';
          this.message = message || 'No Exif data';
          this.stack = new Error().stack;
        }

        MetadataMissingError.prototype = new Error();
        /* harmony default export */

        __webpack_exports__["default"] = {
          MetadataMissingError: MetadataMissingError
        };
        /***/
      },

      /***/
      "./src/exif-reader.js":
      /*!****************************!*\
        !*** ./src/exif-reader.js ***!
        \****************************/

      /*! exports provided: default, errors, load, loadView */

      /***/
      function srcExifReaderJs(module, __webpack_exports__, __webpack_require__) {
        "use strict";

        __webpack_require__.r(__webpack_exports__);
        /* harmony export (binding) */


        __webpack_require__.d(__webpack_exports__, "errors", function () {
          return errors;
        });
        /* harmony export (binding) */


        __webpack_require__.d(__webpack_exports__, "load", function () {
          return load;
        });
        /* harmony export (binding) */


        __webpack_require__.d(__webpack_exports__, "loadView", function () {
          return loadView;
        });
        /* harmony import */


        var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        /*! ./utils.js */
        "./src/utils.js");
        /* harmony import */


        var _dataview_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
        /*! ./dataview.js */
        "./src/dataview.js");
        /* harmony import */


        var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
        /*! ./constants.js */
        "./src/constants.js");
        /* harmony import */


        var _tag_names_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
        /*! ./tag-names-utils.js */
        "./src/tag-names-utils.js");
        /* harmony import */


        var _image_header_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
        /*! ./image-header.js */
        "./src/image-header.js");
        /* harmony import */


        var _tags_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
        /*! ./tags.js */
        "./src/tags.js");
        /* harmony import */


        var _file_tags_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
        /*! ./file-tags.js */
        "./src/file-tags.js");
        /* harmony import */


        var _iptc_tags_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
        /*! ./iptc-tags.js */
        "./src/iptc-tags.js");
        /* harmony import */


        var _xmp_tags_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
        /*! ./xmp-tags.js */
        "./src/xmp-tags.js");
        /* harmony import */


        var _icc_tags_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
        /*! ./icc-tags.js */
        "./src/icc-tags.js");
        /* harmony import */


        var _png_file_tags_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
        /*! ./png-file-tags.js */
        "./src/png-file-tags.js");
        /* harmony import */


        var _thumbnail_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(
        /*! ./thumbnail.js */
        "./src/thumbnail.js");
        /* harmony import */


        var _errors_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(
        /*! ./errors.js */
        "./src/errors.js");
        /**
         * ExifReader
         * http://github.com/mattiasw/exifreader
         * Copyright (C) 2011-2020  Mattias Wallander <mattias@wallander.eu>
         * This Source Code Form is subject to the terms of the Mozilla Public
         * License, v. 2.0. If a copy of the MPL was not distributed with this
         * file, You can obtain one at https://mozilla.org/MPL/2.0/.
         */

        /* harmony default export */


        __webpack_exports__["default"] = {
          load: load,
          loadView: loadView,
          errors: _errors_js__WEBPACK_IMPORTED_MODULE_12__["default"]
        };
        var errors = _errors_js__WEBPACK_IMPORTED_MODULE_12__["default"];

        function load(data) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
            expanded: false
          };

          if (isNodeBuffer(data)) {
            // File data read in Node can share the underlying buffer with other
            // data. Therefore it's safest to get a new one to avoid weird bugs.
            data = new Uint8Array(data).buffer;
          }

          return loadView(getDataView(data), options);
        }

        function isNodeBuffer(data) {
          try {
            return Buffer.isBuffer(data); // eslint-disable-line no-undef
          } catch (error) {
            return false;
          }
        }

        function getDataView(data) {
          try {
            return new DataView(data);
          } catch (error) {
            return new _dataview_js__WEBPACK_IMPORTED_MODULE_1__["default"](data);
          }
        }

        function loadView(dataView) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
            expanded: false
          };
          var foundMetaData = false;
          var tags = {};

          var _ImageHeader$parseApp = _image_header_js__WEBPACK_IMPORTED_MODULE_4__["default"].parseAppMarkers(dataView),
              fileDataOffset = _ImageHeader$parseApp.fileDataOffset,
              tiffHeaderOffset = _ImageHeader$parseApp.tiffHeaderOffset,
              iptcDataOffset = _ImageHeader$parseApp.iptcDataOffset,
              xmpChunks = _ImageHeader$parseApp.xmpChunks,
              iccChunks = _ImageHeader$parseApp.iccChunks,
              pngHeaderOffset = _ImageHeader$parseApp.pngHeaderOffset;

          if (_constants_js__WEBPACK_IMPORTED_MODULE_2__["default"].USE_JPEG && _constants_js__WEBPACK_IMPORTED_MODULE_2__["default"].USE_FILE && hasFileData(fileDataOffset)) {
            foundMetaData = true;

            var readTags = _file_tags_js__WEBPACK_IMPORTED_MODULE_6__["default"].read(dataView, fileDataOffset);

            if (options.expanded) {
              tags.file = readTags;
            } else {
              tags = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["objectAssign"])({}, tags, readTags);
            }
          }

          if (_constants_js__WEBPACK_IMPORTED_MODULE_2__["default"].USE_EXIF && hasExifData(tiffHeaderOffset)) {
            foundMetaData = true;

            var _readTags = _tags_js__WEBPACK_IMPORTED_MODULE_5__["default"].read(dataView, tiffHeaderOffset);

            if (_readTags.Thumbnail) {
              tags.Thumbnail = _readTags.Thumbnail;
              delete _readTags.Thumbnail;
            }

            if (options.expanded) {
              tags.exif = _readTags;
              addGpsGroup(tags);
            } else {
              tags = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["objectAssign"])({}, tags, _readTags);
            }

            if (_constants_js__WEBPACK_IMPORTED_MODULE_2__["default"].USE_TIFF && _constants_js__WEBPACK_IMPORTED_MODULE_2__["default"].USE_IPTC && _readTags['IPTC-NAA'] && !hasIptcData(iptcDataOffset)) {
              var readIptcTags = _iptc_tags_js__WEBPACK_IMPORTED_MODULE_7__["default"].read(_readTags['IPTC-NAA'].value, 0);

              if (options.expanded) {
                tags.iptc = readIptcTags;
              } else {
                tags = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["objectAssign"])({}, tags, readIptcTags);
              }
            }

            if (_constants_js__WEBPACK_IMPORTED_MODULE_2__["default"].USE_TIFF && _constants_js__WEBPACK_IMPORTED_MODULE_2__["default"].USE_XMP && _readTags['ApplicationNotes'] && !hasXmpData(xmpChunks)) {
              var readXmpTags = _xmp_tags_js__WEBPACK_IMPORTED_MODULE_8__["default"].read(Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringValueFromArray"])(_readTags['ApplicationNotes'].value));

              if (options.expanded) {
                tags.xmp = readXmpTags;
              } else {
                tags = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["objectAssign"])({}, tags, readXmpTags);
              }
            }

            if (_constants_js__WEBPACK_IMPORTED_MODULE_2__["default"].USE_TIFF && _constants_js__WEBPACK_IMPORTED_MODULE_2__["default"].USE_ICC && _readTags['ICC_Profile'] && !hasIccData(iccChunks)) {
              var readIccTags = _icc_tags_js__WEBPACK_IMPORTED_MODULE_9__["default"].read(_readTags['ICC_Profile'].value, [{
                offset: 0,
                length: _readTags['ICC_Profile'].value.length,
                chunkNumber: 1,
                chunksTotal: 1
              }]);

              if (options.expanded) {
                tags.icc = readIccTags;
              } else {
                tags = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["objectAssign"])({}, tags, readIccTags);
              }
            }
          }

          if (_constants_js__WEBPACK_IMPORTED_MODULE_2__["default"].USE_JPEG && _constants_js__WEBPACK_IMPORTED_MODULE_2__["default"].USE_IPTC && hasIptcData(iptcDataOffset)) {
            foundMetaData = true;

            var _readTags2 = _iptc_tags_js__WEBPACK_IMPORTED_MODULE_7__["default"].read(dataView, iptcDataOffset);

            if (options.expanded) {
              tags.iptc = _readTags2;
            } else {
              tags = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["objectAssign"])({}, tags, _readTags2);
            }
          }

          if (_constants_js__WEBPACK_IMPORTED_MODULE_2__["default"].USE_XMP && hasXmpData(xmpChunks)) {
            foundMetaData = true;

            var _readTags3 = _xmp_tags_js__WEBPACK_IMPORTED_MODULE_8__["default"].read(dataView, xmpChunks);

            if (options.expanded) {
              tags.xmp = _readTags3;
            } else {
              tags = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["objectAssign"])({}, tags, _readTags3);
            }
          }

          if ((_constants_js__WEBPACK_IMPORTED_MODULE_2__["default"].USE_JPEG || _constants_js__WEBPACK_IMPORTED_MODULE_2__["default"].USE_WEBP) && _constants_js__WEBPACK_IMPORTED_MODULE_2__["default"].USE_ICC && hasIccData(iccChunks)) {
            foundMetaData = true;

            var _readTags4 = _icc_tags_js__WEBPACK_IMPORTED_MODULE_9__["default"].read(dataView, iccChunks);

            if (options.expanded) {
              tags.icc = _readTags4;
            } else {
              tags = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["objectAssign"])({}, tags, _readTags4);
            }
          }

          if (_constants_js__WEBPACK_IMPORTED_MODULE_2__["default"].USE_PNG && _constants_js__WEBPACK_IMPORTED_MODULE_2__["default"].USE_PNG_FILE && hasPngFileData(pngHeaderOffset)) {
            foundMetaData = true;

            var _readTags5 = _png_file_tags_js__WEBPACK_IMPORTED_MODULE_10__["default"].read(dataView, pngHeaderOffset);

            if (options.expanded) {
              tags.pngFile = _readTags5;
            } else {
              tags = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["objectAssign"])({}, tags, _readTags5);
            }
          }

          var thumbnail = (_constants_js__WEBPACK_IMPORTED_MODULE_2__["default"].USE_JPEG || _constants_js__WEBPACK_IMPORTED_MODULE_2__["default"].USE_WEBP) && _constants_js__WEBPACK_IMPORTED_MODULE_2__["default"].USE_EXIF && _constants_js__WEBPACK_IMPORTED_MODULE_2__["default"].USE_THUMBNAIL && _thumbnail_js__WEBPACK_IMPORTED_MODULE_11__["default"].get(dataView, tags.Thumbnail, tiffHeaderOffset);

          if (thumbnail) {
            foundMetaData = true;
            tags.Thumbnail = thumbnail;
          } else {
            delete tags.Thumbnail;
          }

          if (!foundMetaData) {
            throw new _errors_js__WEBPACK_IMPORTED_MODULE_12__["default"].MetadataMissingError();
          }

          return tags;
        }

        function hasFileData(fileDataOffset) {
          return fileDataOffset !== undefined;
        }

        function hasExifData(tiffHeaderOffset) {
          return tiffHeaderOffset !== undefined;
        }

        function addGpsGroup(tags) {
          if (tags.exif) {
            if (tags.exif.GPSLatitude && tags.exif.GPSLatitudeRef) {
              tags.gps = tags.gps || {};
              tags.gps.Latitude = Object(_tag_names_utils_js__WEBPACK_IMPORTED_MODULE_3__["getCalculatedGpsValue"])(tags.exif.GPSLatitude.value);

              if (tags.exif.GPSLatitudeRef.value.join('') === 'S') {
                tags.gps.Latitude = -tags.gps.Latitude;
              }
            }

            if (tags.exif.GPSLongitude && tags.exif.GPSLongitudeRef) {
              tags.gps = tags.gps || {};
              tags.gps.Longitude = Object(_tag_names_utils_js__WEBPACK_IMPORTED_MODULE_3__["getCalculatedGpsValue"])(tags.exif.GPSLongitude.value);

              if (tags.exif.GPSLongitudeRef.value.join('') === 'W') {
                tags.gps.Longitude = -tags.gps.Longitude;
              }
            }

            if (tags.exif.GPSAltitude && tags.exif.GPSAltitudeRef) {
              tags.gps = tags.gps || {};
              tags.gps.Altitude = tags.exif.GPSAltitude.value[0] / tags.exif.GPSAltitude.value[1];

              if (tags.exif.GPSAltitudeRef.value === 1) {
                tags.gps.Altitude = -tags.gps.Altitude;
              }
            }
          }
        }

        function hasIptcData(iptcDataOffset) {
          return iptcDataOffset !== undefined;
        }

        function hasXmpData(xmpChunks) {
          return Array.isArray(xmpChunks) && xmpChunks.length > 0;
        }

        function hasIccData(iccDataOffsets) {
          return Array.isArray(iccDataOffsets) && iccDataOffsets.length > 0;
        }

        function hasPngFileData(pngFileDataOffset) {
          return pngFileDataOffset !== undefined;
        }
        /***/

      },

      /***/
      "./src/file-tags.js":
      /*!**************************!*\
        !*** ./src/file-tags.js ***!
        \**************************/

      /*! exports provided: default */

      /***/
      function srcFileTagsJs(module, __webpack_exports__, __webpack_require__) {
        "use strict";

        __webpack_require__.r(__webpack_exports__);
        /* harmony import */


        var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        /*! ./types.js */
        "./src/types.js");
        /* This Source Code Form is subject to the terms of the Mozilla Public
         * License, v. 2.0. If a copy of the MPL was not distributed with this
         * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

        /* harmony default export */


        __webpack_exports__["default"] = {
          read: read
        };

        function read(dataView, fileDataOffset) {
          var length = getLength(dataView, fileDataOffset);
          var numberOfColorComponents = getNumberOfColorComponents(dataView, fileDataOffset, length);
          return {
            'Bits Per Sample': getDataPrecision(dataView, fileDataOffset, length),
            'Image Height': getImageHeight(dataView, fileDataOffset, length),
            'Image Width': getImageWidth(dataView, fileDataOffset, length),
            'Color Components': numberOfColorComponents,
            'Subsampling': numberOfColorComponents && getSubsampling(dataView, fileDataOffset, numberOfColorComponents.value, length)
          };
        }

        function getLength(dataView, fileDataOffset) {
          return _types_js__WEBPACK_IMPORTED_MODULE_0__["default"].getShortAt(dataView, fileDataOffset);
        }

        function getDataPrecision(dataView, fileDataOffset, length) {
          var OFFSET = 2;
          var SIZE = 1;

          if (OFFSET + SIZE > length) {
            return undefined;
          }

          var value = _types_js__WEBPACK_IMPORTED_MODULE_0__["default"].getByteAt(dataView, fileDataOffset + OFFSET);

          return {
            value: value,
            description: '' + value
          };
        }

        function getImageHeight(dataView, fileDataOffset, length) {
          var OFFSET = 3;
          var SIZE = 2;

          if (OFFSET + SIZE > length) {
            return undefined;
          }

          var value = _types_js__WEBPACK_IMPORTED_MODULE_0__["default"].getShortAt(dataView, fileDataOffset + OFFSET);

          return {
            value: value,
            description: "".concat(value, "px")
          };
        }

        function getImageWidth(dataView, fileDataOffset, length) {
          var OFFSET = 5;
          var SIZE = 2;

          if (OFFSET + SIZE > length) {
            return undefined;
          }

          var value = _types_js__WEBPACK_IMPORTED_MODULE_0__["default"].getShortAt(dataView, fileDataOffset + OFFSET);

          return {
            value: value,
            description: "".concat(value, "px")
          };
        }

        function getNumberOfColorComponents(dataView, fileDataOffset, length) {
          var OFFSET = 7;
          var SIZE = 1;

          if (OFFSET + SIZE > length) {
            return undefined;
          }

          var value = _types_js__WEBPACK_IMPORTED_MODULE_0__["default"].getByteAt(dataView, fileDataOffset + OFFSET);

          return {
            value: value,
            description: '' + value
          };
        }

        function getSubsampling(dataView, fileDataOffset, numberOfColorComponents, length) {
          var OFFSET = 8;
          var SIZE = 3 * numberOfColorComponents;

          if (OFFSET + SIZE > length) {
            return undefined;
          }

          var components = [];

          for (var i = 0; i < numberOfColorComponents; i++) {
            var componentOffset = fileDataOffset + OFFSET + i * 3;
            components.push([_types_js__WEBPACK_IMPORTED_MODULE_0__["default"].getByteAt(dataView, componentOffset), _types_js__WEBPACK_IMPORTED_MODULE_0__["default"].getByteAt(dataView, componentOffset + 1), _types_js__WEBPACK_IMPORTED_MODULE_0__["default"].getByteAt(dataView, componentOffset + 2)]);
          }

          return {
            value: components,
            description: components.length > 1 ? getComponentIds(components) + getSamplingType(components) : ''
          };
        }

        function getComponentIds(components) {
          var ids = {
            0x01: 'Y',
            0x02: 'Cb',
            0x03: 'Cr',
            0x04: 'I',
            0x05: 'Q'
          };
          return components.map(function (compontent) {
            return ids[compontent[0]];
          }).join('');
        }

        function getSamplingType(components) {
          var types = {
            0x11: '4:4:4 (1 1)',
            0x12: '4:4:0 (1 2)',
            0x14: '4:4:1 (1 4)',
            0x21: '4:2:2 (2 1)',
            0x22: '4:2:0 (2 2)',
            0x24: '4:2:1 (2 4)',
            0x41: '4:1:1 (4 1)',
            0x42: '4:1:0 (4 2)'
          };

          if (components.length === 0 || components[0][1] === undefined || types[components[0][1]] === undefined) {
            return '';
          }

          return types[components[0][1]];
        }
        /***/

      },

      /***/
      "./src/icc-tag-names.js":
      /*!******************************!*\
        !*** ./src/icc-tag-names.js ***!
        \******************************/

      /*! exports provided: iccTags, iccProfile */

      /***/
      function srcIccTagNamesJs(module, __webpack_exports__, __webpack_require__) {
        "use strict";

        __webpack_require__.r(__webpack_exports__);
        /* harmony export (binding) */


        __webpack_require__.d(__webpack_exports__, "iccTags", function () {
          return iccTags;
        });
        /* harmony export (binding) */


        __webpack_require__.d(__webpack_exports__, "iccProfile", function () {
          return iccProfile;
        });
        /* harmony import */


        var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        /*! ./utils.js */
        "./src/utils.js");
        /* This Source Code Form is subject to the terms of the Mozilla Public
         * License, v. 2.0. If a copy of the MPL was not distributed with this
         * file, You can obtain one at https://mozilla.org/MPL/2.0/. */


        var iccTags = {
          'desc': {
            'name': 'ICC Description'
          },
          'cprt': {
            'name': 'ICC Copyright'
          },
          'dmdd': {
            'name': 'ICC Device Model Description'
          },
          'vued': {
            'name': 'ICC Viewing Conditions Description'
          },
          'dmnd': {
            'name': 'ICC Device Manufacturer for Display'
          },
          'tech': {
            'name': 'Technology'
          }
        };
        var iccProfile = {
          4: {
            'name': 'Preferred CMM type',
            'value': function value(dataView, offset) {
              return Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringFromDataView"])(dataView, offset, 4);
            },
            'description': function description(value) {
              return value !== null ? toCompany(value) : '';
            }
          },
          8: {
            'name': 'Profile Version',
            'value': function value(dataView, offset) {
              return dataView.getUint8(offset).toString(10) + '.' + (dataView.getUint8(offset + 1) >> 4).toString(10) + '.' + (dataView.getUint8(offset + 1) % 16).toString(10);
            }
          },
          12: {
            'name': 'Profile/Device class',
            'value': function value(dataView, offset) {
              return Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringFromDataView"])(dataView, offset, 4);
            },
            'description': function description(value) {
              switch (value.toLowerCase()) {
                case 'scnr':
                  return 'Input Device profile';

                case 'mntr':
                  return 'Display Device profile';

                case 'prtr':
                  return 'Output Device profile';

                case 'link':
                  return 'DeviceLink profile';

                case 'abst':
                  return 'Abstract profile';

                case 'spac':
                  return 'ColorSpace profile';

                case 'nmcl':
                  return 'NamedColor profile';

                case 'cenc':
                  return 'ColorEncodingSpace profile';

                case 'mid ':
                  return 'MultiplexIdentification profile';

                case 'mlnk':
                  return 'MultiplexLink profile';

                case 'mvis':
                  return 'MultiplexVisualization profile';

                default:
                  return value;
              }
            }
          },
          16: {
            'name': 'Color Space',
            'value': function value(dataView, offset) {
              return Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringFromDataView"])(dataView, offset, 4);
            }
          },
          20: {
            'name': 'Connection Space',
            'value': function value(dataView, offset) {
              return Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringFromDataView"])(dataView, offset, 4);
            }
          },
          24: {
            'name': 'ICC Profile Date',
            'value': function value(dataView, offset) {
              return parseDate(dataView, offset).toISOString();
            }
          },
          36: {
            'name': 'ICC Signature',
            'value': function value(dataView, offset) {
              return sliceToString(dataView.buffer.slice(offset, offset + 4));
            }
          },
          40: {
            'name': 'Primary Platform',
            'value': function value(dataView, offset) {
              return Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringFromDataView"])(dataView, offset, 4);
            },
            'description': function description(value) {
              return toCompany(value);
            }
          },
          48: {
            'name': 'Device Manufacturer',
            'value': function value(dataView, offset) {
              return Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringFromDataView"])(dataView, offset, 4);
            },
            'description': function description(value) {
              return toCompany(value);
            }
          },
          52: {
            'name': 'Device Model Number',
            'value': function value(dataView, offset) {
              return Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringFromDataView"])(dataView, offset, 4);
            }
          },
          64: {
            'name': 'Rendering Intent',
            'value': function value(dataView, offset) {
              return dataView.getUint32(offset);
            },
            'description': function description(value) {
              switch (value) {
                case 0:
                  return 'Perceptual';

                case 1:
                  return 'Relative Colorimetric';

                case 2:
                  return 'Saturation';

                case 3:
                  return 'Absolute Colorimetric';

                default:
                  return value;
              }
            }
          },
          80: {
            'name': 'Profile Creator',
            'value': function value(dataView, offset) {
              return Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringFromDataView"])(dataView, offset, 4);
            }
          }
        };

        function parseDate(dataView, offset) {
          var year = dataView.getUint16(offset);
          var month = dataView.getUint16(offset + 2) - 1;
          var day = dataView.getUint16(offset + 4);
          var hours = dataView.getUint16(offset + 6);
          var minutes = dataView.getUint16(offset + 8);
          var seconds = dataView.getUint16(offset + 10);
          return new Date(Date.UTC(year, month, day, hours, minutes, seconds));
        }

        function sliceToString(slice) {
          return String.fromCharCode.apply(null, new Uint8Array(slice));
        }

        function toCompany(value) {
          switch (value.toLowerCase()) {
            case 'appl':
              return 'Apple';

            case 'adbe':
              return 'Adobe';

            case 'msft':
              return 'Microsoft';

            case 'sunw':
              return 'Sun Microsystems';

            case 'sgi':
              return 'Silicon Graphics';

            case 'tgnt':
              return 'Taligent';

            default:
              return value;
          }
        }
        /***/

      },

      /***/
      "./src/icc-tags.js":
      /*!*************************!*\
        !*** ./src/icc-tags.js ***!
        \*************************/

      /*! exports provided: default, parseTags */

      /***/
      function srcIccTagsJs(module, __webpack_exports__, __webpack_require__) {
        "use strict";

        __webpack_require__.r(__webpack_exports__);
        /* harmony export (binding) */


        __webpack_require__.d(__webpack_exports__, "parseTags", function () {
          return parseTags;
        });
        /* harmony import */


        var _icc_tag_names_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        /*! ./icc-tag-names.js */
        "./src/icc-tag-names.js");
        /* harmony import */


        var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
        /*! ./utils.js */
        "./src/utils.js");
        /* This Source Code Form is subject to the terms of the Mozilla Public
         * License, v. 2.0. If a copy of the MPL was not distributed with this
         * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

        /* harmony default export */


        __webpack_exports__["default"] = {
          read: read
        };
        var PROFILE_HEADER_LENGTH = 84;
        var ICC_TAG_COUNT_OFFSET = 128;
        var ICC_SIGNATURE = 'acsp';
        var TAG_TYPE_DESC = 'desc';
        var TAG_TYPE_MULTI_LOCALIZED_UNICODE_TYPE = 'mluc';
        var TAG_TYPE_TEXT = 'text';
        var TAG_TYPE_SIGNATURE = 'sig ';
        var TAG_TABLE_SINGLE_TAG_DATA = 12; // ICC profile data can be longer than application segment max length of ~64k.
        // so it can be split into multiple APP2 segments. Each segment includes
        // total chunk count and chunk number.
        // Here we read all chunks into single continious array of bytes.

        function read(dataView, iccData) {
          try {
            var totalIccProfileLength = iccData.reduce(function (sum, icc) {
              return sum + icc.length;
            }, 0);
            var iccBinaryData = new Uint8Array(totalIccProfileLength);
            var offset = 0;
            var buffer = getBuffer(dataView);

            var _loop = function _loop(chunkNumber) {
              var iccDataChunk = iccData.find(function (x) {
                return x.chunkNumber === chunkNumber;
              });

              if (!iccDataChunk) {
                throw new Error("ICC chunk ".concat(chunkNumber, " not found"));
              }

              var data = buffer.slice(iccDataChunk.offset, iccDataChunk.offset + iccDataChunk.length);
              var chunkData = new Uint8Array(data);
              iccBinaryData.set(chunkData, offset);
              offset += chunkData.length;
            };

            for (var chunkNumber = 1; chunkNumber <= iccData.length; chunkNumber++) {
              _loop(chunkNumber);
            }

            return parseTags(new DataView(iccBinaryData.buffer));
          } catch (error) {
            return {};
          }
        }

        function getBuffer(dataView) {
          if (Array.isArray(dataView)) {
            return new DataView(Uint8Array.from(dataView).buffer).buffer;
          }

          return dataView.buffer;
        }

        function iccDoesNotHaveTagCount(buffer) {
          return buffer.length < ICC_TAG_COUNT_OFFSET + 4;
        }

        function hasTagsData(buffer, tagHeaderOffset) {
          return buffer.length < tagHeaderOffset + TAG_TABLE_SINGLE_TAG_DATA;
        }

        function parseTags(dataView) {
          var buffer = dataView.buffer;
          var length = dataView.getUint32();

          if (dataView.byteLength !== length) {
            throw new Error('ICC profile length not matching');
          }

          if (dataView.length < PROFILE_HEADER_LENGTH) {
            throw new Error('ICC profile too short');
          }

          var tags = {};
          var iccProfileKeys = Object.keys(_icc_tag_names_js__WEBPACK_IMPORTED_MODULE_0__["iccProfile"]);

          for (var i = 0; i < iccProfileKeys.length; i++) {
            var offset = iccProfileKeys[i];
            var profileEntry = _icc_tag_names_js__WEBPACK_IMPORTED_MODULE_0__["iccProfile"][offset];
            var value = profileEntry.value(dataView, parseInt(offset, 10));
            var description = value;

            if (profileEntry.description) {
              description = profileEntry.description(value);
            }

            tags[profileEntry.name] = {
              value: value,
              description: description
            };
          }

          var signature = sliceToString(buffer.slice(36, 40));

          if (signature !== ICC_SIGNATURE) {
            throw new Error('ICC profile: missing signature');
          }
          /* ICC data is incomplete but we have header parsed so lets return it */


          if (iccDoesNotHaveTagCount(buffer)) {
            return tags;
          }

          var tagCount = dataView.getUint32(128);
          var tagHeaderOffset = 132;

          for (var _i = 0; _i < tagCount; _i++) {
            if (hasTagsData(buffer, tagHeaderOffset)) {
              // Tags are corrupted (offset too far), return what we parsed until now
              return tags;
            }

            var tagSignature = Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__["getStringFromDataView"])(dataView, tagHeaderOffset, 4);
            var tagOffset = dataView.getUint32(tagHeaderOffset + 4);
            var tagSize = dataView.getUint32(tagHeaderOffset + 8);

            if (tagOffset > buffer.length) {
              // Tag data is invalid, lets return what we managed to parse
              return tags;
            }

            var tagType = Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__["getStringFromDataView"])(dataView, tagOffset, 4);

            if (tagType === TAG_TYPE_DESC) {
              var tagValueSize = dataView.getUint32(tagOffset + 8);

              if (tagValueSize > tagSize) {
                // Tag data is invalid, lets return what we managed to parse
                return tags;
              }

              var val = sliceToString(buffer.slice(tagOffset + 12, tagOffset + tagValueSize + 11));
              addTag(tags, tagSignature, val);
            } else if (tagType === TAG_TYPE_MULTI_LOCALIZED_UNICODE_TYPE) {
              var numRecords = dataView.getUint32(tagOffset + 8);
              var recordSize = dataView.getUint32(tagOffset + 12);

              var _offset = tagOffset + 16;

              var _val = [];

              for (var recordNum = 0; recordNum < numRecords; recordNum++) {
                var languageCode = Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__["getStringFromDataView"])(dataView, _offset + 0, 2);
                var countryCode = Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__["getStringFromDataView"])(dataView, _offset + 2, 2);
                var textLength = dataView.getUint32(_offset + 4);
                var textOffset = dataView.getUint32(_offset + 8);
                var text = Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__["getUnicodeStringFromDataView"])(dataView, tagOffset + textOffset, textLength);

                _val.push({
                  languageCode: languageCode,
                  countryCode: countryCode,
                  text: text
                });

                _offset += recordSize;
              }

              if (numRecords === 1) {
                addTag(tags, tagSignature, _val[0].text);
              } else {
                var valObj = {};

                for (var valIndex = 0; valIndex < _val.length; valIndex++) {
                  valObj["".concat(_val[valIndex].languageCode, "-").concat(_val[valIndex].countryCode)] = _val[valIndex].text;
                }

                addTag(tags, tagSignature, valObj);
              }
            } else if (tagType === TAG_TYPE_TEXT) {
              var _val2 = sliceToString(buffer.slice(tagOffset + 8, tagOffset + tagSize - 7));

              addTag(tags, tagSignature, _val2);
            } else if (tagType === TAG_TYPE_SIGNATURE) {
              var _val3 = sliceToString(buffer.slice(tagOffset + 8, tagOffset + 12));

              addTag(tags, tagSignature, _val3);
            }

            tagHeaderOffset = tagHeaderOffset + 12;
          }

          return tags;
        }

        function sliceToString(slice) {
          return String.fromCharCode.apply(null, new Uint8Array(slice));
        }

        function addTag(tags, tagSignature, value) {
          if (_icc_tag_names_js__WEBPACK_IMPORTED_MODULE_0__["iccTags"][tagSignature]) {
            tags[_icc_tag_names_js__WEBPACK_IMPORTED_MODULE_0__["iccTags"][tagSignature].name] = {
              value: value,
              description: value
            };
          } else {
            tags[tagSignature] = {
              value: value,
              description: value
            };
          }
        }
        /***/

      },

      /***/
      "./src/image-header-heic.js":
      /*!**********************************!*\
        !*** ./src/image-header-heic.js ***!
        \**********************************/

      /*! exports provided: default */

      /***/
      function srcImageHeaderHeicJs(module, __webpack_exports__, __webpack_require__) {
        "use strict";

        __webpack_require__.r(__webpack_exports__);
        /* harmony import */


        var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        /*! ./utils.js */
        "./src/utils.js");
        /* harmony import */


        var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
        /*! ./constants.js */
        "./src/constants.js");
        /* This Source Code Form is subject to the terms of the Mozilla Public
         * License, v. 2.0. If a copy of the MPL was not distributed with this
         * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

        /* harmony default export */


        __webpack_exports__["default"] = {
          isHeicFile: isHeicFile,
          findHeicOffsets: findHeicOffsets
        };

        function isHeicFile(dataView) {
          var HEIC_ID = 'ftyp';
          var HEIC_ID_OFFSET = 4;
          var HEIC_MAJOR_BRANDS = ['heic', 'heix', 'hevc', 'hevx', 'heim', 'heis', 'hevm', 'hevs', 'mif1'];
          var HEIC_MAJOR_BRAND_LENGTH = 4;
          var heicMajorBrand = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringFromDataView"])(dataView, HEIC_ID_OFFSET + HEIC_ID.length, HEIC_MAJOR_BRAND_LENGTH);
          return Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringFromDataView"])(dataView, HEIC_ID_OFFSET, HEIC_ID.length) === HEIC_ID && HEIC_MAJOR_BRANDS.indexOf(heicMajorBrand) !== -1;
        }

        function findHeicOffsets(dataView) {
          if (_constants_js__WEBPACK_IMPORTED_MODULE_1__["default"].USE_EXIF || _constants_js__WEBPACK_IMPORTED_MODULE_1__["default"].USE_ICC) {
            var _findMetaAtom = findMetaAtom(dataView),
                metaOffset = _findMetaAtom.offset,
                metaLength = _findMetaAtom.length;

            if (metaOffset === undefined) {
              return {
                hasAppMarkers: false
              };
            }

            var metaEndOffset = Math.min(metaOffset + metaLength, dataView.byteLength);

            var _findMetaItems = findMetaItems(dataView, metaOffset, metaEndOffset),
                exifItemOffset = _findMetaItems.exifItemOffset,
                ilocOffset = _findMetaItems.ilocOffset,
                colrOffset = _findMetaItems.colrOffset;

            var exifOffset = findExifOffset(dataView, exifItemOffset, ilocOffset, metaEndOffset);
            var iccChunks = findIccChunks(dataView, colrOffset, metaEndOffset);
            return {
              hasAppMarkers: exifOffset !== undefined || iccChunks !== undefined,
              tiffHeaderOffset: exifOffset,
              iccChunks: iccChunks
            };
          }

          return {
            hasAppMarkers: false
          };
        }

        function findMetaAtom(dataView) {
          var ATOM_LENGTH_SIZE = 4;
          var ATOM_TYPE_SIZE = 4;
          var ATOM_MIN_LENGTH = 8;
          var ATOM_TYPE_OFFSET = 4;
          var offset = 0;

          while (offset + ATOM_LENGTH_SIZE + ATOM_TYPE_SIZE <= dataView.byteLength) {
            var atomLength = getAtomLength(dataView, offset);

            if (atomLength >= ATOM_MIN_LENGTH) {
              var atomType = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringFromDataView"])(dataView, offset + ATOM_TYPE_OFFSET, ATOM_TYPE_SIZE);

              if (atomType === 'meta') {
                return {
                  offset: offset,
                  length: atomLength
                };
              }
            }

            offset += atomLength;
          }

          return {
            offset: undefined,
            length: 0
          };
        }

        function getAtomLength(dataView, offset) {
          var ATOM_EXTENDED_SIZE_LOW_OFFSET = 12;
          var atomLength = dataView.getUint32(offset);

          if (extendsToEndOfFile(atomLength)) {
            return dataView.byteLength - offset;
          }

          if (hasExtendedSize(atomLength)) {
            if (hasEmptyHighBits(dataView, offset)) {
              // It's a bit tricky to handle 64 bit numbers in JavaScript. Let's
              // wait until there are real-world examples where it is necessary.
              return dataView.getUint32(offset + ATOM_EXTENDED_SIZE_LOW_OFFSET);
            }
          }

          return atomLength;
        }

        function extendsToEndOfFile(atomLength) {
          return atomLength === 0;
        }

        function hasExtendedSize(atomLength) {
          return atomLength === 1;
        }

        function hasEmptyHighBits(dataView, offset) {
          var ATOM_EXTENDED_SIZE_OFFSET = 8;
          return dataView.getUint32(offset + ATOM_EXTENDED_SIZE_OFFSET) === 0;
        }

        function findMetaItems(dataView, offset, metaEndOffset) {
          var STRING_SIZE = 4;
          var ITEM_INDEX_REL_OFFSET = -4;
          var offsets = {
            ilocOffset: undefined,
            exifItemOffset: undefined,
            colrOffset: undefined
          };

          while (offset + STRING_SIZE <= metaEndOffset && (!offsets.ilocOffset || !offsets.exifItemOffset || !offsets.colrOffset)) {
            var itemName = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringFromDataView"])(dataView, offset, STRING_SIZE);

            if (_constants_js__WEBPACK_IMPORTED_MODULE_1__["default"].USE_EXIF && itemName === 'iloc') {
              offsets.ilocOffset = offset;
            } else if (_constants_js__WEBPACK_IMPORTED_MODULE_1__["default"].USE_EXIF && itemName === 'Exif') {
              offsets.exifItemOffset = offset + ITEM_INDEX_REL_OFFSET;
            } else if (_constants_js__WEBPACK_IMPORTED_MODULE_1__["default"].USE_ICC && itemName === 'colr') {
              offsets.colrOffset = offset + ITEM_INDEX_REL_OFFSET;
            }

            offset++;
          }

          return offsets;
        }

        function findExifOffset(dataView, exifItemOffset, offset, metaEndOffset) {
          var EXIF_ITEM_OFFSET_SIZE = 2;
          var ILOC_DATA_OFFSET = 12;
          var EXIF_POINTER_OFFSET = 8;
          var EXIF_POINTER_SIZE = 4;
          var EXIF_PREFIX_LENGTH_OFFSET = 4;
          var ILOC_ITEM_SIZE = 16;

          if (!offset || !exifItemOffset || exifItemOffset + EXIF_ITEM_OFFSET_SIZE > metaEndOffset) {
            return undefined;
          }

          var exifItemIndex = dataView.getUint16(exifItemOffset);
          offset += ILOC_DATA_OFFSET;

          while (offset + ILOC_ITEM_SIZE <= metaEndOffset) {
            var itemIndex = dataView.getUint16(offset);

            if (itemIndex === exifItemIndex) {
              var exifPointer = dataView.getUint32(offset + EXIF_POINTER_OFFSET);

              if (exifPointer + EXIF_POINTER_SIZE <= dataView.byteLength) {
                var exifOffset = dataView.getUint32(exifPointer);
                var prefixLength = exifOffset + EXIF_PREFIX_LENGTH_OFFSET;
                return exifPointer + prefixLength;
              }
            }

            offset += ILOC_ITEM_SIZE;
          }

          return undefined;
        }

        function findIccChunks(dataView, offset, metaEndOffset) {
          var ITEM_TYPE_OFFSET = 8;
          var ITEM_TYPE_SIZE = 4;
          var ITEM_CONTENT_OFFSET = 12;

          if (!offset || offset + ITEM_CONTENT_OFFSET > metaEndOffset) {
            return undefined;
          }

          var colorType = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringFromDataView"])(dataView, offset + ITEM_TYPE_OFFSET, ITEM_TYPE_SIZE);

          if (colorType !== 'prof' && colorType !== 'rICC') {
            return undefined;
          }

          return [{
            offset: offset + ITEM_CONTENT_OFFSET,
            length: getAtomLength(dataView, offset) - ITEM_CONTENT_OFFSET,
            chunkNumber: 1,
            chunksTotal: 1
          }];
        }
        /***/

      },

      /***/
      "./src/image-header-jpeg.js":
      /*!**********************************!*\
        !*** ./src/image-header-jpeg.js ***!
        \**********************************/

      /*! exports provided: default */

      /***/
      function srcImageHeaderJpegJs(module, __webpack_exports__, __webpack_require__) {
        "use strict";

        __webpack_require__.r(__webpack_exports__);
        /* harmony import */


        var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        /*! ./utils.js */
        "./src/utils.js");
        /* harmony import */


        var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
        /*! ./constants.js */
        "./src/constants.js");
        /* This Source Code Form is subject to the terms of the Mozilla Public
         * License, v. 2.0. If a copy of the MPL was not distributed with this
         * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

        /* harmony default export */


        __webpack_exports__["default"] = {
          isJpegFile: isJpegFile,
          findJpegOffsets: findJpegOffsets
        };
        var MIN_JPEG_DATA_BUFFER_LENGTH = 2;
        var JPEG_ID = 0xffd8;
        var JPEG_ID_SIZE = 2;
        var APP_ID_OFFSET = 4;
        var APP_MARKER_SIZE = 2;
        var TIFF_HEADER_OFFSET = 10; // From start of APP1 marker.

        var IPTC_DATA_OFFSET = 18; // From start of APP13 marker.

        var XMP_DATA_OFFSET = 33; // From start of APP1 marker.

        var XMP_EXTENDED_DATA_OFFSET = 79; // From start of APP1 marker including GUID, total length, and offset.

        var APP2_ICC_DATA_OFFSET = 18; // From start of APP2 marker including marker and chunk/chunk total numbers.

        var APP2_ICC_IDENTIFIER = 'ICC_PROFILE\0';
        var ICC_CHUNK_NUMBER_OFFSET = APP_ID_OFFSET + APP2_ICC_IDENTIFIER.length;
        var ICC_TOTAL_CHUNKS_OFFSET = ICC_CHUNK_NUMBER_OFFSET + 1;
        var SOF0_MARKER = 0xffc0;
        var SOF2_MARKER = 0xffc2;
        var DHT_MARKER = 0xffc4;
        var DQT_MARKER = 0xffdb;
        var DRI_MARKER = 0xffdd;
        var SOS_MARKER = 0xffda;
        var APP0_MARKER = 0xffe0;
        var APP1_MARKER = 0xffe1;
        var APP2_MARKER = 0xffe2;
        var APP13_MARKER = 0xffed;
        var APP15_MARKER = 0xffef;
        var COMMENT_MARKER = 0xfffe;
        var APP1_EXIF_IDENTIFIER = 'Exif';
        var APP1_XMP_IDENTIFIER = 'http://ns.adobe.com/xap/1.0/\x00';
        var APP1_XMP_EXTENDED_IDENTIFIER = 'http://ns.adobe.com/xmp/extension/\x00';
        var APP13_IPTC_IDENTIFIER = 'Photoshop 3.0';

        function isJpegFile(dataView) {
          return dataView.byteLength >= MIN_JPEG_DATA_BUFFER_LENGTH && dataView.getUint16(0) === JPEG_ID;
        }

        function findJpegOffsets(dataView) {
          var appMarkerPosition = JPEG_ID_SIZE;
          var fieldLength;
          var sof0DataOffset;
          var sof2DataOffset;
          var tiffHeaderOffset;
          var iptcDataOffset;
          var xmpChunks;
          var iccChunks;

          while (appMarkerPosition + APP_ID_OFFSET + 5 <= dataView.byteLength) {
            if (_constants_js__WEBPACK_IMPORTED_MODULE_1__["default"].USE_FILE && isSOF0Marker(dataView, appMarkerPosition)) {
              sof0DataOffset = appMarkerPosition + APP_MARKER_SIZE;
            } else if (_constants_js__WEBPACK_IMPORTED_MODULE_1__["default"].USE_FILE && isSOF2Marker(dataView, appMarkerPosition)) {
              sof2DataOffset = appMarkerPosition + APP_MARKER_SIZE;
            } else if (_constants_js__WEBPACK_IMPORTED_MODULE_1__["default"].USE_EXIF && isApp1ExifMarker(dataView, appMarkerPosition)) {
              fieldLength = dataView.getUint16(appMarkerPosition + APP_MARKER_SIZE);
              tiffHeaderOffset = appMarkerPosition + TIFF_HEADER_OFFSET;
            } else if (_constants_js__WEBPACK_IMPORTED_MODULE_1__["default"].USE_XMP && isApp1XmpMarker(dataView, appMarkerPosition)) {
              if (!xmpChunks) {
                xmpChunks = [];
              }

              fieldLength = dataView.getUint16(appMarkerPosition + APP_MARKER_SIZE);
              xmpChunks.push(getXmpChunkDetails(appMarkerPosition, fieldLength));
            } else if (_constants_js__WEBPACK_IMPORTED_MODULE_1__["default"].USE_XMP && isApp1ExtendedXmpMarker(dataView, appMarkerPosition)) {
              if (!xmpChunks) {
                xmpChunks = [];
              }

              fieldLength = dataView.getUint16(appMarkerPosition + APP_MARKER_SIZE);
              xmpChunks.push(getExtendedXmpChunkDetails(appMarkerPosition, fieldLength));
            } else if (_constants_js__WEBPACK_IMPORTED_MODULE_1__["default"].USE_IPTC && isApp13PhotoshopMarker(dataView, appMarkerPosition)) {
              fieldLength = dataView.getUint16(appMarkerPosition + APP_MARKER_SIZE);
              iptcDataOffset = appMarkerPosition + IPTC_DATA_OFFSET;
            } else if (_constants_js__WEBPACK_IMPORTED_MODULE_1__["default"].USE_ICC && isApp2ICCMarker(dataView, appMarkerPosition)) {
              fieldLength = dataView.getUint16(appMarkerPosition + APP_MARKER_SIZE);
              var iccDataOffset = appMarkerPosition + APP2_ICC_DATA_OFFSET;
              var iccDataLength = fieldLength - (APP2_ICC_DATA_OFFSET - APP_MARKER_SIZE);
              var iccChunkNumber = dataView.getUint8(appMarkerPosition + ICC_CHUNK_NUMBER_OFFSET);
              var iccChunksTotal = dataView.getUint8(appMarkerPosition + ICC_TOTAL_CHUNKS_OFFSET);

              if (!iccChunks) {
                iccChunks = [];
              }

              iccChunks.push({
                offset: iccDataOffset,
                length: iccDataLength,
                chunkNumber: iccChunkNumber,
                chunksTotal: iccChunksTotal
              });
            } else if (isAppMarker(dataView, appMarkerPosition)) {
              fieldLength = dataView.getUint16(appMarkerPosition + APP_MARKER_SIZE);
            } else {
              break;
            }

            appMarkerPosition += APP_MARKER_SIZE + fieldLength;
          }

          return {
            hasAppMarkers: appMarkerPosition > JPEG_ID_SIZE,
            fileDataOffset: sof0DataOffset || sof2DataOffset,
            tiffHeaderOffset: tiffHeaderOffset,
            iptcDataOffset: iptcDataOffset,
            xmpChunks: xmpChunks,
            iccChunks: iccChunks
          };
        }

        function isSOF0Marker(dataView, appMarkerPosition) {
          return dataView.getUint16(appMarkerPosition) === SOF0_MARKER;
        }

        function isSOF2Marker(dataView, appMarkerPosition) {
          return dataView.getUint16(appMarkerPosition) === SOF2_MARKER;
        }

        function isApp2ICCMarker(dataView, appMarkerPosition) {
          var markerIdLength = APP2_ICC_IDENTIFIER.length;
          return dataView.getUint16(appMarkerPosition) === APP2_MARKER && Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringFromDataView"])(dataView, appMarkerPosition + APP_ID_OFFSET, markerIdLength) === APP2_ICC_IDENTIFIER;
        }

        function isApp1ExifMarker(dataView, appMarkerPosition) {
          var markerIdLength = APP1_EXIF_IDENTIFIER.length;
          return dataView.getUint16(appMarkerPosition) === APP1_MARKER && Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringFromDataView"])(dataView, appMarkerPosition + APP_ID_OFFSET, markerIdLength) === APP1_EXIF_IDENTIFIER && dataView.getUint8(appMarkerPosition + APP_ID_OFFSET + markerIdLength) === 0x00;
        }

        function isApp1XmpMarker(dataView, appMarkerPosition) {
          return dataView.getUint16(appMarkerPosition) === APP1_MARKER && isXmpIdentifier(dataView, appMarkerPosition);
        }

        function isXmpIdentifier(dataView, appMarkerPosition) {
          var markerIdLength = APP1_XMP_IDENTIFIER.length;
          return Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringFromDataView"])(dataView, appMarkerPosition + APP_ID_OFFSET, markerIdLength) === APP1_XMP_IDENTIFIER;
        }

        function isApp1ExtendedXmpMarker(dataView, appMarkerPosition) {
          return dataView.getUint16(appMarkerPosition) === APP1_MARKER && isExtendedXmpIdentifier(dataView, appMarkerPosition);
        }

        function isExtendedXmpIdentifier(dataView, appMarkerPosition) {
          var markerIdLength = APP1_XMP_EXTENDED_IDENTIFIER.length;
          return Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringFromDataView"])(dataView, appMarkerPosition + APP_ID_OFFSET, markerIdLength) === APP1_XMP_EXTENDED_IDENTIFIER;
        }

        function getXmpChunkDetails(appMarkerPosition, fieldLength) {
          return {
            dataOffset: appMarkerPosition + XMP_DATA_OFFSET,
            length: fieldLength - (XMP_DATA_OFFSET - APP_MARKER_SIZE)
          };
        }

        function getExtendedXmpChunkDetails(appMarkerPosition, fieldLength) {
          return {
            dataOffset: appMarkerPosition + XMP_EXTENDED_DATA_OFFSET,
            length: fieldLength - (XMP_EXTENDED_DATA_OFFSET - APP_MARKER_SIZE)
          };
        }

        function isApp13PhotoshopMarker(dataView, appMarkerPosition) {
          var markerIdLength = APP13_IPTC_IDENTIFIER.length;
          return dataView.getUint16(appMarkerPosition) === APP13_MARKER && Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringFromDataView"])(dataView, appMarkerPosition + APP_ID_OFFSET, markerIdLength) === APP13_IPTC_IDENTIFIER && dataView.getUint8(appMarkerPosition + APP_ID_OFFSET + markerIdLength) === 0x00;
        }

        function isAppMarker(dataView, appMarkerPosition) {
          var appMarker = dataView.getUint16(appMarkerPosition);
          return appMarker >= APP0_MARKER && appMarker <= APP15_MARKER || appMarker === COMMENT_MARKER || appMarker === SOF0_MARKER || appMarker === SOF2_MARKER || appMarker === DHT_MARKER || appMarker === DQT_MARKER || appMarker === DRI_MARKER || appMarker === SOS_MARKER;
        }
        /***/

      },

      /***/
      "./src/image-header-png.js":
      /*!*********************************!*\
        !*** ./src/image-header-png.js ***!
        \*********************************/

      /*! exports provided: default */

      /***/
      function srcImageHeaderPngJs(module, __webpack_exports__, __webpack_require__) {
        "use strict";

        __webpack_require__.r(__webpack_exports__);
        /* harmony import */


        var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        /*! ./utils.js */
        "./src/utils.js");
        /* harmony import */


        var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
        /*! ./constants.js */
        "./src/constants.js");
        /* This Source Code Form is subject to the terms of the Mozilla Public
         * License, v. 2.0. If a copy of the MPL was not distributed with this
         * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

        /* harmony default export */


        __webpack_exports__["default"] = {
          isPngFile: isPngFile,
          findPngOffsets: findPngOffsets
        };
        var PNG_ID = '\x89\x50\x4e\x47\x0d\x0a\x1a\x0a';
        var PNG_CHUNK_LENGTH_SIZE = 4;
        var PNG_CHUNK_TYPE_SIZE = 4;
        var PNG_CHUNK_LENGTH_OFFSET = 0;
        var PNG_CHUNK_TYPE_OFFSET = PNG_CHUNK_LENGTH_SIZE;
        var PNG_CHUNK_DATA_OFFSET = PNG_CHUNK_LENGTH_SIZE + PNG_CHUNK_TYPE_SIZE;
        var PNG_XMP_PREFIX = 'XML:com.adobe.xmp\x00';

        function isPngFile(dataView) {
          return Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringFromDataView"])(dataView, 0, PNG_ID.length) === PNG_ID;
        }

        function findPngOffsets(dataView) {
          var PNG_CRC_SIZE = 4;
          var offsets = {
            hasAppMarkers: false
          };
          var offset = PNG_ID.length;

          while (offset + PNG_CHUNK_LENGTH_SIZE + PNG_CHUNK_TYPE_SIZE <= dataView.byteLength) {
            if (_constants_js__WEBPACK_IMPORTED_MODULE_1__["default"].USE_PNG_FILE && isPngImageHeaderChunk(dataView, offset)) {
              offsets.hasAppMarkers = true;
              offsets.pngHeaderOffset = offset + PNG_CHUNK_DATA_OFFSET;
            } else if (_constants_js__WEBPACK_IMPORTED_MODULE_1__["default"].USE_XMP && isPngXmpChunk(dataView, offset)) {
              var dataOffset = getPngXmpDataOffset(dataView, offset);

              if (dataOffset !== undefined) {
                offsets.hasAppMarkers = true;
                offsets.xmpChunks = [{
                  dataOffset: dataOffset,
                  length: dataView.getUint32(offset + PNG_CHUNK_LENGTH_OFFSET) - (dataOffset - (offset + PNG_CHUNK_DATA_OFFSET))
                }];
              }
            }

            offset += dataView.getUint32(offset + PNG_CHUNK_LENGTH_OFFSET) + PNG_CHUNK_LENGTH_SIZE + PNG_CHUNK_TYPE_SIZE + PNG_CRC_SIZE;
          }

          return offsets;
        }

        function isPngImageHeaderChunk(dataView, offset) {
          var PNG_CHUNK_TYPE_IMAGE_HEADER = 'IHDR';
          return Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringFromDataView"])(dataView, offset + PNG_CHUNK_TYPE_OFFSET, PNG_CHUNK_TYPE_SIZE) === PNG_CHUNK_TYPE_IMAGE_HEADER;
        }

        function isPngXmpChunk(dataView, offset) {
          var PNG_CHUNK_TYPE_INTERNATIONAL_TEXT = 'iTXt';
          return Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringFromDataView"])(dataView, offset + PNG_CHUNK_TYPE_OFFSET, PNG_CHUNK_TYPE_SIZE) === PNG_CHUNK_TYPE_INTERNATIONAL_TEXT && Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringFromDataView"])(dataView, offset + PNG_CHUNK_DATA_OFFSET, PNG_XMP_PREFIX.length) === PNG_XMP_PREFIX;
        }

        function getPngXmpDataOffset(dataView, offset) {
          var COMPRESSION_FLAG_SIZE = 1;
          var COMPRESSION_METHOD_SIZE = 1;
          offset += PNG_CHUNK_DATA_OFFSET + PNG_XMP_PREFIX.length + COMPRESSION_FLAG_SIZE + COMPRESSION_METHOD_SIZE;
          var numberOfNullSeparators = 0;

          while (numberOfNullSeparators < 2 && offset < dataView.byteLength) {
            if (dataView.getUint8(offset) === 0x00) {
              numberOfNullSeparators++;
            }

            offset++;
          }

          if (numberOfNullSeparators < 2) {
            return undefined;
          }

          return offset;
        }
        /***/

      },

      /***/
      "./src/image-header-tiff.js":
      /*!**********************************!*\
        !*** ./src/image-header-tiff.js ***!
        \**********************************/

      /*! exports provided: default */

      /***/
      function srcImageHeaderTiffJs(module, __webpack_exports__, __webpack_require__) {
        "use strict";

        __webpack_require__.r(__webpack_exports__);
        /* harmony import */


        var _byte_order_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        /*! ./byte-order.js */
        "./src/byte-order.js");
        /* harmony import */


        var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
        /*! ./constants.js */
        "./src/constants.js");
        /* This Source Code Form is subject to the terms of the Mozilla Public
         * License, v. 2.0. If a copy of the MPL was not distributed with this
         * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

        /* harmony default export */


        __webpack_exports__["default"] = {
          isTiffFile: isTiffFile,
          findTiffOffsets: findTiffOffsets
        };

        function isTiffFile(dataView) {
          var MIN_TIFF_DATA_BUFFER_LENGTH = 4;
          return dataView.byteLength >= MIN_TIFF_DATA_BUFFER_LENGTH && hasTiffMarker(dataView);
        }

        function hasTiffMarker(dataView) {
          var TIFF_ID = 0x2a;
          var TIFF_ID_OFFSET = 2;

          var littleEndian = dataView.getUint16(0) === _byte_order_js__WEBPACK_IMPORTED_MODULE_0__["default"].LITTLE_ENDIAN;

          return dataView.getUint16(TIFF_ID_OFFSET, littleEndian) === TIFF_ID;
        }

        function findTiffOffsets() {
          var TIFF_FILE_HEADER_OFFSET = 0;

          if (_constants_js__WEBPACK_IMPORTED_MODULE_1__["default"].USE_EXIF) {
            return {
              hasAppMarkers: true,
              tiffHeaderOffset: TIFF_FILE_HEADER_OFFSET
            };
          }

          return {};
        }
        /***/

      },

      /***/
      "./src/image-header-webp.js":
      /*!**********************************!*\
        !*** ./src/image-header-webp.js ***!
        \**********************************/

      /*! exports provided: default */

      /***/
      function srcImageHeaderWebpJs(module, __webpack_exports__, __webpack_require__) {
        "use strict";

        __webpack_require__.r(__webpack_exports__);
        /* harmony import */


        var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        /*! ./utils.js */
        "./src/utils.js");
        /* harmony import */


        var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
        /*! ./constants.js */
        "./src/constants.js");
        /* This Source Code Form is subject to the terms of the Mozilla Public
         * License, v. 2.0. If a copy of the MPL was not distributed with this
         * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

        /* harmony default export */


        __webpack_exports__["default"] = {
          isWebpFile: isWebpFile,
          findOffsets: findOffsets
        };

        function isWebpFile(dataView) {
          var RIFF_ID_OFFSET = 0;
          var RIFF_ID = 'RIFF';
          var WEBP_MARKER_OFFSET = 8;
          var WEBP_MARKER = 'WEBP';
          return Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringFromDataView"])(dataView, RIFF_ID_OFFSET, RIFF_ID.length) === RIFF_ID && Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringFromDataView"])(dataView, WEBP_MARKER_OFFSET, WEBP_MARKER.length) === WEBP_MARKER;
        }

        function findOffsets(dataView) {
          var SUB_CHUNK_START_OFFSET = 12;
          var CHUNK_SIZE_OFFSET = 4;
          var EXIF_IDENTIFIER = 'Exif\x00\x00';
          var CHUNK_HEADER_SIZE = 8;
          var offset = SUB_CHUNK_START_OFFSET;
          var hasAppMarkers = false;
          var tiffHeaderOffset;
          var xmpChunks;
          var iccChunks;

          while (offset + CHUNK_HEADER_SIZE < dataView.byteLength) {
            var chunkId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringFromDataView"])(dataView, offset, 4);
            var chunkSize = dataView.getUint32(offset + CHUNK_SIZE_OFFSET, true);

            if (_constants_js__WEBPACK_IMPORTED_MODULE_1__["default"].USE_EXIF && chunkId === 'EXIF') {
              hasAppMarkers = true;

              if (Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringFromDataView"])(dataView, offset + CHUNK_HEADER_SIZE, EXIF_IDENTIFIER.length) === EXIF_IDENTIFIER) {
                tiffHeaderOffset = offset + CHUNK_HEADER_SIZE + EXIF_IDENTIFIER.length;
              } else {
                tiffHeaderOffset = offset + CHUNK_HEADER_SIZE;
              }
            } else if (_constants_js__WEBPACK_IMPORTED_MODULE_1__["default"].USE_XMP && chunkId === 'XMP ') {
              hasAppMarkers = true;
              xmpChunks = [{
                dataOffset: offset + CHUNK_HEADER_SIZE,
                length: chunkSize
              }];
            } else if (_constants_js__WEBPACK_IMPORTED_MODULE_1__["default"].USE_ICC && chunkId === 'ICCP') {
              hasAppMarkers = true;
              iccChunks = [{
                offset: offset + CHUNK_HEADER_SIZE,
                length: chunkSize,
                chunkNumber: 1,
                chunksTotal: 1
              }];
            }

            offset += CHUNK_HEADER_SIZE + (chunkSize % 2 === 0 ? chunkSize : chunkSize + 1);
          }

          return {
            hasAppMarkers: hasAppMarkers,
            tiffHeaderOffset: tiffHeaderOffset,
            xmpChunks: xmpChunks,
            iccChunks: iccChunks
          };
        }
        /***/

      },

      /***/
      "./src/image-header.js":
      /*!*****************************!*\
        !*** ./src/image-header.js ***!
        \*****************************/

      /*! exports provided: default */

      /***/
      function srcImageHeaderJs(module, __webpack_exports__, __webpack_require__) {
        "use strict";

        __webpack_require__.r(__webpack_exports__);
        /* harmony import */


        var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        /*! ./constants.js */
        "./src/constants.js");
        /* harmony import */


        var _image_header_tiff_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
        /*! ./image-header-tiff.js */
        "./src/image-header-tiff.js");
        /* harmony import */


        var _image_header_jpeg_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
        /*! ./image-header-jpeg.js */
        "./src/image-header-jpeg.js");
        /* harmony import */


        var _image_header_png_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
        /*! ./image-header-png.js */
        "./src/image-header-png.js");
        /* harmony import */


        var _image_header_heic_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
        /*! ./image-header-heic.js */
        "./src/image-header-heic.js");
        /* harmony import */


        var _image_header_webp_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
        /*! ./image-header-webp.js */
        "./src/image-header-webp.js");
        /* This Source Code Form is subject to the terms of the Mozilla Public
         * License, v. 2.0. If a copy of the MPL was not distributed with this
         * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

        /* harmony default export */


        __webpack_exports__["default"] = {
          parseAppMarkers: parseAppMarkers
        };

        function parseAppMarkers(dataView) {
          if (_constants_js__WEBPACK_IMPORTED_MODULE_0__["default"].USE_TIFF && _image_header_tiff_js__WEBPACK_IMPORTED_MODULE_1__["default"].isTiffFile(dataView)) {
            return _image_header_tiff_js__WEBPACK_IMPORTED_MODULE_1__["default"].findTiffOffsets();
          }

          if (_constants_js__WEBPACK_IMPORTED_MODULE_0__["default"].USE_JPEG && _image_header_jpeg_js__WEBPACK_IMPORTED_MODULE_2__["default"].isJpegFile(dataView)) {
            return _image_header_jpeg_js__WEBPACK_IMPORTED_MODULE_2__["default"].findJpegOffsets(dataView);
          }

          if (_constants_js__WEBPACK_IMPORTED_MODULE_0__["default"].USE_PNG && _image_header_png_js__WEBPACK_IMPORTED_MODULE_3__["default"].isPngFile(dataView)) {
            return _image_header_png_js__WEBPACK_IMPORTED_MODULE_3__["default"].findPngOffsets(dataView);
          }

          if (_constants_js__WEBPACK_IMPORTED_MODULE_0__["default"].USE_HEIC && _image_header_heic_js__WEBPACK_IMPORTED_MODULE_4__["default"].isHeicFile(dataView)) {
            return _image_header_heic_js__WEBPACK_IMPORTED_MODULE_4__["default"].findHeicOffsets(dataView);
          }

          if (_constants_js__WEBPACK_IMPORTED_MODULE_0__["default"].USE_WEBP && _image_header_webp_js__WEBPACK_IMPORTED_MODULE_5__["default"].isWebpFile(dataView)) {
            return _image_header_webp_js__WEBPACK_IMPORTED_MODULE_5__["default"].findOffsets(dataView);
          }

          throw new Error('Invalid image format');
        }
        /***/

      },

      /***/
      "./src/iptc-tag-names.js":
      /*!*******************************!*\
        !*** ./src/iptc-tag-names.js ***!
        \*******************************/

      /*! exports provided: default */

      /***/
      function srcIptcTagNamesJs(module, __webpack_exports__, __webpack_require__) {
        "use strict";

        __webpack_require__.r(__webpack_exports__);
        /* harmony import */


        var _tag_names_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        /*! ./tag-names-utils.js */
        "./src/tag-names-utils.js");
        /* This Source Code Form is subject to the terms of the Mozilla Public
         * License, v. 2.0. If a copy of the MPL was not distributed with this
         * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

        /* harmony default export */


        __webpack_exports__["default"] = {
          'iptc': {
            0x0100: {
              'name': 'Model Version',
              'description': function description(value) {
                return ((value[0] << 8) + value[1]).toString();
              }
            },
            0x0105: {
              'name': 'Destination',
              'repeatable': true
            },
            0x0114: {
              'name': 'File Format',
              'description': function description(value) {
                return ((value[0] << 8) + value[1]).toString();
              }
            },
            0x0116: {
              'name': 'File Format Version',
              'description': function description(value) {
                return ((value[0] << 8) + value[1]).toString();
              }
            },
            0x011e: 'Service Identifier',
            0x0128: 'Envelope Number',
            0x0132: 'Product ID',
            0x013c: 'Envelope Priority',
            0x0146: {
              'name': 'Date Sent',
              'description': getCreationDate
            },
            0x0150: {
              'name': 'Time Sent',
              'description': getCreationTime
            },
            0x015a: {
              'name': 'Coded Character Set',
              'description': getEncodingName,
              'encoding_name': getEncodingName
            },
            0x0164: 'UNO',
            0x0178: {
              'name': 'ARM Identifier',
              'description': function description(value) {
                return ((value[0] << 8) + value[1]).toString();
              }
            },
            0x017a: {
              'name': 'ARM Version',
              'description': function description(value) {
                return ((value[0] << 8) + value[1]).toString();
              }
            },
            0x0200: {
              'name': 'Record Version',
              'description': function description(value) {
                return ((value[0] << 8) + value[1]).toString();
              }
            },
            0x0203: 'Object Type Reference',
            0x0204: 'Object Attribute Reference',
            0x0205: 'Object Name',
            0x0207: 'Edit Status',
            0x0208: {
              'name': 'Editorial Update',
              'description': function description(value) {
                if (Object(_tag_names_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringValue"])(value) === '01') {
                  return 'Additional Language';
                }

                return 'Unknown';
              }
            },
            0x020a: 'Urgency',
            0x020c: {
              'name': 'Subject Reference',
              'repeatable': true,
              'description': function description(value) {
                var parts = Object(_tag_names_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringValue"])(value).split(':');
                return parts[2] + (parts[3] ? '/' + parts[3] : '') + (parts[4] ? '/' + parts[4] : '');
              }
            },
            0x020f: 'Category',
            0x0214: {
              'name': 'Supplemental Category',
              'repeatable': true
            },
            0x0216: 'Fixture Identifier',
            0x0219: {
              'name': 'Keywords',
              'repeatable': true
            },
            0x021a: {
              'name': 'Content Location Code',
              'repeatable': true
            },
            0x021b: {
              'name': 'Content Location Name',
              'repeatable': true
            },
            0x021e: 'Release Date',
            0x0223: 'Release Time',
            0x0225: 'Expiration Date',
            0x0226: 'Expiration Time',
            0x0228: 'Special Instructions',
            0x022a: {
              'name': 'Action Advised',
              'description': function description(value) {
                var string = Object(_tag_names_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringValue"])(value);

                if (string === '01') {
                  return 'Object Kill';
                } else if (string === '02') {
                  return 'Object Replace';
                } else if (string === '03') {
                  return 'Object Append';
                } else if (string === '04') {
                  return 'Object Reference';
                }

                return 'Unknown';
              }
            },
            0x022d: {
              'name': 'Reference Service',
              'repeatable': true
            },
            0x022f: {
              'name': 'Reference Date',
              'repeatable': true
            },
            0x0232: {
              'name': 'Reference Number',
              'repeatable': true
            },
            0x0237: {
              'name': 'Date Created',
              'description': getCreationDate
            },
            0x023c: {
              'name': 'Time Created',
              'description': getCreationTime
            },
            0x023e: {
              'name': 'Digital Creation Date',
              'description': getCreationDate
            },
            0x023f: {
              'name': 'Digital Creation Time',
              'description': getCreationTime
            },
            0x0241: 'Originating Program',
            0x0246: 'Program Version',
            0x024b: {
              'name': 'Object Cycle',
              'description': function description(value) {
                var string = Object(_tag_names_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringValue"])(value);

                if (string === 'a') {
                  return 'morning';
                } else if (string === 'p') {
                  return 'evening';
                } else if (string === 'b') {
                  return 'both';
                }

                return 'Unknown';
              }
            },
            0x0250: {
              'name': 'By-line',
              'repeatable': true
            },
            0x0255: {
              'name': 'By-line Title',
              'repeatable': true
            },
            0x025a: 'City',
            0x025c: 'Sub-location',
            0x025f: 'Province/State',
            0x0264: 'Country/Primary Location Code',
            0x0265: 'Country/Primary Location Name',
            0x0267: 'Original Transmission Reference',
            0x0269: 'Headline',
            0x026e: 'Credit',
            0x0273: 'Source',
            0x0274: 'Copyright Notice',
            0x0276: {
              'name': 'Contact',
              'repeatable': true
            },
            0x0278: 'Caption/Abstract',
            0x027a: {
              'name': 'Writer/Editor',
              'repeatable': true
            },
            0x027d: {
              'name': 'Rasterized Caption',
              'description': function description(value) {
                return value;
              }
            },
            0x0282: 'Image Type',
            0x0283: {
              'name': 'Image Orientation',
              'description': function description(value) {
                var string = Object(_tag_names_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringValue"])(value);

                if (string === 'P') {
                  return 'Portrait';
                } else if (string === 'L') {
                  return 'Landscape';
                } else if (string === 'S') {
                  return 'Square';
                }

                return 'Unknown';
              }
            },
            0x0287: 'Language Identifier',
            0x0296: {
              'name': 'Audio Type',
              'description': function description(value) {
                var stringValue = Object(_tag_names_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringValue"])(value);
                var character0 = stringValue.charAt(0);
                var character1 = stringValue.charAt(1);
                var description = '';

                if (character0 === '1') {
                  description += 'Mono';
                } else if (character0 === '2') {
                  description += 'Stereo';
                }

                if (character1 === 'A') {
                  description += ', actuality';
                } else if (character1 === 'C') {
                  description += ', question and answer session';
                } else if (character1 === 'M') {
                  description += ', music, transmitted by itself';
                } else if (character1 === 'Q') {
                  description += ', response to a question';
                } else if (character1 === 'R') {
                  description += ', raw sound';
                } else if (character1 === 'S') {
                  description += ', scener';
                } else if (character1 === 'V') {
                  description += ', voicer';
                } else if (character1 === 'W') {
                  description += ', wrap';
                }

                if (description !== '') {
                  return description;
                }

                return stringValue;
              }
            },
            0x0297: {
              'name': 'Audio Sampling Rate',
              'description': function description(value) {
                return parseInt(Object(_tag_names_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringValue"])(value), 10) + ' Hz';
              }
            },
            0x0298: {
              'name': 'Audio Sampling Resolution',
              'description': function description(value) {
                var bits = parseInt(Object(_tag_names_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringValue"])(value), 10);
                return bits + (bits === 1 ? ' bit' : ' bits');
              }
            },
            0x0299: {
              'name': 'Audio Duration',
              'description': function description(value) {
                var duration = Object(_tag_names_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringValue"])(value);

                if (duration.length >= 6) {
                  return duration.substr(0, 2) + ':' + duration.substr(2, 2) + ':' + duration.substr(4, 2);
                }

                return duration;
              }
            },
            0x029a: 'Audio Outcue',
            0x02ba: 'Short Document ID',
            0x02bb: 'Unique Document ID',
            0x02bc: 'Owner ID',
            0x02c8: {
              'name': function name(value) {
                if (value.length === 2) {
                  return 'ObjectData Preview File Format';
                }

                return 'Record 2 destination';
              },
              'description': function description(value) {
                if (value.length === 2) {
                  var intValue = (value[0] << 8) + value[1];

                  if (intValue === 0) {
                    return 'No ObjectData';
                  } else if (intValue === 1) {
                    return 'IPTC-NAA Digital Newsphoto Parameter Record';
                  } else if (intValue === 2) {
                    return 'IPTC7901 Recommended Message Format';
                  } else if (intValue === 3) {
                    return 'Tagged Image File Format (Adobe/Aldus Image data)';
                  } else if (intValue === 4) {
                    return 'Illustrator (Adobe Graphics data)';
                  } else if (intValue === 5) {
                    return 'AppleSingle (Apple Computer Inc)';
                  } else if (intValue === 6) {
                    return 'NAA 89-3 (ANPA 1312)';
                  } else if (intValue === 7) {
                    return 'MacBinary II';
                  } else if (intValue === 8) {
                    return 'IPTC Unstructured Character Oriented File Format (UCOFF)';
                  } else if (intValue === 9) {
                    return 'United Press International ANPA 1312 variant';
                  } else if (intValue === 10) {
                    return 'United Press International Down-Load Message';
                  } else if (intValue === 11) {
                    return 'JPEG File Interchange (JFIF)';
                  } else if (intValue === 12) {
                    return 'Photo-CD Image-Pac (Eastman Kodak)';
                  } else if (intValue === 13) {
                    return 'Microsoft Bit Mapped Graphics File [*.BMP]';
                  } else if (intValue === 14) {
                    return 'Digital Audio File [*.WAV] (Microsoft & Creative Labs)';
                  } else if (intValue === 15) {
                    return 'Audio plus Moving Video [*.AVI] (Microsoft)';
                  } else if (intValue === 16) {
                    return 'PC DOS/Windows Executable Files [*.COM][*.EXE]';
                  } else if (intValue === 17) {
                    return 'Compressed Binary File [*.ZIP] (PKWare Inc)';
                  } else if (intValue === 18) {
                    return 'Audio Interchange File Format AIFF (Apple Computer Inc)';
                  } else if (intValue === 19) {
                    return 'RIFF Wave (Microsoft Corporation)';
                  } else if (intValue === 20) {
                    return 'Freehand (Macromedia/Aldus)';
                  } else if (intValue === 21) {
                    return 'Hypertext Markup Language "HTML" (The Internet Society)';
                  } else if (intValue === 22) {
                    return 'MPEG 2 Audio Layer 2 (Musicom), ISO/IEC';
                  } else if (intValue === 23) {
                    return 'MPEG 2 Audio Layer 3, ISO/IEC';
                  } else if (intValue === 24) {
                    return 'Portable Document File (*.PDF) Adobe';
                  } else if (intValue === 25) {
                    return 'News Industry Text Format (NITF)';
                  } else if (intValue === 26) {
                    return 'Tape Archive (*.TAR)';
                  } else if (intValue === 27) {
                    return 'Tidningarnas Telegrambyr NITF version (TTNITF DTD)';
                  } else if (intValue === 28) {
                    return 'Ritzaus Bureau NITF version (RBNITF DTD)';
                  } else if (intValue === 29) {
                    return 'Corel Draw [*.CDR]';
                  }

                  return "Unknown format ".concat(intValue);
                }

                return Object(_tag_names_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringValue"])(value);
              }
            },
            0x02c9: {
              'name': 'ObjectData Preview File Format Version',
              'description': function description(value, tags) {
                // Format ID, Version ID, Version Description
                var formatVersions = {
                  '00': {
                    '00': '1'
                  },
                  '01': {
                    '01': '1',
                    '02': '2',
                    '03': '3',
                    '04': '4'
                  },
                  '02': {
                    '04': '4'
                  },
                  '03': {
                    '01': '5.0',
                    '02': '6.0'
                  },
                  '04': {
                    '01': '1.40'
                  },
                  '05': {
                    '01': '2'
                  },
                  '06': {
                    '01': '1'
                  },
                  '11': {
                    '01': '1.02'
                  },
                  '20': {
                    '01': '3.1',
                    '02': '4.0',
                    '03': '5.0',
                    '04': '5.5'
                  },
                  '21': {
                    '02': '2.0'
                  }
                };
                var stringValue = Object(_tag_names_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringValue"])(value);

                if (tags['ObjectData Preview File Format']) {
                  var objectDataPreviewFileFormat = Object(_tag_names_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringValue"])(tags['ObjectData Preview File Format'].value);

                  if (formatVersions[objectDataPreviewFileFormat] && formatVersions[objectDataPreviewFileFormat][stringValue]) {
                    return formatVersions[objectDataPreviewFileFormat][stringValue];
                  }
                }

                return stringValue;
              }
            },
            0x02ca: 'ObjectData Preview Data',
            0x070a: {
              'name': 'Size Mode',
              'description': function description(value) {
                return value[0].toString();
              }
            },
            0x0714: {
              'name': 'Max Subfile Size',
              'description': function description(value) {
                var n = 0;

                for (var i = 0; i < value.length; i++) {
                  n = (n << 8) + value[i];
                }

                return n.toString();
              }
            },
            0x075a: {
              'name': 'ObjectData Size Announced',
              'description': function description(value) {
                var n = 0;

                for (var i = 0; i < value.length; i++) {
                  n = (n << 8) + value[i];
                }

                return n.toString();
              }
            },
            0x075f: {
              'name': 'Maximum ObjectData Size',
              'description': function description(value) {
                var n = 0;

                for (var i = 0; i < value.length; i++) {
                  n = (n << 8) + value[i];
                }

                return n.toString();
              }
            }
          }
        };

        function getCreationDate(value) {
          var date = Object(_tag_names_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringValue"])(value);

          if (date.length >= 8) {
            return date.substr(0, 4) + '-' + date.substr(4, 2) + '-' + date.substr(6, 2);
          }

          return date;
        }

        function getCreationTime(value) {
          var time = Object(_tag_names_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringValue"])(value);
          var parsedTime = time;

          if (time.length >= 6) {
            parsedTime = time.substr(0, 2) + ':' + time.substr(2, 2) + ':' + time.substr(4, 2);

            if (time.length === 11) {
              parsedTime += time.substr(6, 1) + time.substr(7, 2) + ':' + time.substr(9, 2);
            }
          }

          return parsedTime;
        }

        function getEncodingName(value) {
          var string = Object(_tag_names_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringValue"])(value);

          if (string === '\x1b%G') {
            return 'UTF-8';
          } else if (string === '\x1b%5') {
            return 'Windows-1252';
          } else if (string === '\x1b%/G') {
            return 'UTF-8 Level 1';
          } else if (string === '\x1b%/H') {
            return 'UTF-8 Level 2';
          } else if (string === '\x1b%/I') {
            return 'UTF-8 Level 3';
          } else if (string === '\x1B/A') {
            return 'ISO-8859-1';
          } else if (string === '\x1B/B') {
            return 'ISO-8859-2';
          } else if (string === '\x1B/C') {
            return 'ISO-8859-3';
          } else if (string === '\x1B/D') {
            return 'ISO-8859-4';
          } else if (string === '\x1B/@') {
            return 'ISO-8859-5';
          } else if (string === '\x1B/G') {
            return 'ISO-8859-6';
          } else if (string === '\x1B/F') {
            return 'ISO-8859-7';
          } else if (string === '\x1B/H') {
            return 'ISO-8859-8';
          }

          return 'Unknown';
        }
        /***/

      },

      /***/
      "./src/iptc-tags.js":
      /*!**************************!*\
        !*** ./src/iptc-tags.js ***!
        \**************************/

      /*! exports provided: default */

      /***/
      function srcIptcTagsJs(module, __webpack_exports__, __webpack_require__) {
        "use strict";

        __webpack_require__.r(__webpack_exports__);
        /* harmony import */


        var _iptc_tag_names_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        /*! ./iptc-tag-names.js */
        "./src/iptc-tag-names.js");
        /* harmony import */


        var _tag_decoder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
        /*! ./tag-decoder.js */
        "./src/tag-decoder.js");
        /* This Source Code Form is subject to the terms of the Mozilla Public
         * License, v. 2.0. If a copy of the MPL was not distributed with this
         * file, You can obtain one at https://mozilla.org/MPL/2.0/. */


        var BYTES_8BIM = 0x3842494d;
        var BYTES_8BIM_SIZE = 4;
        var RESOURCE_BLOCK_HEADER_SIZE = BYTES_8BIM_SIZE + 8;
        var NAA_RESOURCE_BLOCK_TYPE = 0x0404;
        var TAG_HEADER_SIZE = 5;
        /* harmony default export */

        __webpack_exports__["default"] = {
          read: read
        };

        function read(dataView, dataOffset) {
          try {
            if (Array.isArray(dataView)) {
              return parseTags(new DataView(Uint8Array.from(dataView).buffer), {
                size: dataView.length
              }, 0);
            }

            var _getNaaResourceBlock = getNaaResourceBlock(dataView, dataOffset),
                naaBlock = _getNaaResourceBlock.naaBlock,
                newDataOffset = _getNaaResourceBlock.dataOffset;

            return parseTags(dataView, naaBlock, newDataOffset);
          } catch (error) {
            return {};
          }
        }

        function getNaaResourceBlock(dataView, dataOffset) {
          while (dataOffset + RESOURCE_BLOCK_HEADER_SIZE <= dataView.byteLength) {
            var resourceBlock = getResourceBlock(dataView, dataOffset);

            if (isNaaResourceBlock(resourceBlock)) {
              return {
                naaBlock: resourceBlock,
                dataOffset: dataOffset + RESOURCE_BLOCK_HEADER_SIZE
              };
            }

            dataOffset += RESOURCE_BLOCK_HEADER_SIZE + resourceBlock.size + getBlockPadding(resourceBlock);
          }

          throw new Error('No IPTC NAA resource block.');
        }

        function getResourceBlock(dataView, dataOffset) {
          var RESOURCE_BLOCK_SIZE_OFFSET = 10;

          if (dataView.getUint32(dataOffset, false) !== BYTES_8BIM) {
            throw new Error('Not an IPTC resource block.');
          }

          return {
            type: dataView.getUint16(dataOffset + BYTES_8BIM_SIZE),
            size: dataView.getUint16(dataOffset + RESOURCE_BLOCK_SIZE_OFFSET)
          };
        }

        function isNaaResourceBlock(resourceBlock) {
          return resourceBlock.type === NAA_RESOURCE_BLOCK_TYPE;
        }

        function getBlockPadding(resourceBlock) {
          if (resourceBlock.size % 2 !== 0) {
            return 1;
          }

          return 0;
        }

        function parseTags(dataView, naaBlock, dataOffset) {
          var tags = {};
          var encoding = undefined;
          var endOfBlockOffset = dataOffset + naaBlock['size'];

          while (dataOffset < endOfBlockOffset && dataOffset < dataView.byteLength) {
            var _readTag = readTag(dataView, dataOffset, tags, encoding),
                tag = _readTag.tag,
                tagSize = _readTag.tagSize;

            if (tag === null) {
              break;
            }

            if ('encoding' in tag) {
              encoding = tag.encoding;
            }

            if (tags[tag.name] === undefined || tag['repeatable'] === undefined) {
              tags[tag.name] = {
                id: tag.id,
                value: tag.value,
                description: tag.description
              };
            } else {
              if (!(tags[tag.name] instanceof Array)) {
                tags[tag.name] = [{
                  id: tags[tag.name].id,
                  value: tags[tag.name].value,
                  description: tags[tag.name].description
                }];
              }

              tags[tag.name].push({
                id: tag.id,
                value: tag.value,
                description: tag.description
              });
            }

            dataOffset += TAG_HEADER_SIZE + tagSize;
          }

          return tags;
        }

        function readTag(dataView, dataOffset, tags, encoding) {
          var TAG_CODE_OFFSET = 1;
          var TAG_SIZE_OFFSET = 3;

          if (leadByteIsMissing(dataView, dataOffset)) {
            return {
              tag: null,
              tagSize: 0
            };
          }

          var tagCode = dataView.getUint16(dataOffset + TAG_CODE_OFFSET);
          var tagSize = dataView.getUint16(dataOffset + TAG_SIZE_OFFSET);
          var tagValue = getTagValue(dataView, dataOffset + TAG_HEADER_SIZE, tagSize);
          var tag = {
            id: tagCode,
            name: getTagName(_iptc_tag_names_js__WEBPACK_IMPORTED_MODULE_0__["default"]['iptc'][tagCode], tagCode, tagValue),
            value: tagValue,
            description: getTagDescription(_iptc_tag_names_js__WEBPACK_IMPORTED_MODULE_0__["default"]['iptc'][tagCode], tagValue, tags, encoding)
          };

          if (tagIsRepeatable(tagCode)) {
            tag['repeatable'] = true;
          }

          if (tagContainsEncoding(tagCode)) {
            tag['encoding'] = _iptc_tag_names_js__WEBPACK_IMPORTED_MODULE_0__["default"]['iptc'][tagCode]['encoding_name'](tagValue);
          }

          return {
            tag: tag,
            tagSize: tagSize
          };
        }

        function leadByteIsMissing(dataView, dataOffset) {
          var TAG_LEAD_BYTE = 0x1c;
          return dataView.getUint8(dataOffset) !== TAG_LEAD_BYTE;
        }

        function getTagValue(dataView, offset, size) {
          var value = [];

          for (var valueIndex = 0; valueIndex < size; valueIndex++) {
            value.push(dataView.getUint8(offset + valueIndex));
          }

          return value;
        }

        function getTagName(tag, tagCode, tagValue) {
          if (!tag) {
            return "undefined-".concat(tagCode);
          }

          if (tagIsName(tag)) {
            return tag;
          }

          if (hasDynamicName(tag)) {
            return tag['name'](tagValue);
          }

          return tag['name'];
        }

        function tagIsName(tag) {
          return typeof tag === 'string';
        }

        function hasDynamicName(tag) {
          return typeof tag['name'] === 'function';
        }

        function getTagDescription(tag, tagValue, tags, encoding) {
          if (hasDescriptionProperty(tag)) {
            try {
              return tag['description'](tagValue, tags);
            } catch (error) {// Fall through to next handler.
            }
          }

          if (tagValueIsText(tag, tagValue)) {
            return _tag_decoder_js__WEBPACK_IMPORTED_MODULE_1__["default"].decode(encoding, tagValue);
          }

          return tagValue;
        }

        function tagValueIsText(tag, tagValue) {
          return tag && tagValue instanceof Array;
        }

        function hasDescriptionProperty(tag) {
          return tag && tag['description'] !== undefined;
        }

        function tagIsRepeatable(tagCode) {
          return _iptc_tag_names_js__WEBPACK_IMPORTED_MODULE_0__["default"]['iptc'][tagCode] && _iptc_tag_names_js__WEBPACK_IMPORTED_MODULE_0__["default"]['iptc'][tagCode]['repeatable'];
        }

        function tagContainsEncoding(tagCode) {
          return _iptc_tag_names_js__WEBPACK_IMPORTED_MODULE_0__["default"]['iptc'][tagCode] && _iptc_tag_names_js__WEBPACK_IMPORTED_MODULE_0__["default"]['iptc'][tagCode]['encoding_name'] !== undefined;
        }
        /***/

      },

      /***/
      "./src/png-file-tags.js":
      /*!******************************!*\
        !*** ./src/png-file-tags.js ***!
        \******************************/

      /*! exports provided: default */

      /***/
      function srcPngFileTagsJs(module, __webpack_exports__, __webpack_require__) {
        "use strict";

        __webpack_require__.r(__webpack_exports__);
        /* harmony import */


        var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        /*! ./types.js */
        "./src/types.js");
        /* This Source Code Form is subject to the terms of the Mozilla Public
         * License, v. 2.0. If a copy of the MPL was not distributed with this
         * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

        /* harmony default export */


        __webpack_exports__["default"] = {
          read: read
        };

        function read(dataView, fileDataOffset) {
          return {
            'Image Width': getImageWidth(dataView, fileDataOffset),
            'Image Height': getImageHeight(dataView, fileDataOffset),
            'Bit Depth': getBitDepth(dataView, fileDataOffset),
            'Color Type': getColorType(dataView, fileDataOffset),
            'Compression': getCompression(dataView, fileDataOffset),
            'Filter': getFilter(dataView, fileDataOffset),
            'Interlace': getInterlace(dataView, fileDataOffset)
          };
        }

        function getImageWidth(dataView, fileDataOffset) {
          var OFFSET = 0;
          var SIZE = 4;

          if (fileDataOffset + OFFSET + SIZE > dataView.byteLength) {
            return undefined;
          }

          var value = _types_js__WEBPACK_IMPORTED_MODULE_0__["default"].getLongAt(dataView, fileDataOffset);

          return {
            value: value,
            description: "".concat(value, "px")
          };
        }

        function getImageHeight(dataView, fileDataOffset) {
          var OFFSET = 4;
          var SIZE = 4;

          if (fileDataOffset + OFFSET + SIZE > dataView.byteLength) {
            return undefined;
          }

          var value = _types_js__WEBPACK_IMPORTED_MODULE_0__["default"].getLongAt(dataView, fileDataOffset + OFFSET);

          return {
            value: value,
            description: "".concat(value, "px")
          };
        }

        function getBitDepth(dataView, fileDataOffset) {
          var OFFSET = 8;
          var SIZE = 1;

          if (fileDataOffset + OFFSET + SIZE > dataView.byteLength) {
            return undefined;
          }

          var value = _types_js__WEBPACK_IMPORTED_MODULE_0__["default"].getByteAt(dataView, fileDataOffset + OFFSET);

          return {
            value: value,
            description: "".concat(value)
          };
        }

        function getColorType(dataView, fileDataOffset) {
          var OFFSET = 9;
          var SIZE = 1;
          var COLOR_TYPES = {
            0: 'Grayscale',
            2: 'RGB',
            3: 'Palette',
            4: 'Grayscale with Alpha',
            6: 'RGB with Alpha'
          };

          if (fileDataOffset + OFFSET + SIZE > dataView.byteLength) {
            return undefined;
          }

          var value = _types_js__WEBPACK_IMPORTED_MODULE_0__["default"].getByteAt(dataView, fileDataOffset + OFFSET);

          return {
            value: value,
            description: COLOR_TYPES[value] || 'Unknown'
          };
        }

        function getCompression(dataView, fileDataOffset) {
          var OFFSET = 10;
          var SIZE = 1;

          if (fileDataOffset + OFFSET + SIZE > dataView.byteLength) {
            return undefined;
          }

          var value = _types_js__WEBPACK_IMPORTED_MODULE_0__["default"].getByteAt(dataView, fileDataOffset + OFFSET);

          return {
            value: value,
            description: value === 0 ? 'Deflate/Inflate' : 'Unknown'
          };
        }

        function getFilter(dataView, fileDataOffset) {
          var OFFSET = 11;
          var SIZE = 1;

          if (fileDataOffset + OFFSET + SIZE > dataView.byteLength) {
            return undefined;
          }

          var value = _types_js__WEBPACK_IMPORTED_MODULE_0__["default"].getByteAt(dataView, fileDataOffset + OFFSET);

          return {
            value: value,
            description: value === 0 ? 'Adaptive' : 'Unknown'
          };
        }

        function getInterlace(dataView, fileDataOffset) {
          var OFFSET = 12;
          var SIZE = 1;
          var INTERLACE_TYPES = {
            0: 'Noninterlaced',
            1: 'Adam7 Interlace'
          };

          if (fileDataOffset + OFFSET + SIZE > dataView.byteLength) {
            return undefined;
          }

          var value = _types_js__WEBPACK_IMPORTED_MODULE_0__["default"].getByteAt(dataView, fileDataOffset + OFFSET);

          return {
            value: value,
            description: INTERLACE_TYPES[value] || 'Unknown'
          };
        }
        /***/

      },

      /***/
      "./src/tag-decoder.js":
      /*!****************************!*\
        !*** ./src/tag-decoder.js ***!
        \****************************/

      /*! exports provided: default */

      /***/
      function srcTagDecoderJs(module, __webpack_exports__, __webpack_require__) {
        "use strict";

        __webpack_require__.r(__webpack_exports__);
        /* harmony import */


        var _text_decoder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        /*! ./text-decoder.js */
        "./src/text-decoder.js");
        /* This Source Code Form is subject to the terms of the Mozilla Public
         * License, v. 2.0. If a copy of the MPL was not distributed with this
         * file, You can obtain one at https://mozilla.org/MPL/2.0/. */


        var TAG_HEADER_SIZE = 5;
        /* harmony default export */

        __webpack_exports__["default"] = {
          decode: decode,
          TAG_HEADER_SIZE: TAG_HEADER_SIZE
        };

        function decode(encoding, tagValue) {
          var Decoder = _text_decoder_js__WEBPACK_IMPORTED_MODULE_0__["default"].get();

          if (typeof Decoder !== 'undefined' && encoding !== undefined) {
            try {
              return new Decoder(encoding).decode(Uint8Array.from(tagValue));
            } catch (error) {// Pass through and fall back to ASCII decoding.
            }
          }

          var stringValue = tagValue.map(function (charCode) {
            return String.fromCharCode(charCode);
          }).join('');
          return decodeAsciiValue(stringValue);
        }

        function decodeAsciiValue(asciiValue) {
          try {
            return decodeURIComponent(escape(asciiValue));
          } catch (error) {
            return asciiValue;
          }
        }
        /***/

      },

      /***/
      "./src/tag-names-0th-ifd.js":
      /*!**********************************!*\
        !*** ./src/tag-names-0th-ifd.js ***!
        \**********************************/

      /*! exports provided: default */

      /***/
      function srcTagNames0thIfdJs(module, __webpack_exports__, __webpack_require__) {
        "use strict";

        __webpack_require__.r(__webpack_exports__);
        /* harmony import */


        var _tag_names_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        /*! ./tag-names-common.js */
        "./src/tag-names-common.js");
        /* This Source Code Form is subject to the terms of the Mozilla Public
         * License, v. 2.0. If a copy of the MPL was not distributed with this
         * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

        /* harmony default export */


        __webpack_exports__["default"] = {
          0x000b: 'ProcessingSoftware',
          0x00fe: {
            name: 'SubfileType',
            description: function description(value) {
              return {
                0x0: 'Full-resolution image',
                0x1: 'Reduced-resolution image',
                0x2: 'Single page of multi-page image',
                0x3: 'Single page of multi-page reduced-resolution image',
                0x4: 'Transparency mask',
                0x5: 'Transparency mask of reduced-resolution image',
                0x6: 'Transparency mask of multi-page image',
                0x7: 'Transparency mask of reduced-resolution multi-page image',
                0x10001: 'Alternate reduced-resolution image',
                0xffffffff: 'Invalid'
              }[value] || 'Unknown';
            }
          },
          0x00ff: {
            name: 'OldSubfileType',
            description: function description(value) {
              return {
                0: 'Full-resolution image',
                1: 'Reduced-resolution image',
                2: 'Single page of multi-page image'
              }[value] || 'Unknown';
            }
          },
          0x0100: 'ImageWidth',
          0x0101: 'ImageLength',
          0x0102: 'BitsPerSample',
          0x0103: 'Compression',
          0x0106: 'PhotometricInterpretation',
          0x0107: {
            name: 'Thresholding',
            description: function description(value) {
              return {
                1: 'No dithering or halftoning',
                2: 'Ordered dither or halfton',
                3: 'Randomized dither'
              }[value] || 'Unknown';
            }
          },
          0x0108: 'CellWidth',
          0x0109: 'CellLength',
          0x010a: {
            name: 'FillOrder',
            description: function description(value) {
              return {
                1: 'Normal',
                2: 'Reversed'
              }[value] || 'Unknown';
            }
          },
          0x010d: 'DocumentName',
          0x010e: 'ImageDescription',
          0x010f: 'Make',
          0x0110: 'Model',
          0x0111: 'StripOffsets',
          0x0112: {
            name: 'Orientation',
            description: function description(value) {
              if (value === 1) {
                return 'top-left';
              }

              if (value === 2) {
                return 'top-right';
              }

              if (value === 3) {
                return 'bottom-right';
              }

              if (value === 4) {
                return 'bottom-left';
              }

              if (value === 5) {
                return 'left-top';
              }

              if (value === 6) {
                return 'right-top';
              }

              if (value === 7) {
                return 'right-bottom';
              }

              if (value === 8) {
                return 'left-bottom';
              }

              return 'Undefined';
            }
          },
          0x0115: 'SamplesPerPixel',
          0x0116: 'RowsPerStrip',
          0x0117: 'StripByteCounts',
          0x0118: 'MinSampleValue',
          0x0119: 'MaxSampleValue',
          0x011a: {
            'name': 'XResolution',
            'description': function description(value) {
              return '' + Math.round(value[0] / value[1]);
            }
          },
          0x011b: {
            'name': 'YResolution',
            'description': function description(value) {
              return '' + Math.round(value[0] / value[1]);
            }
          },
          0x011c: 'PlanarConfiguration',
          0x011d: 'PageName',
          0x011e: {
            'name': 'XPosition',
            'description': function description(value) {
              return '' + Math.round(value[0] / value[1]);
            }
          },
          0x011f: {
            'name': 'YPosition',
            'description': function description(value) {
              return '' + Math.round(value[0] / value[1]);
            }
          },
          0x0122: {
            name: 'GrayResponseUnit',
            description: function description(value) {
              return {
                1: '0.1',
                2: '0.001',
                3: '0.0001',
                4: '1e-05',
                5: '1e-06'
              }[value] || 'Unknown';
            }
          },
          0x0128: {
            name: 'ResolutionUnit',
            description: function description(value) {
              if (value === 2) {
                return 'inches';
              }

              if (value === 3) {
                return 'centimeters';
              }

              return 'Unknown';
            }
          },
          0x0129: 'PageNumber',
          0x012d: 'TransferFunction',
          0x0131: 'Software',
          0x0132: 'DateTime',
          0x013b: 'Artist',
          0x013c: 'HostComputer',
          0x013d: 'Predictor',
          0x013e: {
            'name': 'WhitePoint',
            'description': function description(values) {
              return values.map(function (value) {
                return "".concat(value[0], "/").concat(value[1]);
              }).join(', ');
            }
          },
          0x013f: {
            'name': 'PrimaryChromaticities',
            'description': function description(values) {
              return values.map(function (value) {
                return "".concat(value[0], "/").concat(value[1]);
              }).join(', ');
            }
          },
          0x0141: 'HalftoneHints',
          0x0142: 'TileWidth',
          0x0143: 'TileLength',
          0x014a: 'A100DataOffset',
          0x014c: {
            name: 'InkSet',
            description: function description(value) {
              return {
                1: 'CMYK',
                2: 'Not CMYK'
              }[value] || 'Unknown';
            }
          },
          0x0151: 'TargetPrinter',
          0x0152: {
            name: 'ExtraSamples',
            description: function description(value) {
              return {
                0: 'Unspecified',
                1: 'Associated Alpha',
                2: 'Unassociated Alpha'
              }[value] || 'Unknown';
            }
          },
          0x0153: {
            name: 'SampleFormat',
            description: function description(value) {
              var formats = {
                1: 'Unsigned',
                2: 'Signed',
                3: 'Float',
                4: 'Undefined',
                5: 'Complex int',
                6: 'Complex float'
              };

              if (!Array.isArray(value)) {
                return 'Unknown';
              }

              return value.map(function (sample) {
                return formats[sample] || 'Unknown';
              }).join(', ');
            }
          },
          0x0201: 'JPEGInterchangeFormat',
          0x0202: 'JPEGInterchangeFormatLength',
          0x0211: {
            'name': 'YCbCrCoefficients',
            'description': function description(values) {
              return values.map(function (value) {
                return '' + value[0] / value[1];
              }).join('/');
            }
          },
          0x0212: 'YCbCrSubSampling',
          0x0213: {
            name: 'YCbCrPositioning',
            description: function description(value) {
              if (value === 1) {
                return 'centered';
              }

              if (value === 2) {
                return 'co-sited';
              }

              return 'undefined ' + value;
            }
          },
          0x0214: {
            'name': 'ReferenceBlackWhite',
            'description': function description(values) {
              return values.map(function (value) {
                return '' + value[0] / value[1];
              }).join(', ');
            }
          },
          0x02bc: 'ApplicationNotes',
          0x4746: 'Rating',
          0x4749: 'RatingPercent',
          0x8298: {
            name: 'Copyright',
            description: function description(value) {
              return value.join('; ');
            }
          },
          0x830e: 'PixelScale',
          0x83bb: 'IPTC-NAA',
          0x8480: 'IntergraphMatrix',
          0x8482: 'ModelTiePoint',
          0x8546: 'SEMInfo',
          0x85d8: 'ModelTransform',
          0x8649: 'PhotoshopSettings',
          0x8769: 'Exif IFD Pointer',
          0x8773: 'ICC_Profile',
          0x87af: 'GeoTiffDirectory',
          0x87b0: 'GeoTiffDoubleParams',
          0x87b1: 'GeoTiffAsciiParams',
          0x8825: 'GPS Info IFD Pointer',
          0x9c9b: 'XPTitle',
          0x9c9c: 'XPComment',
          0x9c9d: 'XPAuthor',
          0x9c9e: 'XPKeywords',
          0x9c9f: 'XPSubject',
          0xa480: 'GDALMetadata',
          0xa481: 'GDALNoData',
          0xc4a5: 'PrintIM',
          0xc613: 'DNGBackwardVersion',
          0xc614: 'UniqueCameraModel',
          0xc615: 'LocalizedCameraModel',
          0xc621: 'ColorMatrix1',
          0xc622: 'ColorMatrix2',
          0xc623: 'CameraCalibration1',
          0xc624: 'CameraCalibration2',
          0xc625: 'ReductionMatrix1',
          0xc626: 'ReductionMatrix2',
          0xc627: 'AnalogBalance',
          0xc628: 'AsShotNeutral',
          0xc629: 'AsShotWhiteXY',
          0xc62a: 'BaselineExposure',
          0xc62b: 'BaselineNoise',
          0xc62c: 'BaselineSharpness',
          0xc62e: 'LinearResponseLimit',
          0xc62f: 'CameraSerialNumber',
          0xc630: 'DNGLensInfo',
          0xc633: 'ShadowScale',
          0xc635: {
            name: 'MakerNoteSafety',
            description: function description(value) {
              return {
                0: 'Unsafe',
                1: 'Safe'
              }[value] || 'Unknown';
            }
          },
          0xc65a: {
            name: 'CalibrationIlluminant1',
            description: _tag_names_common_js__WEBPACK_IMPORTED_MODULE_0__["default"]['LightSource']
          },
          0xc65b: {
            name: 'CalibrationIlluminant2',
            description: _tag_names_common_js__WEBPACK_IMPORTED_MODULE_0__["default"]['LightSource']
          },
          0xc65d: 'RawDataUniqueID',
          0xc68b: 'OriginalRawFileName',
          0xc68c: 'OriginalRawFileData',
          0xc68f: 'AsShotICCProfile',
          0xc690: 'AsShotPreProfileMatrix',
          0xc691: 'CurrentICCProfile',
          0xc692: 'CurrentPreProfileMatrix',
          0xc6bf: 'ColorimetricReference',
          0xc6c5: 'SRawType',
          0xc6d2: 'PanasonicTitle',
          0xc6d3: 'PanasonicTitle2',
          0xc6f3: 'CameraCalibrationSig',
          0xc6f4: 'ProfileCalibrationSig',
          0xc6f5: 'ProfileIFD',
          0xc6f6: 'AsShotProfileName',
          0xc6f8: 'ProfileName',
          0xc6f9: 'ProfileHueSatMapDims',
          0xc6fa: 'ProfileHueSatMapData1',
          0xc6fb: 'ProfileHueSatMapData2',
          0xc6fc: 'ProfileToneCurve',
          0xc6fd: {
            name: 'ProfileEmbedPolicy',
            description: function description(value) {
              return {
                0: 'Allow Copying',
                1: 'Embed if Used',
                2: 'Never Embed',
                3: 'No Restrictions'
              }[value] || 'Unknown';
            }
          },
          0xc6fe: 'ProfileCopyright',
          0xc714: 'ForwardMatrix1',
          0xc715: 'ForwardMatrix2',
          0xc716: 'PreviewApplicationName',
          0xc717: 'PreviewApplicationVersion',
          0xc718: 'PreviewSettingsName',
          0xc719: 'PreviewSettingsDigest',
          0xc71a: {
            name: 'PreviewColorSpace',
            description: function description(value) {
              return {
                1: 'Gray Gamma 2.2',
                2: 'sRGB',
                3: 'Adobe RGB',
                4: 'ProPhoto RGB'
              }[value] || 'Unknown';
            }
          },
          0xc71b: 'PreviewDateTime',
          0xc71c: 'RawImageDigest',
          0xc71d: 'OriginalRawFileDigest',
          0xc725: 'ProfileLookTableDims',
          0xc726: 'ProfileLookTableData',
          0xc763: 'TimeCodes',
          0xc764: 'FrameRate',
          0xc772: 'TStop',
          0xc789: 'ReelName',
          0xc791: 'OriginalDefaultFinalSize',
          0xc792: 'OriginalBestQualitySize',
          0xc793: 'OriginalDefaultCropSize',
          0xc7a1: 'CameraLabel',
          0xc7a3: {
            name: 'ProfileHueSatMapEncoding',
            description: function description(value) {
              return {
                0: 'Linear',
                1: 'sRGB'
              }[value] || 'Unknown';
            }
          },
          0xc7a4: {
            name: 'ProfileLookTableEncoding',
            description: function description(value) {
              return {
                0: 'Linear',
                1: 'sRGB'
              }[value] || 'Unknown';
            }
          },
          0xc7a5: 'BaselineExposureOffset',
          0xc7a6: {
            name: 'DefaultBlackRender',
            description: function description(value) {
              return {
                0: 'Auto',
                1: 'None'
              }[value] || 'Unknown';
            }
          },
          0xc7a7: 'NewRawImageDigest',
          0xc7a8: 'RawToPreviewGain'
        };
        /***/
      },

      /***/
      "./src/tag-names-common.js":
      /*!*********************************!*\
        !*** ./src/tag-names-common.js ***!
        \*********************************/

      /*! exports provided: default */

      /***/
      function srcTagNamesCommonJs(module, __webpack_exports__, __webpack_require__) {
        "use strict";

        __webpack_require__.r(__webpack_exports__);
        /* This Source Code Form is subject to the terms of the Mozilla Public
         * License, v. 2.0. If a copy of the MPL was not distributed with this
         * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

        /* harmony default export */


        __webpack_exports__["default"] = {
          'LightSource': function LightSource(value) {
            if (value === 1) {
              return 'Daylight';
            } else if (value === 2) {
              return 'Fluorescent';
            } else if (value === 3) {
              return 'Tungsten (incandescent light)';
            } else if (value === 4) {
              return 'Flash';
            } else if (value === 9) {
              return 'Fine weather';
            } else if (value === 10) {
              return 'Cloudy weather';
            } else if (value === 11) {
              return 'Shade';
            } else if (value === 12) {
              return 'Daylight fluorescent (D 5700  7100K)';
            } else if (value === 13) {
              return 'Day white fluorescent (N 4600  5400K)';
            } else if (value === 14) {
              return 'Cool white fluorescent (W 3900  4500K)';
            } else if (value === 15) {
              return 'White fluorescent (WW 3200  3700K)';
            } else if (value === 17) {
              return 'Standard light A';
            } else if (value === 18) {
              return 'Standard light B';
            } else if (value === 19) {
              return 'Standard light C';
            } else if (value === 20) {
              return 'D55';
            } else if (value === 21) {
              return 'D65';
            } else if (value === 22) {
              return 'D75';
            } else if (value === 23) {
              return 'D50';
            } else if (value === 24) {
              return 'ISO studio tungsten';
            } else if (value === 255) {
              return 'Other light source';
            }

            return 'Unknown';
          }
        };
        /***/
      },

      /***/
      "./src/tag-names-exif-ifd.js":
      /*!***********************************!*\
        !*** ./src/tag-names-exif-ifd.js ***!
        \***********************************/

      /*! exports provided: default */

      /***/
      function srcTagNamesExifIfdJs(module, __webpack_exports__, __webpack_require__) {
        "use strict";

        __webpack_require__.r(__webpack_exports__);
        /* harmony import */


        var _tag_names_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        /*! ./tag-names-utils.js */
        "./src/tag-names-utils.js");
        /* harmony import */


        var _tag_names_common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
        /*! ./tag-names-common.js */
        "./src/tag-names-common.js");

        function _slicedToArray(arr, i) {
          return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
        }

        function _nonIterableRest() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }

        function _unsupportedIterableToArray(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(n);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
        }

        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length) len = arr.length;

          for (var i = 0, arr2 = new Array(len); i < len; i++) {
            arr2[i] = arr[i];
          }

          return arr2;
        }

        function _iterableToArrayLimit(arr, i) {
          if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = undefined;

          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);

              if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"] != null) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }

          return _arr;
        }

        function _arrayWithHoles(arr) {
          if (Array.isArray(arr)) return arr;
        }
        /* This Source Code Form is subject to the terms of the Mozilla Public
         * License, v. 2.0. If a copy of the MPL was not distributed with this
         * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

        /* harmony default export */


        __webpack_exports__["default"] = {
          0x829a: {
            'name': 'ExposureTime',
            'description': function description(value) {
              if (value[0] !== 0) {
                return "1/".concat(Math.round(value[1] / value[0]));
              }

              return "0/".concat(value[1]);
            }
          },
          0x829d: {
            'name': 'FNumber',
            'description': function description(value) {
              return "f/".concat(value[0] / value[1]);
            }
          },
          0x8822: {
            'name': 'ExposureProgram',
            'description': function description(value) {
              if (value === 0) {
                return 'Undefined';
              } else if (value === 1) {
                return 'Manual';
              } else if (value === 2) {
                return 'Normal program';
              } else if (value === 3) {
                return 'Aperture priority';
              } else if (value === 4) {
                return 'Shutter priority';
              } else if (value === 5) {
                return 'Creative program';
              } else if (value === 6) {
                return 'Action program';
              } else if (value === 7) {
                return 'Portrait mode';
              } else if (value === 8) {
                return 'Landscape mode';
              } else if (value === 9) {
                return 'Bulb';
              }

              return 'Unknown';
            }
          },
          0x8824: 'SpectralSensitivity',
          0x8827: 'ISOSpeedRatings',
          0x8828: {
            'name': 'OECF',
            'description': function description() {
              return '[Raw OECF table data]';
            }
          },
          0x882a: 'TimeZoneOffset',
          0x882b: 'SelfTimerMode',
          0x8830: {
            name: 'SensitivityType',
            description: function description(value) {
              return {
                1: 'Standard Output Sensitivity',
                2: 'Recommended Exposure Index',
                3: 'ISO Speed',
                4: 'Standard Output Sensitivity and Recommended Exposure Index',
                5: 'Standard Output Sensitivity and ISO Speed',
                6: 'Recommended Exposure Index and ISO Speed',
                7: 'Standard Output Sensitivity, Recommended Exposure Index and ISO Speed'
              }[value] || 'Unknown';
            }
          },
          0x8831: 'StandardOutputSensitivity',
          0x8832: 'RecommendedExposureIndex',
          0x8833: 'ISOSpeed',
          0x8834: 'ISOSpeedLatitudeyyy',
          0x8835: 'ISOSpeedLatitudezzz',
          0x9000: {
            'name': 'ExifVersion',
            'description': function description(value) {
              return Object(_tag_names_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringValue"])(value);
            }
          },
          0x9003: 'DateTimeOriginal',
          0x9004: 'DateTimeDigitized',
          0x9009: 'GooglePlusUploadCode',
          0x9010: 'OffsetTime',
          0x9011: 'OffsetTimeOriginal',
          0x9012: 'OffsetTimeDigitized',
          0x9101: {
            'name': 'ComponentsConfiguration',
            'description': function description(value) {
              return value.map(function (character) {
                if (character === 0x31) {
                  return 'Y';
                } else if (character === 0x32) {
                  return 'Cb';
                } else if (character === 0x33) {
                  return 'Cr';
                } else if (character === 0x34) {
                  return 'R';
                } else if (character === 0x35) {
                  return 'G';
                } else if (character === 0x36) {
                  return 'B';
                }
              }).join('');
            }
          },
          0x9102: 'CompressedBitsPerPixel',
          0x9201: {
            'name': 'ShutterSpeedValue',
            'description': function description(value) {
              return "1/".concat(Math.round(Math.pow(2, value[0] / value[1])));
            }
          },
          0x9202: {
            'name': 'ApertureValue',
            'description': function description(value) {
              return Math.pow(Math.sqrt(2), value[0] / value[1]).toFixed(2);
            }
          },
          0x9203: 'BrightnessValue',
          0x9204: 'ExposureBiasValue',
          0x9205: {
            'name': 'MaxApertureValue',
            'description': function description(value) {
              return Math.pow(Math.sqrt(2), value[0] / value[1]).toFixed(2);
            }
          },
          0x9206: {
            'name': 'SubjectDistance',
            'description': function description(value) {
              return value[0] / value[1] + ' m';
            }
          },
          0x9207: {
            'name': 'MeteringMode',
            'description': function description(value) {
              if (value === 1) {
                return 'Average';
              } else if (value === 2) {
                return 'CenterWeightedAverage';
              } else if (value === 3) {
                return 'Spot';
              } else if (value === 4) {
                return 'MultiSpot';
              } else if (value === 5) {
                return 'Pattern';
              } else if (value === 6) {
                return 'Partial';
              } else if (value === 255) {
                return 'Other';
              }

              return 'Unknown';
            }
          },
          0x9208: {
            'name': 'LightSource',
            description: _tag_names_common_js__WEBPACK_IMPORTED_MODULE_1__["default"]['LightSource']
          },
          0x9209: {
            'name': 'Flash',
            'description': function description(value) {
              if (value === 0x00) {
                return 'Flash did not fire';
              } else if (value === 0x01) {
                return 'Flash fired';
              } else if (value === 0x05) {
                return 'Strobe return light not detected';
              } else if (value === 0x07) {
                return 'Strobe return light detected';
              } else if (value === 0x09) {
                return 'Flash fired, compulsory flash mode';
              } else if (value === 0x0d) {
                return 'Flash fired, compulsory flash mode, return light not detected';
              } else if (value === 0x0f) {
                return 'Flash fired, compulsory flash mode, return light detected';
              } else if (value === 0x10) {
                return 'Flash did not fire, compulsory flash mode';
              } else if (value === 0x18) {
                return 'Flash did not fire, auto mode';
              } else if (value === 0x19) {
                return 'Flash fired, auto mode';
              } else if (value === 0x1d) {
                return 'Flash fired, auto mode, return light not detected';
              } else if (value === 0x1f) {
                return 'Flash fired, auto mode, return light detected';
              } else if (value === 0x20) {
                return 'No flash function';
              } else if (value === 0x41) {
                return 'Flash fired, red-eye reduction mode';
              } else if (value === 0x45) {
                return 'Flash fired, red-eye reduction mode, return light not detected';
              } else if (value === 0x47) {
                return 'Flash fired, red-eye reduction mode, return light detected';
              } else if (value === 0x49) {
                return 'Flash fired, compulsory flash mode, red-eye reduction mode';
              } else if (value === 0x4d) {
                return 'Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected';
              } else if (value === 0x4f) {
                return 'Flash fired, compulsory flash mode, red-eye reduction mode, return light detected';
              } else if (value === 0x59) {
                return 'Flash fired, auto mode, red-eye reduction mode';
              } else if (value === 0x5d) {
                return 'Flash fired, auto mode, return light not detected, red-eye reduction mode';
              } else if (value === 0x5f) {
                return 'Flash fired, auto mode, return light detected, red-eye reduction mode';
              }

              return 'Unknown';
            }
          },
          0x920a: {
            'name': 'FocalLength',
            'description': function description(value) {
              return value[0] / value[1] + ' mm';
            }
          },
          0x9211: 'ImageNumber',
          0x9212: {
            name: 'SecurityClassification',
            description: function description(value) {
              return {
                'C': 'Confidential',
                'R': 'Restricted',
                'S': 'Secret',
                'T': 'Top Secret',
                'U': 'Unclassified'
              }[value] || 'Unknown';
            }
          },
          0x9213: 'ImageHistory',
          0x9214: {
            'name': 'SubjectArea',
            'description': function description(value) {
              if (value.length === 2) {
                return "Location; X: ".concat(value[0], ", Y: ").concat(value[1]);
              } else if (value.length === 3) {
                return "Circle; X: ".concat(value[0], ", Y: ").concat(value[1], ", diameter: ").concat(value[2]);
              } else if (value.length === 4) {
                return "Rectangle; X: ".concat(value[0], ", Y: ").concat(value[1], ", width: ").concat(value[2], ", height: ").concat(value[3]);
              }

              return 'Unknown';
            }
          },
          0x927c: {
            'name': 'MakerNote',
            'description': function description() {
              return '[Raw maker note data]';
            }
          },
          0x9286: {
            'name': 'UserComment',
            'description': _tag_names_utils_js__WEBPACK_IMPORTED_MODULE_0__["getEncodedString"]
          },
          0x9290: 'SubSecTime',
          0x9291: 'SubSecTimeOriginal',
          0x9292: 'SubSecTimeDigitized',
          0x9400: {
            'name': 'AmbientTemperature',
            'description': function description(value) {
              return value[0] / value[1] + ' C';
            }
          },
          0x9401: {
            'name': 'Humidity',
            'description': function description(value) {
              return value[0] / value[1] + ' %';
            }
          },
          0x9402: {
            'name': 'Pressure',
            'description': function description(value) {
              return value[0] / value[1] + ' hPa';
            }
          },
          0x9403: {
            'name': 'WaterDepth',
            'description': function description(value) {
              return value[0] / value[1] + ' m';
            }
          },
          0x9404: {
            'name': 'Acceleration',
            'description': function description(value) {
              return value[0] / value[1] + ' mGal';
            }
          },
          0x9405: {
            'name': 'CameraElevationAngle',
            'description': function description(value) {
              return value[0] / value[1] + ' ';
            }
          },
          0xa000: {
            'name': 'FlashpixVersion',
            'description': function description(value) {
              return value.map(function (charCode) {
                return String.fromCharCode(charCode);
              }).join('');
            }
          },
          0xa001: {
            'name': 'ColorSpace',
            'description': function description(value) {
              if (value === 1) {
                return 'sRGB';
              } else if (value === 0xffff) {
                return 'Uncalibrated';
              }

              return 'Unknown';
            }
          },
          0xa002: 'PixelXDimension',
          0xa003: 'PixelYDimension',
          0xa004: 'RelatedSoundFile',
          0xa005: 'Interoperability IFD Pointer',
          0xa20b: 'FlashEnergy',
          0xa20c: {
            'name': 'SpatialFrequencyResponse',
            'description': function description() {
              return '[Raw SFR table data]';
            }
          },
          0xa20e: 'FocalPlaneXResolution',
          0xa20f: 'FocalPlaneYResolution',
          0xa210: {
            'name': 'FocalPlaneResolutionUnit',
            'description': function description(value) {
              if (value === 2) {
                return 'inches';
              } else if (value === 3) {
                return 'centimeters';
              }

              return 'Unknown';
            }
          },
          0xa214: {
            'name': 'SubjectLocation',
            'description': function description(_ref) {
              var _ref2 = _slicedToArray(_ref, 2),
                  x = _ref2[0],
                  y = _ref2[1];

              return "X: ".concat(x, ", Y: ").concat(y);
            }
          },
          0xa215: 'ExposureIndex',
          0xa217: {
            'name': 'SensingMethod',
            'description': function description(value) {
              if (value === 1) {
                return 'Undefined';
              } else if (value === 2) {
                return 'One-chip color area sensor';
              } else if (value === 3) {
                return 'Two-chip color area sensor';
              } else if (value === 4) {
                return 'Three-chip color area sensor';
              } else if (value === 5) {
                return 'Color sequential area sensor';
              } else if (value === 7) {
                return 'Trilinear sensor';
              } else if (value === 8) {
                return 'Color sequential linear sensor';
              }

              return 'Unknown';
            }
          },
          0xa300: {
            'name': 'FileSource',
            'description': function description(value) {
              if (value === 3) {
                return 'DSC';
              }

              return 'Unknown';
            }
          },
          0xa301: {
            'name': 'SceneType',
            'description': function description(value) {
              if (value === 1) {
                return 'A directly photographed image';
              }

              return 'Unknown';
            }
          },
          0xa302: {
            'name': 'CFAPattern',
            'description': function description() {
              return '[Raw CFA pattern table data]';
            }
          },
          0xa401: {
            'name': 'CustomRendered',
            'description': function description(value) {
              if (value === 0) {
                return 'Normal process';
              } else if (value === 1) {
                return 'Custom process';
              }

              return 'Unknown';
            }
          },
          0xa402: {
            'name': 'ExposureMode',
            'description': function description(value) {
              if (value === 0) {
                return 'Auto exposure';
              } else if (value === 1) {
                return 'Manual exposure';
              } else if (value === 2) {
                return 'Auto bracket';
              }

              return 'Unknown';
            }
          },
          0xa403: {
            'name': 'WhiteBalance',
            'description': function description(value) {
              if (value === 0) {
                return 'Auto white balance';
              } else if (value === 1) {
                return 'Manual white balance';
              }

              return 'Unknown';
            }
          },
          0xa404: {
            'name': 'DigitalZoomRatio',
            'description': function description(value) {
              if (value[0] === 0) {
                return 'Digital zoom was not used';
              }

              return '' + value[0] / value[1];
            }
          },
          0xa405: {
            'name': 'FocalLengthIn35mmFilm',
            'description': function description(value) {
              if (value === 0) {
                return 'Unknown';
              }

              return value;
            }
          },
          0xa406: {
            'name': 'SceneCaptureType',
            'description': function description(value) {
              if (value === 0) {
                return 'Standard';
              } else if (value === 1) {
                return 'Landscape';
              } else if (value === 2) {
                return 'Portrait';
              } else if (value === 3) {
                return 'Night scene';
              }

              return 'Unknown';
            }
          },
          0xa407: {
            'name': 'GainControl',
            'description': function description(value) {
              if (value === 0) {
                return 'None';
              } else if (value === 1) {
                return 'Low gain up';
              } else if (value === 2) {
                return 'High gain up';
              } else if (value === 3) {
                return 'Low gain down';
              } else if (value === 4) {
                return 'High gain down';
              }

              return 'Unknown';
            }
          },
          0xa408: {
            'name': 'Contrast',
            'description': function description(value) {
              if (value === 0) {
                return 'Normal';
              } else if (value === 1) {
                return 'Soft';
              } else if (value === 2) {
                return 'Hard';
              }

              return 'Unknown';
            }
          },
          0xa409: {
            'name': 'Saturation',
            'description': function description(value) {
              if (value === 0) {
                return 'Normal';
              } else if (value === 1) {
                return 'Low saturation';
              } else if (value === 2) {
                return 'High saturation';
              }

              return 'Unknown';
            }
          },
          0xa40a: {
            'name': 'Sharpness',
            'description': function description(value) {
              if (value === 0) {
                return 'Normal';
              } else if (value === 1) {
                return 'Soft';
              } else if (value === 2) {
                return 'Hard';
              }

              return 'Unknown';
            }
          },
          0xa40b: {
            'name': 'DeviceSettingDescription',
            'description': function description() {
              return '[Raw device settings table data]';
            }
          },
          0xa40c: {
            'name': 'SubjectDistanceRange',
            'description': function description(value) {
              if (value === 1) {
                return 'Macro';
              } else if (value === 2) {
                return 'Close view';
              } else if (value === 3) {
                return 'Distant view';
              }

              return 'Unknown';
            }
          },
          0xa420: 'ImageUniqueID',
          0xa430: 'CameraOwnerName',
          0xa431: 'BodySerialNumber',
          0xa432: {
            'name': 'LensSpecification',
            'description': function description(value) {
              var focalLengths = "".concat(value[0][0] / value[0][1], "-").concat(value[1][0] / value[1][1], " mm");

              if (value[3][1] === 0) {
                return "".concat(focalLengths, " f/?");
              }

              return "".concat(focalLengths, " f/").concat(1 / (value[2][1] / value[2][1] / (value[3][0] / value[3][1])));
            }
          },
          0xa433: 'LensMake',
          0xa434: 'LensModel',
          0xa435: 'LensSerialNumber',
          0xa460: {
            name: 'CompositeImage',
            description: function description(value) {
              return {
                1: 'Not a Composite Image',
                2: 'General Composite Image',
                3: 'Composite Image Captured While Shooting'
              }[value] || 'Unknown';
            }
          },
          0xa461: 'SourceImageNumberOfCompositeImage',
          0xa462: 'SourceExposureTimesOfCompositeImage',
          0xa500: 'Gamma',
          0xea1c: 'Padding',
          0xea1d: 'OffsetSchema',
          0xfde8: 'OwnerName',
          0xfde9: 'SerialNumber',
          0xfdea: 'Lens',
          0xfe4c: 'RawFile',
          0xfe4d: 'Converter',
          0xfe4e: 'WhiteBalance',
          0xfe51: 'Exposure',
          0xfe52: 'Shadows',
          0xfe53: 'Brightness',
          0xfe54: 'Contrast',
          0xfe55: 'Saturation',
          0xfe56: 'Sharpness',
          0xfe57: 'Smoothness',
          0xfe58: 'MoireFilter'
        };
        /***/
      },

      /***/
      "./src/tag-names-gps-ifd.js":
      /*!**********************************!*\
        !*** ./src/tag-names-gps-ifd.js ***!
        \**********************************/

      /*! exports provided: default */

      /***/
      function srcTagNamesGpsIfdJs(module, __webpack_exports__, __webpack_require__) {
        "use strict";

        __webpack_require__.r(__webpack_exports__);
        /* harmony import */


        var _tag_names_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        /*! ./tag-names-utils.js */
        "./src/tag-names-utils.js");

        function _slicedToArray(arr, i) {
          return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
        }

        function _nonIterableRest() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }

        function _unsupportedIterableToArray(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(n);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
        }

        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length) len = arr.length;

          for (var i = 0, arr2 = new Array(len); i < len; i++) {
            arr2[i] = arr[i];
          }

          return arr2;
        }

        function _iterableToArrayLimit(arr, i) {
          if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = undefined;

          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);

              if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"] != null) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }

          return _arr;
        }

        function _arrayWithHoles(arr) {
          if (Array.isArray(arr)) return arr;
        }
        /* This Source Code Form is subject to the terms of the Mozilla Public
         * License, v. 2.0. If a copy of the MPL was not distributed with this
         * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

        /* harmony default export */


        __webpack_exports__["default"] = {
          0x0000: {
            'name': 'GPSVersionID',
            'description': function description(value) {
              if (value[0] === 2 && value[1] === 2 && value[2] === 0 && value[3] === 0) {
                return 'Version 2.2';
              }

              return 'Unknown';
            }
          },
          0x0001: {
            'name': 'GPSLatitudeRef',
            'description': function description(value) {
              var ref = value.join('');

              if (ref === 'N') {
                return 'North latitude';
              } else if (ref === 'S') {
                return 'South latitude';
              }

              return 'Unknown';
            }
          },
          0x0002: {
            'name': 'GPSLatitude',
            'description': _tag_names_utils_js__WEBPACK_IMPORTED_MODULE_0__["getCalculatedGpsValue"]
          },
          0x0003: {
            'name': 'GPSLongitudeRef',
            'description': function description(value) {
              var ref = value.join('');

              if (ref === 'E') {
                return 'East longitude';
              } else if (ref === 'W') {
                return 'West longitude';
              }

              return 'Unknown';
            }
          },
          0x0004: {
            'name': 'GPSLongitude',
            'description': _tag_names_utils_js__WEBPACK_IMPORTED_MODULE_0__["getCalculatedGpsValue"]
          },
          0x0005: {
            'name': 'GPSAltitudeRef',
            'description': function description(value) {
              if (value === 0) {
                return 'Sea level';
              } else if (value === 1) {
                return 'Sea level reference (negative value)';
              }

              return 'Unknown';
            }
          },
          0x0006: {
            'name': 'GPSAltitude',
            'description': function description(value) {
              return value[0] / value[1] + ' m';
            }
          },
          0x0007: {
            'name': 'GPSTimeStamp',
            'description': function description(values) {
              return values.map(function (_ref) {
                var _ref2 = _slicedToArray(_ref, 2),
                    numerator = _ref2[0],
                    denominator = _ref2[1];

                var num = numerator / denominator;

                if (/^\d(\.|$)/.test("".concat(num))) {
                  return "0".concat(num);
                }

                return num;
              }).join(':');
            }
          },
          0x0008: 'GPSSatellites',
          0x0009: {
            'name': 'GPSStatus',
            'description': function description(value) {
              var status = value.join('');

              if (status === 'A') {
                return 'Measurement in progress';
              } else if (status === 'V') {
                return 'Measurement Interoperability';
              }

              return 'Unknown';
            }
          },
          0x000a: {
            'name': 'GPSMeasureMode',
            'description': function description(value) {
              var mode = value.join('');

              if (mode === '2') {
                return '2-dimensional measurement';
              } else if (mode === '3') {
                return '3-dimensional measurement';
              }

              return 'Unknown';
            }
          },
          0x000b: 'GPSDOP',
          0x000c: {
            'name': 'GPSSpeedRef',
            'description': function description(value) {
              var ref = value.join('');

              if (ref === 'K') {
                return 'Kilometers per hour';
              } else if (ref === 'M') {
                return 'Miles per hour';
              } else if (ref === 'N') {
                return 'Knots';
              }

              return 'Unknown';
            }
          },
          0x000d: 'GPSSpeed',
          0x000e: {
            'name': 'GPSTrackRef',
            'description': function description(value) {
              var ref = value.join('');

              if (ref === 'T') {
                return 'True direction';
              } else if (ref === 'M') {
                return 'Magnetic direction';
              }

              return 'Unknown';
            }
          },
          0x000f: 'GPSTrack',
          0x0010: {
            'name': 'GPSImgDirectionRef',
            'description': function description(value) {
              var ref = value.join('');

              if (ref === 'T') {
                return 'True direction';
              } else if (ref === 'M') {
                return 'Magnetic direction';
              }

              return 'Unknown';
            }
          },
          0x0011: 'GPSImgDirection',
          0x0012: 'GPSMapDatum',
          0x0013: {
            'name': 'GPSDestLatitudeRef',
            'description': function description(value) {
              var ref = value.join('');

              if (ref === 'N') {
                return 'North latitude';
              } else if (ref === 'S') {
                return 'South latitude';
              }

              return 'Unknown';
            }
          },
          0x0014: {
            'name': 'GPSDestLatitude',
            'description': function description(value) {
              return value[0][0] / value[0][1] + value[1][0] / value[1][1] / 60 + value[2][0] / value[2][1] / 3600;
            }
          },
          0x0015: {
            'name': 'GPSDestLongitudeRef',
            'description': function description(value) {
              var ref = value.join('');

              if (ref === 'E') {
                return 'East longitude';
              } else if (ref === 'W') {
                return 'West longitude';
              }

              return 'Unknown';
            }
          },
          0x0016: {
            'name': 'GPSDestLongitude',
            'description': function description(value) {
              return value[0][0] / value[0][1] + value[1][0] / value[1][1] / 60 + value[2][0] / value[2][1] / 3600;
            }
          },
          0x0017: {
            'name': 'GPSDestBearingRef',
            'description': function description(value) {
              var ref = value.join('');

              if (ref === 'T') {
                return 'True direction';
              } else if (ref === 'M') {
                return 'Magnetic direction';
              }

              return 'Unknown';
            }
          },
          0x0018: 'GPSDestBearing',
          0x0019: {
            'name': 'GPSDestDistanceRef',
            'description': function description(value) {
              var ref = value.join('');

              if (ref === 'K') {
                return 'Kilometers';
              } else if (ref === 'M') {
                return 'Miles';
              } else if (ref === 'N') {
                return 'Knots';
              }

              return 'Unknown';
            }
          },
          0x001a: 'GPSDestDistance',
          0x001b: {
            'name': 'GPSProcessingMethod',
            'description': _tag_names_utils_js__WEBPACK_IMPORTED_MODULE_0__["getEncodedString"]
          },
          0x001c: {
            'name': 'GPSAreaInformation',
            'description': _tag_names_utils_js__WEBPACK_IMPORTED_MODULE_0__["getEncodedString"]
          },
          0x001d: 'GPSDateStamp',
          0x001e: {
            'name': 'GPSDifferential',
            'description': function description(value) {
              if (value === 0) {
                return 'Measurement without differential correction';
              } else if (value === 1) {
                return 'Differential correction applied';
              }

              return 'Unknown';
            }
          },
          0x001f: 'GPSHPositioningError'
        };
        /***/
      },

      /***/
      "./src/tag-names-interoperability-ifd.js":
      /*!***********************************************!*\
        !*** ./src/tag-names-interoperability-ifd.js ***!
        \***********************************************/

      /*! exports provided: default */

      /***/
      function srcTagNamesInteroperabilityIfdJs(module, __webpack_exports__, __webpack_require__) {
        "use strict";

        __webpack_require__.r(__webpack_exports__);
        /* harmony import */


        var _tag_names_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        /*! ./tag-names-utils.js */
        "./src/tag-names-utils.js");
        /* This Source Code Form is subject to the terms of the Mozilla Public
         * License, v. 2.0. If a copy of the MPL was not distributed with this
         * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

        /* harmony default export */


        __webpack_exports__["default"] = {
          0x0001: 'InteroperabilityIndex',
          0x0002: {
            name: 'InteroperabilityVersion',
            description: function description(value) {
              return Object(_tag_names_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringValue"])(value);
            }
          },
          0x1000: 'RelatedImageFileFormat',
          0x1001: 'RelatedImageWidth',
          0x1002: 'RelatedImageHeight'
        };
        /***/
      },

      /***/
      "./src/tag-names-utils.js":
      /*!********************************!*\
        !*** ./src/tag-names-utils.js ***!
        \********************************/

      /*! exports provided: getStringValue, getEncodedString, getCalculatedGpsValue */

      /***/
      function srcTagNamesUtilsJs(module, __webpack_exports__, __webpack_require__) {
        "use strict";

        __webpack_require__.r(__webpack_exports__);
        /* harmony export (binding) */


        __webpack_require__.d(__webpack_exports__, "getStringValue", function () {
          return getStringValue;
        });
        /* harmony export (binding) */


        __webpack_require__.d(__webpack_exports__, "getEncodedString", function () {
          return getEncodedString;
        });
        /* harmony export (binding) */


        __webpack_require__.d(__webpack_exports__, "getCalculatedGpsValue", function () {
          return getCalculatedGpsValue;
        });
        /* This Source Code Form is subject to the terms of the Mozilla Public
         * License, v. 2.0. If a copy of the MPL was not distributed with this
         * file, You can obtain one at https://mozilla.org/MPL/2.0/. */


        function getStringValue(value) {
          return value.map(function (charCode) {
            return String.fromCharCode(charCode);
          }).join('');
        }

        function getEncodedString(value) {
          if (value.length >= 8) {
            var encoding = getStringValue(value.slice(0, 8));

            if (encoding === 'ASCII\x00\x00\x00') {
              return getStringValue(value.slice(8));
            } else if (encoding === 'JIS\x00\x00\x00\x00\x00') {
              return '[JIS encoded text]';
            } else if (encoding === 'UNICODE\x00') {
              return '[Unicode encoded text]';
            } else if (encoding === '\x00\x00\x00\x00\x00\x00\x00\x00') {
              return '[Undefined encoding]';
            }
          }

          return 'Undefined';
        }

        function getCalculatedGpsValue(value) {
          return value[0][0] / value[0][1] + value[1][0] / value[1][1] / 60 + value[2][0] / value[2][1] / 3600;
        }
        /***/

      },

      /***/
      "./src/tag-names.js":
      /*!**************************!*\
        !*** ./src/tag-names.js ***!
        \**************************/

      /*! exports provided: default */

      /***/
      function srcTagNamesJs(module, __webpack_exports__, __webpack_require__) {
        "use strict";

        __webpack_require__.r(__webpack_exports__);
        /* harmony import */


        var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        /*! ./utils.js */
        "./src/utils.js");
        /* harmony import */


        var _tag_names_0th_ifd_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
        /*! ./tag-names-0th-ifd.js */
        "./src/tag-names-0th-ifd.js");
        /* harmony import */


        var _tag_names_exif_ifd_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
        /*! ./tag-names-exif-ifd.js */
        "./src/tag-names-exif-ifd.js");
        /* harmony import */


        var _tag_names_gps_ifd_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
        /*! ./tag-names-gps-ifd.js */
        "./src/tag-names-gps-ifd.js");
        /* harmony import */


        var _tag_names_interoperability_ifd_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
        /*! ./tag-names-interoperability-ifd.js */
        "./src/tag-names-interoperability-ifd.js");
        /* This Source Code Form is subject to the terms of the Mozilla Public
         * License, v. 2.0. If a copy of the MPL was not distributed with this
         * file, You can obtain one at https://mozilla.org/MPL/2.0/. */


        var tagNames0thExifIfds = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["objectAssign"])({}, _tag_names_0th_ifd_js__WEBPACK_IMPORTED_MODULE_1__["default"], _tag_names_exif_ifd_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
        /* harmony default export */

        __webpack_exports__["default"] = {
          '0th': tagNames0thExifIfds,
          'exif': tagNames0thExifIfds,
          'gps': _tag_names_gps_ifd_js__WEBPACK_IMPORTED_MODULE_3__["default"],
          'interoperability': _tag_names_interoperability_ifd_js__WEBPACK_IMPORTED_MODULE_4__["default"]
        };
        /***/
      },

      /***/
      "./src/tags.js":
      /*!*********************!*\
        !*** ./src/tags.js ***!
        \*********************/

      /*! exports provided: default */

      /***/
      function srcTagsJs(module, __webpack_exports__, __webpack_require__) {
        "use strict";

        __webpack_require__.r(__webpack_exports__);
        /* harmony import */


        var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        /*! ./constants.js */
        "./src/constants.js");
        /* harmony import */


        var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
        /*! ./utils.js */
        "./src/utils.js");
        /* harmony import */


        var _byte_order_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
        /*! ./byte-order.js */
        "./src/byte-order.js");
        /* harmony import */


        var _types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
        /*! ./types.js */
        "./src/types.js");
        /* harmony import */


        var _tag_names_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
        /*! ./tag-names.js */
        "./src/tag-names.js");
        /* This Source Code Form is subject to the terms of the Mozilla Public
         * License, v. 2.0. If a copy of the MPL was not distributed with this
         * file, You can obtain one at https://mozilla.org/MPL/2.0/. */


        var EXIF_IFD_POINTER_KEY = 'Exif IFD Pointer';
        var GPS_INFO_IFD_POINTER_KEY = 'GPS Info IFD Pointer';
        var INTEROPERABILITY_IFD_POINTER_KEY = 'Interoperability IFD Pointer';
        var getTagValueAt = {
          1: _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].getByteAt,
          2: _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].getAsciiAt,
          3: _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].getShortAt,
          4: _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].getLongAt,
          5: _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].getRationalAt,
          7: _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].getUndefinedAt,
          9: _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].getSlongAt,
          10: _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].getSrationalAt,
          13: _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].getIfdPointerAt
        };
        /* harmony default export */

        __webpack_exports__["default"] = {
          read: read
        };

        function read(dataView, tiffHeaderOffset) {
          var byteOrder = _byte_order_js__WEBPACK_IMPORTED_MODULE_2__["default"].getByteOrder(dataView, tiffHeaderOffset);

          var tags = read0thIfd(dataView, tiffHeaderOffset, byteOrder);
          tags = readExifIfd(tags, dataView, tiffHeaderOffset, byteOrder);
          tags = readGpsIfd(tags, dataView, tiffHeaderOffset, byteOrder);
          tags = readInteroperabilityIfd(tags, dataView, tiffHeaderOffset, byteOrder);
          return tags;
        }

        function read0thIfd(dataView, tiffHeaderOffset, byteOrder) {
          return readIfd(dataView, '0th', tiffHeaderOffset, get0thIfdOffset(dataView, tiffHeaderOffset, byteOrder), byteOrder);
        }

        function get0thIfdOffset(dataView, tiffHeaderOffset, byteOrder) {
          return tiffHeaderOffset + _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].getLongAt(dataView, tiffHeaderOffset + 4, byteOrder);
        }

        function readExifIfd(tags, dataView, tiffHeaderOffset, byteOrder) {
          if (tags[EXIF_IFD_POINTER_KEY] !== undefined) {
            return Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__["objectAssign"])(tags, readIfd(dataView, 'exif', tiffHeaderOffset, tiffHeaderOffset + tags[EXIF_IFD_POINTER_KEY].value, byteOrder));
          }

          return tags;
        }

        function readGpsIfd(tags, dataView, tiffHeaderOffset, byteOrder) {
          if (tags[GPS_INFO_IFD_POINTER_KEY] !== undefined) {
            return Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__["objectAssign"])(tags, readIfd(dataView, 'gps', tiffHeaderOffset, tiffHeaderOffset + tags[GPS_INFO_IFD_POINTER_KEY].value, byteOrder));
          }

          return tags;
        }

        function readInteroperabilityIfd(tags, dataView, tiffHeaderOffset, byteOrder) {
          if (tags[INTEROPERABILITY_IFD_POINTER_KEY] !== undefined) {
            return Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__["objectAssign"])(tags, readIfd(dataView, 'interoperability', tiffHeaderOffset, tiffHeaderOffset + tags[INTEROPERABILITY_IFD_POINTER_KEY].value, byteOrder));
          }

          return tags;
        }

        function readIfd(dataView, ifdType, tiffHeaderOffset, offset, byteOrder) {
          var FIELD_COUNT_SIZE = _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].getTypeSize('SHORT');

          var FIELD_SIZE = 12;
          var tags = {};
          var numberOfFields = getNumberOfFields(dataView, offset, byteOrder);
          offset += FIELD_COUNT_SIZE;

          for (var fieldIndex = 0; fieldIndex < numberOfFields; fieldIndex++) {
            if (offset + FIELD_SIZE > dataView.byteLength) {
              break;
            }

            var tag = readTag(dataView, ifdType, tiffHeaderOffset, offset, byteOrder);

            if (tag !== undefined) {
              tags[tag.name] = {
                'id': tag.id,
                'value': tag.value,
                'description': tag.description
              };
            }

            offset += FIELD_SIZE;
          }

          if (_constants_js__WEBPACK_IMPORTED_MODULE_0__["default"].USE_THUMBNAIL && offset < dataView.byteLength - _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].getTypeSize('LONG')) {
            var nextIfdOffset = _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].getLongAt(dataView, offset, byteOrder);

            if (nextIfdOffset !== 0) {
              tags['Thumbnail'] = readIfd(dataView, ifdType, tiffHeaderOffset, tiffHeaderOffset + nextIfdOffset, byteOrder);
            }
          }

          return tags;
        }

        function getNumberOfFields(dataView, offset, byteOrder) {
          if (offset + _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].getTypeSize('SHORT') <= dataView.byteLength) {
            return _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].getShortAt(dataView, offset, byteOrder);
          }

          return 0;
        }

        function readTag(dataView, ifdType, tiffHeaderOffset, offset, byteOrder) {
          var TAG_CODE_IPTC_NAA = 0x83bb;

          var TAG_TYPE_OFFSET = _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].getTypeSize('SHORT');

          var TAG_COUNT_OFFSET = TAG_TYPE_OFFSET + _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].getTypeSize('SHORT');

          var TAG_VALUE_OFFSET = TAG_COUNT_OFFSET + _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].getTypeSize('LONG');

          var tagCode = _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].getShortAt(dataView, offset, byteOrder);

          var tagType = _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].getShortAt(dataView, offset + TAG_TYPE_OFFSET, byteOrder);

          var tagCount = _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].getLongAt(dataView, offset + TAG_COUNT_OFFSET, byteOrder);

          var tagValue;

          if (_types_js__WEBPACK_IMPORTED_MODULE_3__["default"].typeSizes[tagType] === undefined) {
            return undefined;
          }

          if (tagValueFitsInOffsetSlot(tagType, tagCount)) {
            tagValue = getTagValue(dataView, offset + TAG_VALUE_OFFSET, tagType, tagCount, byteOrder);
          } else {
            var tagValueOffset = _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].getLongAt(dataView, offset + TAG_VALUE_OFFSET, byteOrder);

            if (tagValueFitsInDataView(dataView, tiffHeaderOffset, tagValueOffset, tagType, tagCount)) {
              var forceByteType = tagCode === TAG_CODE_IPTC_NAA;
              tagValue = getTagValue(dataView, tiffHeaderOffset + tagValueOffset, tagType, tagCount, byteOrder, forceByteType);
            } else {
              tagValue = '<faulty value>';
            }
          }

          if (tagType === _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].tagTypes['ASCII']) {
            tagValue = splitNullSeparatedAsciiString(tagValue);
            tagValue = decodeAsciiValue(tagValue);
          }

          var tagName = "undefined-".concat(tagCode);
          var tagDescription = tagValue;

          if (_tag_names_js__WEBPACK_IMPORTED_MODULE_4__["default"][ifdType][tagCode] !== undefined) {
            if (_tag_names_js__WEBPACK_IMPORTED_MODULE_4__["default"][ifdType][tagCode]['name'] !== undefined && _tag_names_js__WEBPACK_IMPORTED_MODULE_4__["default"][ifdType][tagCode]['description'] !== undefined) {
              tagName = _tag_names_js__WEBPACK_IMPORTED_MODULE_4__["default"][ifdType][tagCode]['name'];

              try {
                tagDescription = _tag_names_js__WEBPACK_IMPORTED_MODULE_4__["default"][ifdType][tagCode]['description'](tagValue);
              } catch (error) {
                tagDescription = getDescriptionFromTagValue(tagValue);
              }
            } else if (tagType === _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].tagTypes['RATIONAL'] || tagType === _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].tagTypes['SRATIONAL']) {
              tagName = _tag_names_js__WEBPACK_IMPORTED_MODULE_4__["default"][ifdType][tagCode];
              tagDescription = '' + tagValue[0] / tagValue[1];
            } else {
              tagName = _tag_names_js__WEBPACK_IMPORTED_MODULE_4__["default"][ifdType][tagCode];
              tagDescription = getDescriptionFromTagValue(tagValue);
            }
          }

          return {
            id: tagCode,
            name: tagName,
            value: tagValue,
            description: tagDescription
          };
        }

        function tagValueFitsInOffsetSlot(tagType, tagCount) {
          return _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].typeSizes[tagType] * tagCount <= _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].getTypeSize('LONG');
        }

        function getTagValue(dataView, offset, type, count, byteOrder) {
          var forceByteType = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
          var value = [];

          if (forceByteType) {
            count = count * _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].typeSizes[type];
            type = _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].tagTypes['BYTE'];
          }

          for (var valueIndex = 0; valueIndex < count; valueIndex++) {
            value.push(getTagValueAt[type](dataView, offset, byteOrder));
            offset += _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].typeSizes[type];
          }

          if (type === _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].tagTypes['ASCII']) {
            value = _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].getAsciiValue(value);
          } else if (value.length === 1) {
            value = value[0];
          }

          return value;
        }

        function tagValueFitsInDataView(dataView, tiffHeaderOffset, tagValueOffset, tagType, tagCount) {
          return tiffHeaderOffset + tagValueOffset + _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].typeSizes[tagType] * tagCount <= dataView.byteLength;
        }

        function splitNullSeparatedAsciiString(string) {
          var tagValue = [];
          var i = 0;

          for (var j = 0; j < string.length; j++) {
            if (string[j] === '\x00') {
              i++;
              continue;
            }

            if (tagValue[i] === undefined) {
              tagValue[i] = '';
            }

            tagValue[i] += string[j];
          }

          return tagValue;
        }

        function decodeAsciiValue(asciiValue) {
          try {
            return asciiValue.map(function (value) {
              return decodeURIComponent(escape(value));
            });
          } catch (error) {
            return asciiValue;
          }
        }

        function getDescriptionFromTagValue(tagValue) {
          if (tagValue instanceof Array) {
            return tagValue.join(', ');
          }

          return tagValue;
        }
        /***/

      },

      /***/
      "./src/text-decoder.js":
      /*!*****************************!*\
        !*** ./src/text-decoder.js ***!
        \*****************************/

      /*! exports provided: default */

      /***/
      function srcTextDecoderJs(module, __webpack_exports__, __webpack_require__) {
        "use strict";

        __webpack_require__.r(__webpack_exports__);
        /* This Source Code Form is subject to the terms of the Mozilla Public
         * License, v. 2.0. If a copy of the MPL was not distributed with this
         * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

        /* harmony default export */


        __webpack_exports__["default"] = {
          get: get
        };

        function get() {
          if (typeof TextDecoder !== 'undefined') {
            return TextDecoder;
          }

          return undefined;
        }
        /***/

      },

      /***/
      "./src/thumbnail.js":
      /*!**************************!*\
        !*** ./src/thumbnail.js ***!
        \**************************/

      /*! exports provided: default */

      /***/
      function srcThumbnailJs(module, __webpack_exports__, __webpack_require__) {
        "use strict";

        __webpack_require__.r(__webpack_exports__);
        /* harmony import */


        var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        /*! ./utils.js */
        "./src/utils.js");

        function _typeof(obj) {
          "@babel/helpers - typeof";

          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
          }

          return _typeof(obj);
        }
        /* This Source Code Form is subject to the terms of the Mozilla Public
         * License, v. 2.0. If a copy of the MPL was not distributed with this
         * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
        // https://exiftool.org/TagNames/EXIF.html#Compression


        var COMPRESSION_JPEG = [6, 7, 99];
        /* harmony default export */

        __webpack_exports__["default"] = {
          get: get
        };

        function get(dataView, thumbnailTags, tiffHeaderOffset) {
          if (hasJpegThumbnail(thumbnailTags)) {
            thumbnailTags.type = 'image/jpeg';
            var offset = tiffHeaderOffset + thumbnailTags.JPEGInterchangeFormat.value;
            thumbnailTags.image = dataView.buffer.slice(offset, offset + thumbnailTags.JPEGInterchangeFormatLength.value);
            Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["deferInit"])(thumbnailTags, 'base64', function () {
              return getBase64Image(this.image);
            });
          } // There is a small possibility of thumbnails in TIFF format but they are
          // not stored as a self-contained image file and would be much more
          // difficult to extract.
          // https://exiftool.org/forum/index.php?topic=3273.msg14778#msg14778


          return thumbnailTags;
        }

        function hasJpegThumbnail(tags) {
          return tags && (tags.Compression === undefined || COMPRESSION_JPEG.includes(tags.Compression.value)) && tags.JPEGInterchangeFormat && tags.JPEGInterchangeFormat.value && tags.JPEGInterchangeFormatLength && tags.JPEGInterchangeFormatLength.value;
        }

        function getBase64Image(image) {
          if (typeof btoa !== 'undefined') {
            // IE11- does not implement reduce on the Uint8Array prototype.
            return btoa(Array.prototype.reduce.call(new Uint8Array(image), function (data, _byte) {
              return data + String.fromCharCode(_byte);
            }, ''));
          }

          if (typeof Buffer === 'undefined') {
            return undefined;
          }

          if (_typeof(Buffer.from) !== undefined) {
            // eslint-disable-line no-undef
            return Buffer.from(image).toString('base64'); // eslint-disable-line no-undef
          }

          return new Buffer(image).toString('base64'); // eslint-disable-line no-undef
        }
        /***/

      },

      /***/
      "./src/types.js":
      /*!**********************!*\
        !*** ./src/types.js ***!
        \**********************/

      /*! exports provided: default */

      /***/
      function srcTypesJs(module, __webpack_exports__, __webpack_require__) {
        "use strict";

        __webpack_require__.r(__webpack_exports__);
        /* harmony import */


        var _byte_order_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        /*! ./byte-order.js */
        "./src/byte-order.js");
        /* This Source Code Form is subject to the terms of the Mozilla Public
         * License, v. 2.0. If a copy of the MPL was not distributed with this
         * file, You can obtain one at https://mozilla.org/MPL/2.0/. */


        var typeSizes = {
          1: 1,
          // BYTE
          2: 1,
          // ASCII
          3: 2,
          // SHORT
          4: 4,
          // LONG
          5: 8,
          // RATIONAL
          7: 1,
          // UNDEFINED
          9: 4,
          // SLONG
          10: 8,
          // SRATIONAL
          13: 4 // IFD

        };
        var tagTypes = {
          'BYTE': 1,
          'ASCII': 2,
          'SHORT': 3,
          'LONG': 4,
          'RATIONAL': 5,
          'UNDEFINED': 7,
          'SLONG': 9,
          'SRATIONAL': 10,
          'IFD': 13
        };
        /* harmony default export */

        __webpack_exports__["default"] = {
          getAsciiValue: getAsciiValue,
          getByteAt: getByteAt,
          getAsciiAt: getAsciiAt,
          getShortAt: getShortAt,
          getLongAt: getLongAt,
          getRationalAt: getRationalAt,
          getUndefinedAt: getUndefinedAt,
          getSlongAt: getSlongAt,
          getSrationalAt: getSrationalAt,
          getIfdPointerAt: getIfdPointerAt,
          typeSizes: typeSizes,
          tagTypes: tagTypes,
          getTypeSize: getTypeSize
        };

        function getAsciiValue(charArray) {
          return charArray.map(function (charCode) {
            return String.fromCharCode(charCode);
          });
        }

        function getByteAt(dataView, offset) {
          return dataView.getUint8(offset);
        }

        function getAsciiAt(dataView, offset) {
          return dataView.getUint8(offset);
        }

        function getShortAt(dataView, offset, byteOrder) {
          return dataView.getUint16(offset, byteOrder === _byte_order_js__WEBPACK_IMPORTED_MODULE_0__["default"].LITTLE_ENDIAN);
        }

        function getLongAt(dataView, offset, byteOrder) {
          return dataView.getUint32(offset, byteOrder === _byte_order_js__WEBPACK_IMPORTED_MODULE_0__["default"].LITTLE_ENDIAN);
        }

        function getRationalAt(dataView, offset, byteOrder) {
          return [getLongAt(dataView, offset, byteOrder), getLongAt(dataView, offset + 4, byteOrder)];
        }

        function getUndefinedAt(dataView, offset) {
          return getByteAt(dataView, offset);
        }

        function getSlongAt(dataView, offset, byteOrder) {
          return dataView.getInt32(offset, byteOrder === _byte_order_js__WEBPACK_IMPORTED_MODULE_0__["default"].LITTLE_ENDIAN);
        }

        function getSrationalAt(dataView, offset, byteOrder) {
          return [getSlongAt(dataView, offset, byteOrder), getSlongAt(dataView, offset + 4, byteOrder)];
        }

        function getIfdPointerAt(dataView, offset, byteOrder) {
          return getLongAt(dataView, offset, byteOrder);
        }

        function getTypeSize(typeName) {
          if (tagTypes[typeName] === undefined) {
            throw new Error('No such type found.');
          }

          return typeSizes[tagTypes[typeName]];
        }
        /***/

      },

      /***/
      "./src/utils.js":
      /*!**********************!*\
        !*** ./src/utils.js ***!
        \**********************/

      /*! exports provided: getStringFromDataView, getUnicodeStringFromDataView, getStringValueFromArray, getCharacterArray, objectAssign, deferInit */

      /***/
      function srcUtilsJs(module, __webpack_exports__, __webpack_require__) {
        "use strict";

        __webpack_require__.r(__webpack_exports__);
        /* harmony export (binding) */


        __webpack_require__.d(__webpack_exports__, "getStringFromDataView", function () {
          return getStringFromDataView;
        });
        /* harmony export (binding) */


        __webpack_require__.d(__webpack_exports__, "getUnicodeStringFromDataView", function () {
          return getUnicodeStringFromDataView;
        });
        /* harmony export (binding) */


        __webpack_require__.d(__webpack_exports__, "getStringValueFromArray", function () {
          return getStringValueFromArray;
        });
        /* harmony export (binding) */


        __webpack_require__.d(__webpack_exports__, "getCharacterArray", function () {
          return getCharacterArray;
        });
        /* harmony export (binding) */


        __webpack_require__.d(__webpack_exports__, "objectAssign", function () {
          return objectAssign;
        });
        /* harmony export (binding) */


        __webpack_require__.d(__webpack_exports__, "deferInit", function () {
          return deferInit;
        });
        /* This Source Code Form is subject to the terms of the Mozilla Public
         * License, v. 2.0. If a copy of the MPL was not distributed with this
         * file, You can obtain one at https://mozilla.org/MPL/2.0/. */


        function getStringFromDataView(dataView, offset, length) {
          var chars = [];

          for (var i = 0; i < length && offset + i < dataView.byteLength; i++) {
            chars.push(dataView.getUint8(offset + i));
          }

          return getStringValueFromArray(chars);
        }

        function getUnicodeStringFromDataView(dataView, offset, length) {
          var chars = [];

          for (var i = 0; i < length && offset + i < dataView.byteLength; i += 2) {
            chars.push(dataView.getUint16(offset + i));
          }

          return getStringValueFromArray(chars);
        }

        function getStringValueFromArray(charArray) {
          return charArray.map(function (charCode) {
            return String.fromCharCode(charCode);
          }).join('');
        }

        function getCharacterArray(string) {
          return string.split('').map(function (character) {
            return character.charCodeAt(0);
          });
        }

        function objectAssign() {
          for (var i = 1; i < arguments.length; i++) {
            for (var property in arguments[i]) {
              arguments[0][property] = arguments[i][property];
            }
          }

          return arguments[0];
        }

        function deferInit(object, key, initializer) {
          var initialized = false;
          Object.defineProperty(object, key, {
            get: function get() {
              if (!initialized) {
                initialized = true;
                Object.defineProperty(object, key, {
                  configurable: true,
                  enumerable: true,
                  value: initializer.apply(object),
                  writable: true
                });
              }

              return object[key];
            },
            configurable: true,
            enumerable: true
          });
        }
        /***/

      },

      /***/
      "./src/xmp-tag-names.js":
      /*!******************************!*\
        !*** ./src/xmp-tag-names.js ***!
        \******************************/

      /*! exports provided: default */

      /***/
      function srcXmpTagNamesJs(module, __webpack_exports__, __webpack_require__) {
        "use strict";

        __webpack_require__.r(__webpack_exports__);

        function _slicedToArray(arr, i) {
          return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
        }

        function _nonIterableRest() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }

        function _unsupportedIterableToArray(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(n);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
        }

        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length) len = arr.length;

          for (var i = 0, arr2 = new Array(len); i < len; i++) {
            arr2[i] = arr[i];
          }

          return arr2;
        }

        function _iterableToArrayLimit(arr, i) {
          if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = undefined;

          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);

              if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"] != null) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }

          return _arr;
        }

        function _arrayWithHoles(arr) {
          if (Array.isArray(arr)) return arr;
        }
        /* This Source Code Form is subject to the terms of the Mozilla Public
         * License, v. 2.0. If a copy of the MPL was not distributed with this
         * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

        /* harmony default export */


        __webpack_exports__["default"] = {
          'tiff:Orientation': function tiffOrientation(value) {
            if (value === '1') {
              return 'Horizontal (normal)';
            }

            if (value === '2') {
              return 'Mirror horizontal';
            }

            if (value === '3') {
              return 'Rotate 180';
            }

            if (value === '4') {
              return 'Mirror vertical';
            }

            if (value === '5') {
              return 'Mirror horizontal and rotate 270 CW';
            }

            if (value === '6') {
              return 'Rotate 90 CW';
            }

            if (value === '7') {
              return 'Mirror horizontal and rotate 90 CW';
            }

            if (value === '8') {
              return 'Rotate 270 CW';
            }

            return value;
          },
          'exif:GPSLatitude': calculateGPSValue,
          'exif:GPSLongitude': calculateGPSValue
        };

        function calculateGPSValue(value) {
          var _value$split = value.split(','),
              _value$split2 = _slicedToArray(_value$split, 2),
              degreesString = _value$split2[0],
              minutesString = _value$split2[1];

          if (degreesString !== undefined && minutesString !== undefined) {
            var degrees = parseFloat(degreesString);
            var minutes = parseFloat(minutesString);
            var ref = minutesString.charAt(minutesString.length - 1);

            if (!Number.isNaN(degrees) && !Number.isNaN(minutes)) {
              return '' + (degrees + minutes / 60) + ref;
            }
          }

          return value;
        }
        /***/

      },

      /***/
      "./src/xmp-tags.js":
      /*!*************************!*\
        !*** ./src/xmp-tags.js ***!
        \*************************/

      /*! exports provided: default */

      /***/
      function srcXmpTagsJs(module, __webpack_exports__, __webpack_require__) {
        "use strict";

        __webpack_require__.r(__webpack_exports__);
        /* harmony import */


        var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        /*! ./utils.js */
        "./src/utils.js");
        /* harmony import */


        var _xmp_tag_names_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
        /*! ./xmp-tag-names.js */
        "./src/xmp-tag-names.js");
        /* harmony import */


        var _dom_parser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
        /*! ./dom-parser.js */
        "./src/dom-parser.js");

        function _typeof(obj) {
          "@babel/helpers - typeof";

          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
          }

          return _typeof(obj);
        }
        /* This Source Code Form is subject to the terms of the Mozilla Public
         * License, v. 2.0. If a copy of the MPL was not distributed with this
         * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

        /* harmony default export */


        __webpack_exports__["default"] = {
          read: read
        };

        function read(dataView, chunks) {
          if (typeof dataView === 'string') {
            return readTags({}, dataView);
          }

          return extractCompleteChunks(dataView, chunks).reduce(readTags, {});
        } // The first chunk is always the regular XMP document. Then there is something
        // called extended XMP. The extended XMP is also a single XMP document but it
        // can be divided into multiple chunks that need to be combined into one.


        function extractCompleteChunks(dataView, chunks) {
          if (chunks.length === 0) {
            return [];
          }

          var completeChunks = [combineChunks(dataView, chunks.slice(0, 1))];

          if (chunks.length > 1) {
            completeChunks.push(combineChunks(dataView, chunks.slice(1)));
          }

          return completeChunks;
        }

        function combineChunks(dataView, chunks) {
          var totalLength = chunks.reduce(function (size, chunk) {
            return size + chunk.length;
          }, 0);
          var combinedChunks = new Uint8Array(totalLength);
          var offset = 0;

          for (var i = 0; i < chunks.length; i++) {
            var chunk = chunks[i];
            var slice = dataView.buffer.slice(chunk.dataOffset, chunk.dataOffset + chunk.length);
            combinedChunks.set(new Uint8Array(slice), offset);
            offset += chunk.length;
          }

          return new DataView(combinedChunks.buffer);
        }

        function readTags(tags, chunkDataView) {
          try {
            var doc = getDocument(chunkDataView);
            var rdf = getRDF(doc);
            return Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["objectAssign"])(tags, parseXMPObject(convertToObject(rdf, true)));
          } catch (error) {
            return tags;
          }
        }

        function getDocument(chunkDataView) {
          var Parser = _dom_parser_js__WEBPACK_IMPORTED_MODULE_2__["default"].get();

          if (!Parser) {
            console.warn('Warning: DOMParser is not available. It is needed to be able to parse XMP tags.'); // eslint-disable-line no-console

            throw new Error();
          }

          var domParser = new Parser();
          var xmlString = typeof chunkDataView === 'string' ? chunkDataView : Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["getStringFromDataView"])(chunkDataView, 0, chunkDataView.byteLength);
          var doc = domParser.parseFromString(trimXmlSource(xmlString), 'application/xml');

          if (doc.documentElement.nodeName === 'parsererror') {
            throw new Error(doc.documentElement.textContent);
          }

          return doc;
        }

        function trimXmlSource(xmlSource) {
          return xmlSource.replace(/^.+(<\?xpacket begin)/, '$1').replace(/(<\?xpacket end=".*"\?>).+$/, '$1');
        }

        function getRDF(node) {
          for (var i = 0; i < node.childNodes.length; i++) {
            if (node.childNodes[i].tagName === 'x:xmpmeta') {
              return getRDF(node.childNodes[i]);
            }

            if (node.childNodes[i].tagName === 'rdf:RDF') {
              return node.childNodes[i];
            }
          }

          throw new Error();
        }

        function convertToObject(node) {
          var isTopNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          var childNodes = getChildNodes(node);

          if (hasTextOnlyContent(childNodes)) {
            if (isTopNode) {
              return {};
            }

            return getTextValue(childNodes[0]);
          }

          return getElementsFromNodes(childNodes);
        }

        function getChildNodes(node) {
          var elements = [];

          for (var i = 0; i < node.childNodes.length; i++) {
            elements.push(node.childNodes[i]);
          }

          return elements;
        }

        function hasTextOnlyContent(nodes) {
          return nodes.length === 1 && nodes[0].nodeName === '#text';
        }

        function getTextValue(node) {
          return node.nodeValue;
        }

        function getElementsFromNodes(nodes) {
          var elements = {};
          nodes.forEach(function (node) {
            if (isElement(node)) {
              var nodeElement = getElementFromNode(node);

              if (elements[node.nodeName] !== undefined) {
                if (!Array.isArray(elements[node.nodeName])) {
                  elements[node.nodeName] = [elements[node.nodeName]];
                }

                elements[node.nodeName].push(nodeElement);
              } else {
                elements[node.nodeName] = nodeElement;
              }
            }
          });
          return elements;
        }

        function isElement(node) {
          return node.nodeName && node.nodeName !== '#text';
        }

        function getElementFromNode(node) {
          return {
            attributes: getAttributes(node),
            value: convertToObject(node)
          };
        }

        function getAttributes(element) {
          var attributes = {};

          for (var i = 0; i < element.attributes.length; i++) {
            attributes[element.attributes[i].nodeName] = decodeURIComponent(escape(element.attributes[i].value));
          }

          return attributes;
        }

        function parseXMPObject(xmpObject) {
          var tags = {};

          if (typeof xmpObject === 'string') {
            return xmpObject;
          }

          for (var nodeName in xmpObject) {
            var nodes = xmpObject[nodeName];

            if (!Array.isArray(nodes)) {
              nodes = [nodes];
            }

            nodes.forEach(function (node) {
              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["objectAssign"])(tags, parseNodeAttributesAsTags(node.attributes));

              if (_typeof(node.value) === 'object') {
                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["objectAssign"])(tags, parseNodeChildrenAsTags(node.value));
              }
            });
          }

          return tags;
        }

        function parseNodeAttributesAsTags(attributes) {
          var tags = {};

          for (var name in attributes) {
            if (isTagAttribute(name)) {
              tags[getLocalName(name)] = {
                value: attributes[name],
                attributes: {},
                description: getDescription(attributes[name], name)
              };
            }
          }

          return tags;
        }

        function isTagAttribute(name) {
          return name !== 'rdf:parseType' && !isNamespaceDefinition(name);
        }

        function isNamespaceDefinition(name) {
          return name.split(':')[0] === 'xmlns';
        }

        function getLocalName(name) {
          return name.split(':')[1];
        }

        function getDescription(value) {
          var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

          if (Array.isArray(value)) {
            return getDescriptionOfArray(value);
          }

          if (_typeof(value) === 'object') {
            return getDescriptionOfObject(value);
          }

          try {
            if (name && typeof _xmp_tag_names_js__WEBPACK_IMPORTED_MODULE_1__["default"][name] === 'function') {
              return _xmp_tag_names_js__WEBPACK_IMPORTED_MODULE_1__["default"][name](value);
            }

            return decodeURIComponent(escape(value));
          } catch (error) {
            return value;
          }
        }

        function getDescriptionOfArray(value) {
          return value.map(function (item) {
            if (item.value !== undefined) {
              return getDescription(item.value);
            }

            return getDescription(item);
          }).join(', ');
        }

        function getDescriptionOfObject(value) {
          var descriptions = [];

          for (var key in value) {
            descriptions.push("".concat(getClearTextKey(key), ": ").concat(value[key].value));
          }

          return descriptions.join('; ');
        }

        function getClearTextKey(key) {
          if (key === 'CiAdrCity') {
            return 'CreatorCity';
          }

          if (key === 'CiAdrCtry') {
            return 'CreatorCountry';
          }

          if (key === 'CiAdrExtadr') {
            return 'CreatorAddress';
          }

          if (key === 'CiAdrPcode') {
            return 'CreatorPostalCode';
          }

          if (key === 'CiAdrRegion') {
            return 'CreatorRegion';
          }

          if (key === 'CiEmailWork') {
            return 'CreatorWorkEmail';
          }

          if (key === 'CiTelWork') {
            return 'CreatorWorkPhone';
          }

          if (key === 'CiUrlWork') {
            return 'CreatorWorkUrl';
          }

          return key;
        }

        function parseNodeChildrenAsTags(children) {
          var tags = {};

          for (var name in children) {
            if (!isNamespaceDefinition(name)) {
              tags[getLocalName(name)] = parseNodeAsTag(children[name], name);
            }
          }

          return tags;
        }

        function parseNodeAsTag(node, name) {
          if (hasNestedSimpleRdfDescription(node)) {
            return parseNodeAsSimpleRdfDescription(node, name);
          } else if (hasNestedStructureRdfDescription(node)) {
            return parseNodeAsStructureRdfDescription(node, name);
          } else if (isCompactStructure(node)) {
            return parseNodeAsCompactStructure(node, name);
          } else if (isArray(node)) {
            return parseNodeAsArray(node, name);
          }

          return parseNodeAsSimpleValue(node, name);
        }

        function hasNestedSimpleRdfDescription(node) {
          return node.attributes['rdf:parseType'] === 'Resource' && node.value['rdf:value'] !== undefined || node.value['rdf:Description'] !== undefined && node.value['rdf:Description'].value['rdf:value'] !== undefined;
        }

        function parseNodeAsSimpleRdfDescription(node, name) {
          var attributes = parseNodeAttributes(node);

          if (node.value['rdf:Description'] !== undefined) {
            node = node.value['rdf:Description'];
          }

          Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["objectAssign"])(attributes, parseNodeAttributes(node), parseNodeChildrenAsAttributes(node));
          var value = parseRdfValue(node);
          return {
            value: value,
            attributes: attributes,
            description: getDescription(value, name)
          };
        }

        function parseNodeAttributes(node) {
          var attributes = {};

          for (var name in node.attributes) {
            if (name !== 'rdf:parseType' && name !== 'rdf:resource' && !isNamespaceDefinition(name)) {
              attributes[getLocalName(name)] = node.attributes[name];
            }
          }

          return attributes;
        }

        function parseNodeChildrenAsAttributes(node) {
          var attributes = {};

          for (var name in node.value) {
            if (name !== 'rdf:value' && !isNamespaceDefinition(name)) {
              attributes[getLocalName(name)] = node.value[name].value;
            }
          }

          return attributes;
        }

        function parseRdfValue(node) {
          return getURIValue(node.value['rdf:value']) || node.value['rdf:value'].value;
        }

        function hasNestedStructureRdfDescription(node) {
          return node.attributes['rdf:parseType'] === 'Resource' || node.value['rdf:Description'] !== undefined && node.value['rdf:Description'].value['rdf:value'] === undefined;
        }

        function parseNodeAsStructureRdfDescription(node, name) {
          var tag = {
            value: {},
            attributes: {}
          };

          if (node.value['rdf:Description'] !== undefined) {
            Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["objectAssign"])(tag.value, parseNodeAttributesAsTags(node.value['rdf:Description'].attributes));
            Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["objectAssign"])(tag.attributes, parseNodeAttributes(node));
            node = node.value['rdf:Description'];
          }

          Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["objectAssign"])(tag.value, parseNodeChildrenAsTags(node.value));
          tag.description = getDescription(tag.value, name);
          return tag;
        }

        function isCompactStructure(node) {
          return Object.keys(node.value).length === 0 && node.attributes['rdf:resource'] === undefined;
        }

        function parseNodeAsCompactStructure(node, name) {
          var value = parseNodeAttributesAsTags(node.attributes);
          return {
            value: value,
            attributes: {},
            description: getDescription(value, name)
          };
        }

        function isArray(node) {
          return getArrayChild(node.value) !== undefined;
        }

        function getArrayChild(value) {
          return value['rdf:Bag'] || value['rdf:Seq'] || value['rdf:Alt'];
        }

        function parseNodeAsArray(node, name) {
          var items = getArrayChild(node.value).value['rdf:li'];
          var attributes = parseNodeAttributes(node);
          var value = [];

          if (items === undefined) {
            items = [];
          } else if (!Array.isArray(items)) {
            items = [items];
          }

          items.forEach(function (item) {
            value.push(parseArrayValue(item));
          });
          return {
            value: value,
            attributes: attributes,
            description: getDescription(value, name)
          };
        }

        function parseArrayValue(item) {
          if (hasNestedSimpleRdfDescription(item)) {
            return parseNodeAsSimpleRdfDescription(item);
          }

          if (hasNestedArrayValue(item)) {
            return parseNodeChildrenAsTags(item.value);
          }

          return {
            value: item.value,
            attributes: parseNodeAttributes(item),
            description: getDescription(item.value)
          };
        }

        function hasNestedArrayValue(node) {
          return node.attributes['rdf:parseType'] === 'Resource';
        }

        function parseNodeAsSimpleValue(node, name) {
          var value = getURIValue(node) || parseXMPObject(node.value);
          return {
            value: value,
            attributes: parseNodeAttributes(node),
            description: getDescription(value, name)
          };
        }

        function getURIValue(node) {
          return node.attributes && node.attributes['rdf:resource'];
        }
        /***/

      }
      /******/

    })
  );
});

}).call(this,require("buffer").Buffer)

},{"buffer":9}],55:[function(require,module,exports){
"use strict";

/*
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
JPEG encoder ported to JavaScript and optimized by Andreas Ritter, www.bytestrom.eu, 11/2009

Basic GUI blocking jpeg encoder
*/
function JPEGEncoder(quality) {
  var ffloor = Math.floor;
  var YTable = new Array(64);
  var UVTable = new Array(64);
  var fdtbl_Y = new Array(64);
  var fdtbl_UV = new Array(64);
  var YDC_HT;
  var UVDC_HT;
  var YAC_HT;
  var UVAC_HT;
  var bitcode = new Array(65535);
  var category = new Array(65535);
  var outputfDCTQuant = new Array(64);
  var DU = new Array(64);
  var byteout = [];
  var bytenew = 0;
  var bytepos = 7;
  var YDU = new Array(64);
  var UDU = new Array(64);
  var VDU = new Array(64);
  var clt = new Array(256);
  var RGB_YUV_TABLE = new Array(2048);
  var currentQuality;
  var ZigZag = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63];
  var std_dc_luminance_nrcodes = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0];
  var std_dc_luminance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
  var std_ac_luminance_nrcodes = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d];
  var std_ac_luminance_values = [0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08, 0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa];
  var std_dc_chrominance_nrcodes = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0];
  var std_dc_chrominance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
  var std_ac_chrominance_nrcodes = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77];
  var std_ac_chrominance_values = [0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0, 0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34, 0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa];

  function initQuantTables(sf) {
    var YQT = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99];

    for (var i = 0; i < 64; i++) {
      var t = ffloor((YQT[i] * sf + 50) / 100);
      t = Math.min(Math.max(t, 1), 255);
      YTable[ZigZag[i]] = t;
    }

    var UVQT = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99];

    for (var j = 0; j < 64; j++) {
      var u = ffloor((UVQT[j] * sf + 50) / 100);
      u = Math.min(Math.max(u, 1), 255);
      UVTable[ZigZag[j]] = u;
    }

    var aasf = [1.0, 1.387039845, 1.306562965, 1.175875602, 1.0, 0.785694958, 0.541196100, 0.275899379];
    var k = 0;

    for (var row = 0; row < 8; row++) {
      for (var col = 0; col < 8; col++) {
        fdtbl_Y[k] = 1.0 / (YTable[ZigZag[k]] * aasf[row] * aasf[col] * 8.0);
        fdtbl_UV[k] = 1.0 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8.0);
        k++;
      }
    }
  }

  function computeHuffmanTbl(nrcodes, std_table) {
    var codevalue = 0;
    var pos_in_table = 0;
    var HT = new Array();

    for (var k = 1; k <= 16; k++) {
      for (var j = 1; j <= nrcodes[k]; j++) {
        HT[std_table[pos_in_table]] = [];
        HT[std_table[pos_in_table]][0] = codevalue;
        HT[std_table[pos_in_table]][1] = k;
        pos_in_table++;
        codevalue++;
      }

      codevalue *= 2;
    }

    return HT;
  }

  function initHuffmanTbl() {
    YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes, std_dc_luminance_values);
    UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes, std_dc_chrominance_values);
    YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes, std_ac_luminance_values);
    UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes, std_ac_chrominance_values);
  }

  function initCategoryNumber() {
    var nrlower = 1;
    var nrupper = 2;

    for (var cat = 1; cat <= 15; cat++) {
      //Positive numbers
      for (var nr = nrlower; nr < nrupper; nr++) {
        category[32767 + nr] = cat;
        bitcode[32767 + nr] = [];
        bitcode[32767 + nr][1] = cat;
        bitcode[32767 + nr][0] = nr;
      } //Negative numbers


      for (var nrneg = -(nrupper - 1); nrneg <= -nrlower; nrneg++) {
        category[32767 + nrneg] = cat;
        bitcode[32767 + nrneg] = [];
        bitcode[32767 + nrneg][1] = cat;
        bitcode[32767 + nrneg][0] = nrupper - 1 + nrneg;
      }

      nrlower <<= 1;
      nrupper <<= 1;
    }
  }

  function initRGBYUVTable() {
    for (var i = 0; i < 256; i++) {
      RGB_YUV_TABLE[i] = 19595 * i;
      RGB_YUV_TABLE[i + 256 >> 0] = 38470 * i;
      RGB_YUV_TABLE[i + 512 >> 0] = 7471 * i + 0x8000;
      RGB_YUV_TABLE[i + 768 >> 0] = -11059 * i;
      RGB_YUV_TABLE[i + 1024 >> 0] = -21709 * i;
      RGB_YUV_TABLE[i + 1280 >> 0] = 32768 * i + 0x807FFF;
      RGB_YUV_TABLE[i + 1536 >> 0] = -27439 * i;
      RGB_YUV_TABLE[i + 1792 >> 0] = -5329 * i;
    }
  } // IO functions


  function writeBits(bs) {
    var value = bs[0];
    var posval = bs[1] - 1;

    while (posval >= 0) {
      if (value & 1 << posval) {
        bytenew |= 1 << bytepos;
      }

      posval--;
      bytepos--;

      if (bytepos < 0) {
        if (bytenew == 0xFF) {
          writeByte(0xFF);
          writeByte(0);
        } else {
          writeByte(bytenew);
        }

        bytepos = 7;
        bytenew = 0;
      }
    }
  }

  function writeByte(value) {
    //byteout.push(clt[value]); // write char directly instead of converting later
    byteout.push(value);
  }

  function writeWord(value) {
    writeByte(value >> 8 & 0xFF);
    writeByte(value & 0xFF);
  } // DCT & quantization core


  function fDCTQuant(data, fdtbl) {
    var d0, d1, d2, d3, d4, d5, d6, d7;
    /* Pass 1: process rows. */

    var dataOff = 0;
    var i;
    var I8 = 8;
    var I64 = 64;

    for (i = 0; i < I8; ++i) {
      d0 = data[dataOff];
      d1 = data[dataOff + 1];
      d2 = data[dataOff + 2];
      d3 = data[dataOff + 3];
      d4 = data[dataOff + 4];
      d5 = data[dataOff + 5];
      d6 = data[dataOff + 6];
      d7 = data[dataOff + 7];
      var tmp0 = d0 + d7;
      var tmp7 = d0 - d7;
      var tmp1 = d1 + d6;
      var tmp6 = d1 - d6;
      var tmp2 = d2 + d5;
      var tmp5 = d2 - d5;
      var tmp3 = d3 + d4;
      var tmp4 = d3 - d4;
      /* Even part */

      var tmp10 = tmp0 + tmp3;
      /* phase 2 */

      var tmp13 = tmp0 - tmp3;
      var tmp11 = tmp1 + tmp2;
      var tmp12 = tmp1 - tmp2;
      data[dataOff] = tmp10 + tmp11;
      /* phase 3 */

      data[dataOff + 4] = tmp10 - tmp11;
      var z1 = (tmp12 + tmp13) * 0.707106781;
      /* c4 */

      data[dataOff + 2] = tmp13 + z1;
      /* phase 5 */

      data[dataOff + 6] = tmp13 - z1;
      /* Odd part */

      tmp10 = tmp4 + tmp5;
      /* phase 2 */

      tmp11 = tmp5 + tmp6;
      tmp12 = tmp6 + tmp7;
      /* The rotator is modified from fig 4-8 to avoid extra negations. */

      var z5 = (tmp10 - tmp12) * 0.382683433;
      /* c6 */

      var z2 = 0.541196100 * tmp10 + z5;
      /* c2-c6 */

      var z4 = 1.306562965 * tmp12 + z5;
      /* c2+c6 */

      var z3 = tmp11 * 0.707106781;
      /* c4 */

      var z11 = tmp7 + z3;
      /* phase 5 */

      var z13 = tmp7 - z3;
      data[dataOff + 5] = z13 + z2;
      /* phase 6 */

      data[dataOff + 3] = z13 - z2;
      data[dataOff + 1] = z11 + z4;
      data[dataOff + 7] = z11 - z4;
      dataOff += 8;
      /* advance pointer to next row */
    }
    /* Pass 2: process columns. */


    dataOff = 0;

    for (i = 0; i < I8; ++i) {
      d0 = data[dataOff];
      d1 = data[dataOff + 8];
      d2 = data[dataOff + 16];
      d3 = data[dataOff + 24];
      d4 = data[dataOff + 32];
      d5 = data[dataOff + 40];
      d6 = data[dataOff + 48];
      d7 = data[dataOff + 56];
      var tmp0p2 = d0 + d7;
      var tmp7p2 = d0 - d7;
      var tmp1p2 = d1 + d6;
      var tmp6p2 = d1 - d6;
      var tmp2p2 = d2 + d5;
      var tmp5p2 = d2 - d5;
      var tmp3p2 = d3 + d4;
      var tmp4p2 = d3 - d4;
      /* Even part */

      var tmp10p2 = tmp0p2 + tmp3p2;
      /* phase 2 */

      var tmp13p2 = tmp0p2 - tmp3p2;
      var tmp11p2 = tmp1p2 + tmp2p2;
      var tmp12p2 = tmp1p2 - tmp2p2;
      data[dataOff] = tmp10p2 + tmp11p2;
      /* phase 3 */

      data[dataOff + 32] = tmp10p2 - tmp11p2;
      var z1p2 = (tmp12p2 + tmp13p2) * 0.707106781;
      /* c4 */

      data[dataOff + 16] = tmp13p2 + z1p2;
      /* phase 5 */

      data[dataOff + 48] = tmp13p2 - z1p2;
      /* Odd part */

      tmp10p2 = tmp4p2 + tmp5p2;
      /* phase 2 */

      tmp11p2 = tmp5p2 + tmp6p2;
      tmp12p2 = tmp6p2 + tmp7p2;
      /* The rotator is modified from fig 4-8 to avoid extra negations. */

      var z5p2 = (tmp10p2 - tmp12p2) * 0.382683433;
      /* c6 */

      var z2p2 = 0.541196100 * tmp10p2 + z5p2;
      /* c2-c6 */

      var z4p2 = 1.306562965 * tmp12p2 + z5p2;
      /* c2+c6 */

      var z3p2 = tmp11p2 * 0.707106781;
      /* c4 */

      var z11p2 = tmp7p2 + z3p2;
      /* phase 5 */

      var z13p2 = tmp7p2 - z3p2;
      data[dataOff + 40] = z13p2 + z2p2;
      /* phase 6 */

      data[dataOff + 24] = z13p2 - z2p2;
      data[dataOff + 8] = z11p2 + z4p2;
      data[dataOff + 56] = z11p2 - z4p2;
      dataOff++;
      /* advance pointer to next column */
    } // Quantize/descale the coefficients


    var fDCTQuant;

    for (i = 0; i < I64; ++i) {
      // Apply the quantization and scaling factor & Round to nearest integer
      fDCTQuant = data[i] * fdtbl[i];
      outputfDCTQuant[i] = fDCTQuant > 0.0 ? fDCTQuant + 0.5 | 0 : fDCTQuant - 0.5 | 0; //outputfDCTQuant[i] = fround(fDCTQuant);
    }

    return outputfDCTQuant;
  }

  function writeAPP0() {
    writeWord(0xFFE0); // marker

    writeWord(16); // length

    writeByte(0x4A); // J

    writeByte(0x46); // F

    writeByte(0x49); // I

    writeByte(0x46); // F

    writeByte(0); // = "JFIF",'\0'

    writeByte(1); // versionhi

    writeByte(1); // versionlo

    writeByte(0); // xyunits

    writeWord(1); // xdensity

    writeWord(1); // ydensity

    writeByte(0); // thumbnwidth

    writeByte(0); // thumbnheight
  }

  function writeSOF0(width, height) {
    writeWord(0xFFC0); // marker

    writeWord(17); // length, truecolor YUV JPG

    writeByte(8); // precision

    writeWord(height);
    writeWord(width);
    writeByte(3); // nrofcomponents

    writeByte(1); // IdY

    writeByte(0x11); // HVY

    writeByte(0); // QTY

    writeByte(2); // IdU

    writeByte(0x11); // HVU

    writeByte(1); // QTU

    writeByte(3); // IdV

    writeByte(0x11); // HVV

    writeByte(1); // QTV
  }

  function writeDQT() {
    writeWord(0xFFDB); // marker

    writeWord(132); // length

    writeByte(0);

    for (var i = 0; i < 64; i++) {
      writeByte(YTable[i]);
    }

    writeByte(1);

    for (var j = 0; j < 64; j++) {
      writeByte(UVTable[j]);
    }
  }

  function writeDHT() {
    writeWord(0xFFC4); // marker

    writeWord(0x01A2); // length

    writeByte(0); // HTYDCinfo

    for (var i = 0; i < 16; i++) {
      writeByte(std_dc_luminance_nrcodes[i + 1]);
    }

    for (var j = 0; j <= 11; j++) {
      writeByte(std_dc_luminance_values[j]);
    }

    writeByte(0x10); // HTYACinfo

    for (var k = 0; k < 16; k++) {
      writeByte(std_ac_luminance_nrcodes[k + 1]);
    }

    for (var l = 0; l <= 161; l++) {
      writeByte(std_ac_luminance_values[l]);
    }

    writeByte(1); // HTUDCinfo

    for (var m = 0; m < 16; m++) {
      writeByte(std_dc_chrominance_nrcodes[m + 1]);
    }

    for (var n = 0; n <= 11; n++) {
      writeByte(std_dc_chrominance_values[n]);
    }

    writeByte(0x11); // HTUACinfo

    for (var o = 0; o < 16; o++) {
      writeByte(std_ac_chrominance_nrcodes[o + 1]);
    }

    for (var p = 0; p <= 161; p++) {
      writeByte(std_ac_chrominance_values[p]);
    }
  }

  function writeSOS() {
    writeWord(0xFFDA); // marker

    writeWord(12); // length

    writeByte(3); // nrofcomponents

    writeByte(1); // IdY

    writeByte(0); // HTY

    writeByte(2); // IdU

    writeByte(0x11); // HTU

    writeByte(3); // IdV

    writeByte(0x11); // HTV

    writeByte(0); // Ss

    writeByte(0x3f); // Se

    writeByte(0); // Bf
  }

  function processDU(CDU, fdtbl, DC, HTDC, HTAC) {
    var EOB = HTAC[0x00];
    var M16zeroes = HTAC[0xF0];
    var pos;
    var I16 = 16;
    var I63 = 63;
    var I64 = 64;
    var DU_DCT = fDCTQuant(CDU, fdtbl); //ZigZag reorder

    for (var j = 0; j < I64; ++j) {
      DU[ZigZag[j]] = DU_DCT[j];
    }

    var Diff = DU[0] - DC;
    DC = DU[0]; //Encode DC

    if (Diff == 0) {
      writeBits(HTDC[0]); // Diff might be 0
    } else {
      pos = 32767 + Diff;
      writeBits(HTDC[category[pos]]);
      writeBits(bitcode[pos]);
    } //Encode ACs


    var end0pos = 63; // was const... which is crazy

    while (end0pos > 0 && DU[end0pos] == 0) {
      end0pos--;
    } //end0pos = first element in reverse order !=0


    if (end0pos == 0) {
      writeBits(EOB);
      return DC;
    }

    var i = 1;
    var lng;

    while (i <= end0pos) {
      var startpos = i;

      while (DU[i] == 0 && i <= end0pos) {
        ++i;
      }

      var nrzeroes = i - startpos;

      if (nrzeroes >= I16) {
        lng = nrzeroes >> 4;

        for (var nrmarker = 1; nrmarker <= lng; ++nrmarker) {
          writeBits(M16zeroes);
        }

        nrzeroes = nrzeroes & 0xF;
      }

      pos = 32767 + DU[i];
      writeBits(HTAC[(nrzeroes << 4) + category[pos]]);
      writeBits(bitcode[pos]);
      i++;
    }

    if (end0pos != I63) {
      writeBits(EOB);
    }

    return DC;
  }

  function initCharLookupTable() {
    var sfcc = String.fromCharCode;

    for (var i = 0; i < 256; i++) {
      ///// ACHTUNG // 255
      clt[i] = sfcc(i);
    }
  }

  this.encode = function (image, quality) // image data object
  {
    if (quality) setQuality(quality); // Initialize bit writer

    byteout = new Array();
    bytenew = 0;
    bytepos = 7; // Add JPEG headers

    writeWord(0xFFD8); // SOI

    writeAPP0();
    writeDQT();
    writeSOF0(image.width, image.height);
    writeDHT();
    writeSOS(); // Encode 8x8 macroblocks

    var DCY = 0;
    var DCU = 0;
    var DCV = 0;
    bytenew = 0;
    bytepos = 7;
    this.encode.displayName = "_encode_";
    var imageData = image.data;
    var width = image.width;
    var height = image.height;
    var quadWidth = width * 4;
    var x,
        y = 0;
    var r, g, b;
    var start, p, col, row, pos;

    while (y < height) {
      x = 0;

      while (x < quadWidth) {
        start = quadWidth * y + x;
        col = -1;
        row = 0;

        for (pos = 0; pos < 64; pos++) {
          row = pos >> 3; // /8

          col = (pos & 7) * 4; // %8

          p = start + row * quadWidth + col;

          if (y + row >= height) {
            // padding bottom
            p -= quadWidth * (y + 1 + row - height);
          }

          if (x + col >= quadWidth) {
            // padding right
            p -= x + col - quadWidth + 4;
          }

          r = imageData[p++];
          g = imageData[p++];
          b = imageData[p++];
          /* // calculate YUV values dynamically
          YDU[pos]=((( 0.29900)*r+( 0.58700)*g+( 0.11400)*b))-128; //-0x80
          UDU[pos]=(((-0.16874)*r+(-0.33126)*g+( 0.50000)*b));
          VDU[pos]=((( 0.50000)*r+(-0.41869)*g+(-0.08131)*b));
          */
          // use lookup table (slightly faster)

          YDU[pos] = (RGB_YUV_TABLE[r] + RGB_YUV_TABLE[g + 256 >> 0] + RGB_YUV_TABLE[b + 512 >> 0] >> 16) - 128;
          UDU[pos] = (RGB_YUV_TABLE[r + 768 >> 0] + RGB_YUV_TABLE[g + 1024 >> 0] + RGB_YUV_TABLE[b + 1280 >> 0] >> 16) - 128;
          VDU[pos] = (RGB_YUV_TABLE[r + 1280 >> 0] + RGB_YUV_TABLE[g + 1536 >> 0] + RGB_YUV_TABLE[b + 1792 >> 0] >> 16) - 128;
        }

        DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);
        DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
        DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
        x += 32;
      }

      y += 8;
    } ////////////////////////////////////////////////////////////////
    // Do the bit alignment of the EOI marker


    if (bytepos >= 0) {
      var fillbits = [];
      fillbits[1] = bytepos + 1;
      fillbits[0] = (1 << bytepos + 1) - 1;
      writeBits(fillbits);
    }

    writeWord(0xFFD9); //EOI

    return new Uint8Array(byteout);
  };

  function setQuality(quality) {
    quality = Math.min(Math.max(quality, 1), 100);
    if (currentQuality == quality) return; // don't recalc if unchanged

    var sf = quality < 50 ? Math.floor(5000 / quality) : Math.floor(200 - quality * 2);
    initQuantTables(sf);
    currentQuality = quality; //console.log('Quality set to: '+quality +'%');
  }

  function init() {
    quality = quality || 50; // Create tables

    initCharLookupTable();
    initHuffmanTbl();
    initCategoryNumber();
    initRGBYUVTable();
    setQuality(quality);
  }

  init();
} // eslint-disable-next-line no-empty


exports.JPEGEncoder = JPEGEncoder;

},{}],56:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.JpegImage = void 0;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/* Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var BaseException = function BaseExceptionClosure() {
  // eslint-disable-next-line no-shadow
  function BaseException(message) {
    if (this.constructor === BaseException) {
      unreachable("Cannot initialize BaseException.");
    }

    this.message = message;
    this.name = this.constructor.name;
  }

  BaseException.prototype = new Error();
  BaseException.constructor = BaseException;
  return BaseException;
}();

var VerbosityLevel = {
  ERRORS: 0,
  WARNINGS: 1,
  INFOS: 5
}; // Non-fatal warnings.

function warn(msg) {
  if (verbosity >= VerbosityLevel.WARNINGS) {
    console.log("Warning: ".concat(msg));
  }
}

function unreachable(msg) {
  throw new Error(msg);
}

function assert(cond, msg) {
  if (!cond) {
    unreachable(msg);
  }
}

function readUint16(data, offset) {
  return data[offset] << 8 | data[offset + 1];
}

var JpegError = /*#__PURE__*/function (_BaseException) {
  _inherits(JpegError, _BaseException);

  var _super = _createSuper(JpegError);

  function JpegError(msg) {
    _classCallCheck(this, JpegError);

    return _super.call(this, "JPEG error: ".concat(msg));
  }

  return JpegError;
}(BaseException);

var DNLMarkerError = /*#__PURE__*/function (_BaseException2) {
  _inherits(DNLMarkerError, _BaseException2);

  var _super2 = _createSuper(DNLMarkerError);

  function DNLMarkerError(message, scanLines) {
    var _this;

    _classCallCheck(this, DNLMarkerError);

    _this = _super2.call(this, message);
    _this.scanLines = scanLines;
    return _this;
  }

  return DNLMarkerError;
}(BaseException);

var EOIMarkerError = /*#__PURE__*/function (_BaseException3) {
  _inherits(EOIMarkerError, _BaseException3);

  var _super3 = _createSuper(EOIMarkerError);

  function EOIMarkerError() {
    _classCallCheck(this, EOIMarkerError);

    return _super3.apply(this, arguments);
  }

  return EOIMarkerError;
}(BaseException);
/**
 * This code was forked from https://github.com/notmasteryet/jpgjs.
 * The original version was created by GitHub user notmasteryet.
 *
 * - The JPEG specification can be found in the ITU CCITT Recommendation T.81
 *   (www.w3.org/Graphics/JPEG/itu-t81.pdf)
 * - The JFIF specification can be found in the JPEG File Interchange Format
 *   (www.w3.org/Graphics/JPEG/jfif3.pdf)
 * - The Adobe Application-Specific JPEG markers in the
 *   Supporting the DCT Filters in PostScript Level 2, Technical Note #5116
 *   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)
 */


var JpegImage = function JpegImageClosure() {
  // prettier-ignore
  var dctZigZag = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]);
  var dctCos1 = 4017; // cos(pi/16)

  var dctSin1 = 799; // sin(pi/16)

  var dctCos3 = 3406; // cos(3*pi/16)

  var dctSin3 = 2276; // sin(3*pi/16)

  var dctCos6 = 1567; // cos(6*pi/16)

  var dctSin6 = 3784; // sin(6*pi/16)

  var dctSqrt2 = 5793; // sqrt(2)

  var dctSqrt1d2 = 2896; // sqrt(2) / 2
  // eslint-disable-next-line no-shadow

  function JpegImage() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$decodeTransform = _ref.decodeTransform,
        decodeTransform = _ref$decodeTransform === void 0 ? null : _ref$decodeTransform,
        _ref$colorTransform = _ref.colorTransform,
        colorTransform = _ref$colorTransform === void 0 ? -1 : _ref$colorTransform;

    this._decodeTransform = decodeTransform;
    this._colorTransform = colorTransform;
  }

  function buildHuffmanTable(codeLengths, values) {
    var k = 0,
        code = [],
        i,
        j,
        length = 16;

    while (length > 0 && !codeLengths[length - 1]) {
      length--;
    }

    code.push({
      children: [],
      index: 0
    });
    var p = code[0],
        q;

    for (i = 0; i < length; i++) {
      for (j = 0; j < codeLengths[i]; j++) {
        p = code.pop();
        p.children[p.index] = values[k];

        while (p.index > 0) {
          p = code.pop();
        }

        p.index++;
        code.push(p);

        while (code.length <= i) {
          code.push(q = {
            children: [],
            index: 0
          });
          p.children[p.index] = q.children;
          p = q;
        }

        k++;
      }

      if (i + 1 < length) {
        // p here points to last code
        code.push(q = {
          children: [],
          index: 0
        });
        p.children[p.index] = q.children;
        p = q;
      }
    }

    return code[0].children;
  }

  function getBlockBufferOffset(component, row, col) {
    return 64 * ((component.blocksPerLine + 1) * row + col);
  }

  function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive) {
    var parseDNLMarker = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : false;
    var mcusPerLine = frame.mcusPerLine;
    var progressive = frame.progressive;
    var startOffset = offset;
    var bitsData = 0,
        bitsCount = 0;

    function readBit() {
      if (bitsCount > 0) {
        bitsCount--;
        return bitsData >> bitsCount & 1;
      }

      bitsData = data[offset++];

      if (bitsData === 0xff) {
        var nextByte = data[offset++];

        if (nextByte) {
          if (nextByte ===
          /* DNL = */
          0xdc && parseDNLMarker) {
            offset += 2; // Skip marker length.

            var scanLines = readUint16(data, offset);
            offset += 2;

            if (scanLines > 0 && scanLines !== frame.scanLines) {
              throw new DNLMarkerError("Found DNL marker (0xFFDC) while parsing scan data", scanLines);
            }
          } else if (nextByte ===
          /* EOI = */
          0xd9) {
            if (parseDNLMarker) {
              // NOTE: only 8-bit JPEG images are supported in this decoder.
              var maybeScanLines = blockRow * (frame.precision === 8 ? 8 : 0); // Heuristic to attempt to handle corrupt JPEG images with too
              // large `scanLines` parameter, by falling back to the currently
              // parsed number of scanLines when it's at least (approximately)
              // one order of magnitude smaller than expected (fixes
              // issue10880.pdf and issue10989.pdf).

              if (maybeScanLines > 0 && Math.round(frame.scanLines / maybeScanLines) >= 10) {
                throw new DNLMarkerError("Found EOI marker (0xFFD9) while parsing scan data, " + "possibly caused by incorrect `scanLines` parameter", maybeScanLines);
              }
            }

            throw new EOIMarkerError("Found EOI marker (0xFFD9) while parsing scan data");
          }

          throw new JpegError("unexpected marker ".concat((bitsData << 8 | nextByte).toString(16)));
        } // unstuff 0

      }

      bitsCount = 7;
      return bitsData >>> 7;
    }

    function decodeHuffman(tree) {
      var node = tree;

      while (true) {
        node = node[readBit()];

        switch (_typeof(node)) {
          case "number":
            return node;

          case "object":
            continue;
        }

        throw new JpegError("invalid huffman sequence");
      }
    }

    function receive(length) {
      var n = 0;

      while (length > 0) {
        n = n << 1 | readBit();
        length--;
      }

      return n;
    }

    function receiveAndExtend(length) {
      if (length === 1) {
        return readBit() === 1 ? 1 : -1;
      }

      var n = receive(length);

      if (n >= 1 << length - 1) {
        return n;
      }

      return n + (-1 << length) + 1;
    }

    function decodeBaseline(component, blockOffset) {
      var t = decodeHuffman(component.huffmanTableDC);
      var diff = t === 0 ? 0 : receiveAndExtend(t);
      component.blockData[blockOffset] = component.pred += diff;
      var k = 1;

      while (k < 64) {
        var rs = decodeHuffman(component.huffmanTableAC);
        var s = rs & 15,
            r = rs >> 4;

        if (s === 0) {
          if (r < 15) {
            break;
          }

          k += 16;
          continue;
        }

        k += r;
        var z = dctZigZag[k];
        component.blockData[blockOffset + z] = receiveAndExtend(s);
        k++;
      }
    }

    function decodeDCFirst(component, blockOffset) {
      var t = decodeHuffman(component.huffmanTableDC);
      var diff = t === 0 ? 0 : receiveAndExtend(t) << successive;
      component.blockData[blockOffset] = component.pred += diff;
    }

    function decodeDCSuccessive(component, blockOffset) {
      component.blockData[blockOffset] |= readBit() << successive;
    }

    var eobrun = 0;

    function decodeACFirst(component, blockOffset) {
      if (eobrun > 0) {
        eobrun--;
        return;
      }

      var k = spectralStart,
          e = spectralEnd;

      while (k <= e) {
        var rs = decodeHuffman(component.huffmanTableAC);
        var s = rs & 15,
            r = rs >> 4;

        if (s === 0) {
          if (r < 15) {
            eobrun = receive(r) + (1 << r) - 1;
            break;
          }

          k += 16;
          continue;
        }

        k += r;
        var z = dctZigZag[k];
        component.blockData[blockOffset + z] = receiveAndExtend(s) * (1 << successive);
        k++;
      }
    }

    var successiveACState = 0,
        successiveACNextValue;

    function decodeACSuccessive(component, blockOffset) {
      var k = spectralStart;
      var e = spectralEnd;
      var r = 0;
      var s;
      var rs;

      while (k <= e) {
        var offsetZ = blockOffset + dctZigZag[k];
        var sign = component.blockData[offsetZ] < 0 ? -1 : 1;

        switch (successiveACState) {
          case 0:
            // initial state
            rs = decodeHuffman(component.huffmanTableAC);
            s = rs & 15;
            r = rs >> 4;

            if (s === 0) {
              if (r < 15) {
                eobrun = receive(r) + (1 << r);
                successiveACState = 4;
              } else {
                r = 16;
                successiveACState = 1;
              }
            } else {
              if (s !== 1) {
                throw new JpegError("invalid ACn encoding");
              }

              successiveACNextValue = receiveAndExtend(s);
              successiveACState = r ? 2 : 3;
            }

            continue;

          case 1: // skipping r zero items

          case 2:
            if (component.blockData[offsetZ]) {
              component.blockData[offsetZ] += sign * (readBit() << successive);
            } else {
              r--;

              if (r === 0) {
                successiveACState = successiveACState === 2 ? 3 : 0;
              }
            }

            break;

          case 3:
            // set value for a zero item
            if (component.blockData[offsetZ]) {
              component.blockData[offsetZ] += sign * (readBit() << successive);
            } else {
              component.blockData[offsetZ] = successiveACNextValue << successive;
              successiveACState = 0;
            }

            break;

          case 4:
            // eob
            if (component.blockData[offsetZ]) {
              component.blockData[offsetZ] += sign * (readBit() << successive);
            }

            break;
        }

        k++;
      }

      if (successiveACState === 4) {
        eobrun--;

        if (eobrun === 0) {
          successiveACState = 0;
        }
      }
    }

    var blockRow = 0;

    function decodeMcu(component, decode, mcu, row, col) {
      var mcuRow = mcu / mcusPerLine | 0;
      var mcuCol = mcu % mcusPerLine;
      blockRow = mcuRow * component.v + row;
      var blockCol = mcuCol * component.h + col;
      var blockOffset = getBlockBufferOffset(component, blockRow, blockCol);
      decode(component, blockOffset);
    }

    function decodeBlock(component, decode, mcu) {
      blockRow = mcu / component.blocksPerLine | 0;
      var blockCol = mcu % component.blocksPerLine;
      var blockOffset = getBlockBufferOffset(component, blockRow, blockCol);
      decode(component, blockOffset);
    }

    var componentsLength = components.length;
    var component, i, j, k, n;
    var decodeFn;

    if (progressive) {
      if (spectralStart === 0) {
        decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
      } else {
        decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
      }
    } else {
      decodeFn = decodeBaseline;
    }

    var mcu = 0,
        fileMarker;
    var mcuExpected;

    if (componentsLength === 1) {
      mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
    } else {
      mcuExpected = mcusPerLine * frame.mcusPerColumn;
    }

    var h, v;

    while (mcu <= mcuExpected) {
      // reset interval stuff
      var mcuToRead = resetInterval ? Math.min(mcuExpected - mcu, resetInterval) : mcuExpected; // The `mcuToRead === 0` case should only occur when all of the expected
      // MCU data has been already parsed, i.e. when `mcu === mcuExpected`, but
      // some corrupt JPEG images contain more data than intended and we thus
      // want to skip over any extra RSTx markers below (fixes issue11794.pdf).

      if (mcuToRead > 0) {
        for (i = 0; i < componentsLength; i++) {
          components[i].pred = 0;
        }

        eobrun = 0;

        if (componentsLength === 1) {
          component = components[0];

          for (n = 0; n < mcuToRead; n++) {
            decodeBlock(component, decodeFn, mcu);
            mcu++;
          }
        } else {
          for (n = 0; n < mcuToRead; n++) {
            for (i = 0; i < componentsLength; i++) {
              component = components[i];
              h = component.h;
              v = component.v;

              for (j = 0; j < v; j++) {
                for (k = 0; k < h; k++) {
                  decodeMcu(component, decodeFn, mcu, j, k);
                }
              }
            }

            mcu++;
          }
        }
      } // find marker


      bitsCount = 0;
      fileMarker = findNextFileMarker(data, offset);

      if (!fileMarker) {
        break; // Reached the end of the image data without finding any marker.
      }

      if (fileMarker.invalid) {
        // Some bad images seem to pad Scan blocks with e.g. zero bytes, skip
        // past those to attempt to find a valid marker (fixes issue4090.pdf).
        var partialMsg = mcuToRead > 0 ? "unexpected" : "excessive";
        warn("decodeScan - ".concat(partialMsg, " MCU data, current marker is: ").concat(fileMarker.invalid));
        offset = fileMarker.offset;
      }

      if (fileMarker.marker >= 0xffd0 && fileMarker.marker <= 0xffd7) {
        // RSTx
        offset += 2;
      } else {
        break;
      }
    }

    return offset - startOffset;
  } // A port of poppler's IDCT method which in turn is taken from:
  //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,
  //   'Practical Fast 1-D DCT Algorithms with 11 Multiplications',
  //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,
  //   988-991.


  function quantizeAndInverse(component, blockBufferOffset, p) {
    var qt = component.quantizationTable,
        blockData = component.blockData;
    var v0, v1, v2, v3, v4, v5, v6, v7;
    var p0, p1, p2, p3, p4, p5, p6, p7;
    var t;

    if (!qt) {
      throw new JpegError("missing required Quantization Table.");
    } // inverse DCT on rows


    for (var row = 0; row < 64; row += 8) {
      // gather block data
      p0 = blockData[blockBufferOffset + row];
      p1 = blockData[blockBufferOffset + row + 1];
      p2 = blockData[blockBufferOffset + row + 2];
      p3 = blockData[blockBufferOffset + row + 3];
      p4 = blockData[blockBufferOffset + row + 4];
      p5 = blockData[blockBufferOffset + row + 5];
      p6 = blockData[blockBufferOffset + row + 6];
      p7 = blockData[blockBufferOffset + row + 7]; // dequant p0

      p0 *= qt[row]; // check for all-zero AC coefficients

      if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {
        t = dctSqrt2 * p0 + 512 >> 10;
        p[row] = t;
        p[row + 1] = t;
        p[row + 2] = t;
        p[row + 3] = t;
        p[row + 4] = t;
        p[row + 5] = t;
        p[row + 6] = t;
        p[row + 7] = t;
        continue;
      } // dequant p1 ... p7


      p1 *= qt[row + 1];
      p2 *= qt[row + 2];
      p3 *= qt[row + 3];
      p4 *= qt[row + 4];
      p5 *= qt[row + 5];
      p6 *= qt[row + 6];
      p7 *= qt[row + 7]; // stage 4

      v0 = dctSqrt2 * p0 + 128 >> 8;
      v1 = dctSqrt2 * p4 + 128 >> 8;
      v2 = p2;
      v3 = p6;
      v4 = dctSqrt1d2 * (p1 - p7) + 128 >> 8;
      v7 = dctSqrt1d2 * (p1 + p7) + 128 >> 8;
      v5 = p3 << 4;
      v6 = p5 << 4; // stage 3

      v0 = v0 + v1 + 1 >> 1;
      v1 = v0 - v1;
      t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;
      v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;
      v3 = t;
      v4 = v4 + v6 + 1 >> 1;
      v6 = v4 - v6;
      v7 = v7 + v5 + 1 >> 1;
      v5 = v7 - v5; // stage 2

      v0 = v0 + v3 + 1 >> 1;
      v3 = v0 - v3;
      v1 = v1 + v2 + 1 >> 1;
      v2 = v1 - v2;
      t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
      v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
      v7 = t;
      t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
      v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
      v6 = t; // stage 1

      p[row] = v0 + v7;
      p[row + 7] = v0 - v7;
      p[row + 1] = v1 + v6;
      p[row + 6] = v1 - v6;
      p[row + 2] = v2 + v5;
      p[row + 5] = v2 - v5;
      p[row + 3] = v3 + v4;
      p[row + 4] = v3 - v4;
    } // inverse DCT on columns


    for (var col = 0; col < 8; ++col) {
      p0 = p[col];
      p1 = p[col + 8];
      p2 = p[col + 16];
      p3 = p[col + 24];
      p4 = p[col + 32];
      p5 = p[col + 40];
      p6 = p[col + 48];
      p7 = p[col + 56]; // check for all-zero AC coefficients

      if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {
        t = dctSqrt2 * p0 + 8192 >> 14; // Convert to 8-bit.

        if (t < -2040) {
          t = 0;
        } else if (t >= 2024) {
          t = 255;
        } else {
          t = t + 2056 >> 4;
        }

        blockData[blockBufferOffset + col] = t;
        blockData[blockBufferOffset + col + 8] = t;
        blockData[blockBufferOffset + col + 16] = t;
        blockData[blockBufferOffset + col + 24] = t;
        blockData[blockBufferOffset + col + 32] = t;
        blockData[blockBufferOffset + col + 40] = t;
        blockData[blockBufferOffset + col + 48] = t;
        blockData[blockBufferOffset + col + 56] = t;
        continue;
      } // stage 4


      v0 = dctSqrt2 * p0 + 2048 >> 12;
      v1 = dctSqrt2 * p4 + 2048 >> 12;
      v2 = p2;
      v3 = p6;
      v4 = dctSqrt1d2 * (p1 - p7) + 2048 >> 12;
      v7 = dctSqrt1d2 * (p1 + p7) + 2048 >> 12;
      v5 = p3;
      v6 = p5; // stage 3
      // Shift v0 by 128.5 << 5 here, so we don't need to shift p0...p7 when
      // converting to UInt8 range later.

      v0 = (v0 + v1 + 1 >> 1) + 4112;
      v1 = v0 - v1;
      t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
      v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
      v3 = t;
      v4 = v4 + v6 + 1 >> 1;
      v6 = v4 - v6;
      v7 = v7 + v5 + 1 >> 1;
      v5 = v7 - v5; // stage 2

      v0 = v0 + v3 + 1 >> 1;
      v3 = v0 - v3;
      v1 = v1 + v2 + 1 >> 1;
      v2 = v1 - v2;
      t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
      v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
      v7 = t;
      t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
      v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
      v6 = t; // stage 1

      p0 = v0 + v7;
      p7 = v0 - v7;
      p1 = v1 + v6;
      p6 = v1 - v6;
      p2 = v2 + v5;
      p5 = v2 - v5;
      p3 = v3 + v4;
      p4 = v3 - v4; // Convert to 8-bit integers.

      if (p0 < 16) {
        p0 = 0;
      } else if (p0 >= 4080) {
        p0 = 255;
      } else {
        p0 >>= 4;
      }

      if (p1 < 16) {
        p1 = 0;
      } else if (p1 >= 4080) {
        p1 = 255;
      } else {
        p1 >>= 4;
      }

      if (p2 < 16) {
        p2 = 0;
      } else if (p2 >= 4080) {
        p2 = 255;
      } else {
        p2 >>= 4;
      }

      if (p3 < 16) {
        p3 = 0;
      } else if (p3 >= 4080) {
        p3 = 255;
      } else {
        p3 >>= 4;
      }

      if (p4 < 16) {
        p4 = 0;
      } else if (p4 >= 4080) {
        p4 = 255;
      } else {
        p4 >>= 4;
      }

      if (p5 < 16) {
        p5 = 0;
      } else if (p5 >= 4080) {
        p5 = 255;
      } else {
        p5 >>= 4;
      }

      if (p6 < 16) {
        p6 = 0;
      } else if (p6 >= 4080) {
        p6 = 255;
      } else {
        p6 >>= 4;
      }

      if (p7 < 16) {
        p7 = 0;
      } else if (p7 >= 4080) {
        p7 = 255;
      } else {
        p7 >>= 4;
      } // store block data


      blockData[blockBufferOffset + col] = p0;
      blockData[blockBufferOffset + col + 8] = p1;
      blockData[blockBufferOffset + col + 16] = p2;
      blockData[blockBufferOffset + col + 24] = p3;
      blockData[blockBufferOffset + col + 32] = p4;
      blockData[blockBufferOffset + col + 40] = p5;
      blockData[blockBufferOffset + col + 48] = p6;
      blockData[blockBufferOffset + col + 56] = p7;
    }
  }

  function buildComponentData(frame, component) {
    var blocksPerLine = component.blocksPerLine;
    var blocksPerColumn = component.blocksPerColumn;
    var computationBuffer = new Int16Array(64);

    for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
      for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
        var offset = getBlockBufferOffset(component, blockRow, blockCol);
        quantizeAndInverse(component, offset, computationBuffer);
      }
    }

    return component.blockData;
  }

  function findNextFileMarker(data, currentPos) {
    var startPos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : currentPos;
    var maxPos = data.length - 1;
    var newPos = startPos < currentPos ? startPos : currentPos;

    if (currentPos >= maxPos) {
      return null; // Don't attempt to read non-existent data and just return.
    }

    var currentMarker = readUint16(data, currentPos);

    if (currentMarker >= 0xffc0 && currentMarker <= 0xfffe) {
      return {
        invalid: null,
        marker: currentMarker,
        offset: currentPos
      };
    }

    var newMarker = readUint16(data, newPos);

    while (!(newMarker >= 0xffc0 && newMarker <= 0xfffe)) {
      if (++newPos >= maxPos) {
        return null; // Don't attempt to read non-existent data and just return.
      }

      newMarker = readUint16(data, newPos);
    }

    return {
      invalid: currentMarker.toString(16),
      marker: newMarker,
      offset: newPos
    };
  }

  JpegImage.prototype = {
    parse: function parse(data) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$dnlScanLines = _ref2.dnlScanLines,
          dnlScanLines = _ref2$dnlScanLines === void 0 ? null : _ref2$dnlScanLines;

      function readDataBlock() {
        var length = readUint16(data, offset);
        offset += 2;
        var endOffset = offset + length - 2;
        var fileMarker = findNextFileMarker(data, endOffset, offset);

        if (fileMarker && fileMarker.invalid) {
          warn("readDataBlock - incorrect length, current marker is: " + fileMarker.invalid);
          endOffset = fileMarker.offset;
        }

        var array = data.subarray(offset, endOffset);
        offset += array.length;
        return array;
      }

      function prepareComponents(frame) {
        var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / frame.maxH);
        var mcusPerColumn = Math.ceil(frame.scanLines / 8 / frame.maxV);

        for (var i = 0; i < frame.components.length; i++) {
          component = frame.components[i];
          var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / frame.maxH);
          var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / frame.maxV);
          var blocksPerLineForMcu = mcusPerLine * component.h;
          var blocksPerColumnForMcu = mcusPerColumn * component.v;
          var blocksBufferSize = 64 * blocksPerColumnForMcu * (blocksPerLineForMcu + 1);
          component.blockData = new Int16Array(blocksBufferSize);
          component.blocksPerLine = blocksPerLine;
          component.blocksPerColumn = blocksPerColumn;
        }

        frame.mcusPerLine = mcusPerLine;
        frame.mcusPerColumn = mcusPerColumn;
      }

      var offset = 0;
      var jfif = null;
      var adobe = null;
      var frame, resetInterval;
      var numSOSMarkers = 0;
      var quantizationTables = [];
      var huffmanTablesAC = [],
          huffmanTablesDC = [];
      var fileMarker = readUint16(data, offset);
      offset += 2;

      if (fileMarker !==
      /* SOI (Start of Image) = */
      0xffd8) {
        throw new JpegError("SOI not found");
      }

      fileMarker = readUint16(data, offset);
      offset += 2;

      markerLoop: while (fileMarker !==
      /* EOI (End of Image) = */
      0xffd9) {
        var i, j, l;

        switch (fileMarker) {
          case 0xffe0: // APP0 (Application Specific)

          case 0xffe1: // APP1

          case 0xffe2: // APP2

          case 0xffe3: // APP3

          case 0xffe4: // APP4

          case 0xffe5: // APP5

          case 0xffe6: // APP6

          case 0xffe7: // APP7

          case 0xffe8: // APP8

          case 0xffe9: // APP9

          case 0xffea: // APP10

          case 0xffeb: // APP11

          case 0xffec: // APP12

          case 0xffed: // APP13

          case 0xffee: // APP14

          case 0xffef: // APP15

          case 0xfffe:
            // COM (Comment)
            var appData = readDataBlock();

            if (fileMarker === 0xffe0) {
              // 'JFIF\x00'
              if (appData[0] === 0x4a && appData[1] === 0x46 && appData[2] === 0x49 && appData[3] === 0x46 && appData[4] === 0) {
                jfif = {
                  version: {
                    major: appData[5],
                    minor: appData[6]
                  },
                  densityUnits: appData[7],
                  xDensity: appData[8] << 8 | appData[9],
                  yDensity: appData[10] << 8 | appData[11],
                  thumbWidth: appData[12],
                  thumbHeight: appData[13],
                  thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                };
              }
            } // TODO APP1 - Exif


            if (fileMarker === 0xffee) {
              // 'Adobe'
              if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6f && appData[3] === 0x62 && appData[4] === 0x65) {
                adobe = {
                  version: appData[5] << 8 | appData[6],
                  flags0: appData[7] << 8 | appData[8],
                  flags1: appData[9] << 8 | appData[10],
                  transformCode: appData[11]
                };
              }
            }

            break;

          case 0xffdb:
            // DQT (Define Quantization Tables)
            var quantizationTablesLength = readUint16(data, offset);
            offset += 2;
            var quantizationTablesEnd = quantizationTablesLength + offset - 2;
            var z;

            while (offset < quantizationTablesEnd) {
              var quantizationTableSpec = data[offset++];
              var tableData = new Uint16Array(64);

              if (quantizationTableSpec >> 4 === 0) {
                // 8 bit values
                for (j = 0; j < 64; j++) {
                  z = dctZigZag[j];
                  tableData[z] = data[offset++];
                }
              } else if (quantizationTableSpec >> 4 === 1) {
                // 16 bit values
                for (j = 0; j < 64; j++) {
                  z = dctZigZag[j];
                  tableData[z] = readUint16(data, offset);
                  offset += 2;
                }
              } else {
                throw new JpegError("DQT - invalid table spec");
              }

              quantizationTables[quantizationTableSpec & 15] = tableData;
            }

            break;

          case 0xffc0: // SOF0 (Start of Frame, Baseline DCT)

          case 0xffc1: // SOF1 (Start of Frame, Extended DCT)

          case 0xffc2:
            // SOF2 (Start of Frame, Progressive DCT)
            if (frame) {
              throw new JpegError("Only single frame JPEGs supported");
            }

            offset += 2; // Skip marker length.

            frame = {};
            frame.extended = fileMarker === 0xffc1;
            frame.progressive = fileMarker === 0xffc2;
            frame.precision = data[offset++];
            var sofScanLines = readUint16(data, offset);
            offset += 2;
            frame.scanLines = dnlScanLines || sofScanLines;
            frame.samplesPerLine = readUint16(data, offset);
            offset += 2;
            frame.components = [];
            frame.componentIds = {};
            var componentsCount = data[offset++],
                componentId;
            var maxH = 0,
                maxV = 0;

            for (i = 0; i < componentsCount; i++) {
              componentId = data[offset];
              var h = data[offset + 1] >> 4;
              var v = data[offset + 1] & 15;

              if (maxH < h) {
                maxH = h;
              }

              if (maxV < v) {
                maxV = v;
              }

              var qId = data[offset + 2];
              l = frame.components.push({
                h: h,
                v: v,
                quantizationId: qId,
                quantizationTable: null // See comment below.

              });
              frame.componentIds[componentId] = l - 1;
              offset += 3;
            }

            frame.maxH = maxH;
            frame.maxV = maxV;
            prepareComponents(frame);
            break;

          case 0xffc4:
            // DHT (Define Huffman Tables)
            var huffmanLength = readUint16(data, offset);
            offset += 2;

            for (i = 2; i < huffmanLength;) {
              var huffmanTableSpec = data[offset++];
              var codeLengths = new Uint8Array(16);
              var codeLengthSum = 0;

              for (j = 0; j < 16; j++, offset++) {
                codeLengthSum += codeLengths[j] = data[offset];
              }

              var huffmanValues = new Uint8Array(codeLengthSum);

              for (j = 0; j < codeLengthSum; j++, offset++) {
                huffmanValues[j] = data[offset];
              }

              i += 17 + codeLengthSum;
              (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
            }

            break;

          case 0xffdd:
            // DRI (Define Restart Interval)
            offset += 2; // Skip marker length.

            resetInterval = readUint16(data, offset);
            offset += 2;
            break;

          case 0xffda:
            // SOS (Start of Scan)
            // A DNL marker (0xFFDC), if it exists, is only allowed at the end
            // of the first scan segment and may only occur once in an image.
            // Furthermore, to prevent an infinite loop, do *not* attempt to
            // parse DNL markers during re-parsing of the JPEG scan data.
            var parseDNLMarker = ++numSOSMarkers === 1 && !dnlScanLines;
            offset += 2; // Skip marker length.

            var selectorsCount = data[offset++];
            var components = [],
                component;

            for (i = 0; i < selectorsCount; i++) {
              var index = data[offset++];
              var componentIndex = frame.componentIds[index];
              component = frame.components[componentIndex];
              component.index = index;
              var tableSpec = data[offset++];
              component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
              component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
              components.push(component);
            }

            var spectralStart = data[offset++];
            var spectralEnd = data[offset++];
            var successiveApproximation = data[offset++];

            try {
              var processed = decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15, parseDNLMarker);
              offset += processed;
            } catch (ex) {
              if (ex instanceof DNLMarkerError) {
                warn("".concat(ex.message, " -- attempting to re-parse the JPEG image."));
                return this.parse(data, {
                  dnlScanLines: ex.scanLines
                });
              } else if (ex instanceof EOIMarkerError) {
                warn("".concat(ex.message, " -- ignoring the rest of the image data."));
                break markerLoop;
              }

              throw ex;
            }

            break;

          case 0xffdc:
            // DNL (Define Number of Lines)
            // Ignore the marker, since it's being handled in `decodeScan`.
            offset += 4;
            break;

          case 0xffff:
            // Fill bytes
            if (data[offset] !== 0xff) {
              // Avoid skipping a valid marker.
              offset--;
            }

            break;

          default:
            // Could be incorrect encoding -- the last 0xFF byte of the previous
            // block could have been eaten by the encoder, hence we fallback to
            // `startPos = offset - 3` when looking for the next valid marker.
            var nextFileMarker = findNextFileMarker(data,
            /* currentPos = */
            offset - 2,
            /* startPos = */
            offset - 3);

            if (nextFileMarker && nextFileMarker.invalid) {
              warn("JpegImage.parse - unexpected data, current marker is: " + nextFileMarker.invalid);
              offset = nextFileMarker.offset;
              break;
            }

            if (offset >= data.length - 1) {
              warn("JpegImage.parse - reached the end of the image data " + "without finding an EOI marker (0xFFD9).");
              break markerLoop;
            }

            throw new JpegError("JpegImage.parse - unknown marker: " + fileMarker.toString(16));
        }

        fileMarker = readUint16(data, offset);
        offset += 2;
      }

      this.width = frame.samplesPerLine;
      this.height = frame.scanLines;
      this.jfif = jfif;
      this.adobe = adobe;
      this.components = [];

      for (i = 0; i < frame.components.length; i++) {
        component = frame.components[i]; // Prevent errors when DQT markers are placed after SOF{n} markers,
        // by assigning the `quantizationTable` entry after the entire image
        // has been parsed (fixes issue7406.pdf).

        var quantizationTable = quantizationTables[component.quantizationId];

        if (quantizationTable) {
          component.quantizationTable = quantizationTable;
        }

        this.components.push({
          index: component.index,
          output: buildComponentData(frame, component),
          scaleX: component.h / frame.maxH,
          scaleY: component.v / frame.maxV,
          blocksPerLine: component.blocksPerLine,
          blocksPerColumn: component.blocksPerColumn
        });
      }

      this.numComponents = this.components.length;
      return undefined;
    },
    _getLinearizedBlockData: function _getLinearizedBlockData(width, height) {
      var isSourcePDF = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var scaleX = this.width / width,
          scaleY = this.height / height;
      var component, componentScaleX, componentScaleY, blocksPerScanline;
      var x, y, i, j, k;
      var index;
      var offset = 0;
      var output;
      var numComponents = this.components.length;
      var dataLength = width * height * numComponents;
      var data = new Uint8ClampedArray(dataLength);
      var xScaleBlockOffset = new Uint32Array(width);
      var mask3LSB = 0xfffffff8; // used to clear the 3 LSBs

      var lastComponentScaleX;

      for (i = 0; i < numComponents; i++) {
        component = this.components[i];
        componentScaleX = component.scaleX * scaleX;
        componentScaleY = component.scaleY * scaleY;
        offset = i;
        output = component.output;
        blocksPerScanline = component.blocksPerLine + 1 << 3; // Precalculate the `xScaleBlockOffset`. Since it doesn't depend on the
        // component data, that's only necessary when `componentScaleX` changes.

        if (componentScaleX !== lastComponentScaleX) {
          for (x = 0; x < width; x++) {
            j = 0 | x * componentScaleX;
            xScaleBlockOffset[x] = (j & mask3LSB) << 3 | j & 7;
          }

          lastComponentScaleX = componentScaleX;
        } // linearize the blocks of the component


        for (y = 0; y < height; y++) {
          j = 0 | y * componentScaleY;
          index = blocksPerScanline * (j & mask3LSB) | (j & 7) << 3;

          for (x = 0; x < width; x++) {
            data[offset] = output[index + xScaleBlockOffset[x]];
            offset += numComponents;
          }
        }
      } // decodeTransform contains pairs of multiplier (-256..256) and additive


      var transform = this._decodeTransform; // In PDF files, JPEG images with CMYK colour spaces are usually inverted
      // (this can be observed by extracting the raw image data).
      // Since the conversion algorithms (see below) were written primarily for
      // the PDF use-cases, attempting to use `JpegImage` to parse standalone
      // JPEG (CMYK) images may thus result in inverted images (see issue 9513).
      //
      // Unfortunately it's not (always) possible to tell, from the image data
      // alone, if it needs to be inverted. Thus in an attempt to provide better
      // out-of-box behaviour when `JpegImage` is used standalone, default to
      // inverting JPEG (CMYK) images if and only if the image data does *not*
      // come from a PDF file and no `decodeTransform` was passed by the user.

      if (!isSourcePDF && numComponents === 4 && !transform) {
        // prettier-ignore
        transform = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255]);
      }

      if (transform) {
        for (i = 0; i < dataLength;) {
          for (j = 0, k = 0; j < numComponents; j++, i++, k += 2) {
            data[i] = (data[i] * transform[k] >> 8) + transform[k + 1];
          }
        }
      }

      return data;
    },

    get _isColorConversionNeeded() {
      if (this.adobe) {
        // The adobe transform marker overrides any previous setting.
        return !!this.adobe.transformCode;
      }

      if (this.numComponents === 3) {
        if (this._colorTransform === 0) {
          // If the Adobe transform marker is not present and the image
          // dictionary has a 'ColorTransform' entry, explicitly set to `0`,
          // then the colours should *not* be transformed.
          return false;
        } else if (this.components[0].index ===
        /* "R" = */
        0x52 && this.components[1].index ===
        /* "G" = */
        0x47 && this.components[2].index ===
        /* "B" = */
        0x42) {
          // If the three components are indexed as RGB in ASCII
          // then the colours should *not* be transformed.
          return false;
        }

        return true;
      } // `this.numComponents !== 3`


      if (this._colorTransform === 1) {
        // If the Adobe transform marker is not present and the image
        // dictionary has a 'ColorTransform' entry, explicitly set to `1`,
        // then the colours should be transformed.
        return true;
      }

      return false;
    },

    _convertYccToRgb: function convertYccToRgb(data) {
      var Y, Cb, Cr;

      for (var i = 0, length = data.length; i < length; i += 3) {
        Y = data[i];
        Cb = data[i + 1];
        Cr = data[i + 2];
        data[i] = Y - 179.456 + 1.402 * Cr;
        data[i + 1] = Y + 135.459 - 0.344 * Cb - 0.714 * Cr;
        data[i + 2] = Y - 226.816 + 1.772 * Cb;
      }

      return data;
    },
    _convertYcckToRgb: function convertYcckToRgb(data) {
      var Y, Cb, Cr, k;
      var offset = 0;

      for (var i = 0, length = data.length; i < length; i += 4) {
        Y = data[i];
        Cb = data[i + 1];
        Cr = data[i + 2];
        k = data[i + 3];
        data[offset++] = -122.67195406894 + Cb * (-6.60635669420364e-5 * Cb + 0.000437130475926232 * Cr - 5.4080610064599e-5 * Y + 0.00048449797120281 * k - 0.154362151871126) + Cr * (-0.000957964378445773 * Cr + 0.000817076911346625 * Y - 0.00477271405408747 * k + 1.53380253221734) + Y * (0.000961250184130688 * Y - 0.00266257332283933 * k + 0.48357088451265) + k * (-0.000336197177618394 * k + 0.484791561490776);
        data[offset++] = 107.268039397724 + Cb * (2.19927104525741e-5 * Cb - 0.000640992018297945 * Cr + 0.000659397001245577 * Y + 0.000426105652938837 * k - 0.176491792462875) + Cr * (-0.000778269941513683 * Cr + 0.00130872261408275 * Y + 0.000770482631801132 * k - 0.151051492775562) + Y * (0.00126935368114843 * Y - 0.00265090189010898 * k + 0.25802910206845) + k * (-0.000318913117588328 * k - 0.213742400323665);
        data[offset++] = -20.810012546947 + Cb * (-0.000570115196973677 * Cb - 2.63409051004589e-5 * Cr + 0.0020741088115012 * Y - 0.00288260236853442 * k + 0.814272968359295) + Cr * (-1.53496057440975e-5 * Cr - 0.000132689043961446 * Y + 0.000560833691242812 * k - 0.195152027534049) + Y * (0.00174418132927582 * Y - 0.00255243321439347 * k + 0.116935020465145) + k * (-0.000343531996510555 * k + 0.24165260232407);
      } // Ensure that only the converted RGB data is returned.


      return data.subarray(0, offset);
    },
    _convertYcckToCmyk: function convertYcckToCmyk(data) {
      var Y, Cb, Cr;

      for (var i = 0, length = data.length; i < length; i += 4) {
        Y = data[i];
        Cb = data[i + 1];
        Cr = data[i + 2];
        data[i] = 434.456 - Y - 1.402 * Cr;
        data[i + 1] = 119.541 - Y + 0.344 * Cb + 0.714 * Cr;
        data[i + 2] = 481.816 - Y - 1.772 * Cb; // K in data[i + 3] is unchanged
      }

      return data;
    },
    _convertCmykToRgb: function convertCmykToRgb(data) {
      var c, m, y, k;
      var offset = 0;

      for (var i = 0, length = data.length; i < length; i += 4) {
        c = data[i];
        m = data[i + 1];
        y = data[i + 2];
        k = data[i + 3];
        data[offset++] = 255 + c * (-0.00006747147073602441 * c + 0.0008379262121013727 * m + 0.0002894718188643294 * y + 0.003264231057537806 * k - 1.1185611867203937) + m * (0.000026374107616089405 * m - 0.00008626949158638572 * y - 0.0002748769067499491 * k - 0.02155688794978967) + y * (-0.00003878099212869363 * y - 0.0003267808279485286 * k + 0.0686742238595345) - k * (0.0003361971776183937 * k + 0.7430659151342254);
        data[offset++] = 255 + c * (0.00013596372813588848 * c + 0.000924537132573585 * m + 0.00010567359618683593 * y + 0.0004791864687436512 * k - 0.3109689587515875) + m * (-0.00023545346108370344 * m + 0.0002702845253534714 * y + 0.0020200308977307156 * k - 0.7488052167015494) + y * (0.00006834815998235662 * y + 0.00015168452363460973 * k - 0.09751927774728933) - k * (0.00031891311758832814 * k + 0.7364883807733168);
        data[offset++] = 255 + c * (0.000013598650411385307 * c + 0.00012423956175490851 * m + 0.0004751985097583589 * y - 0.0000036729317476630422 * k - 0.05562186980264034) + m * (0.00016141380598724676 * m + 0.0009692239130725186 * y + 0.0007782692450036253 * k - 0.44015232367526463) + y * (5.068882914068769e-7 * y + 0.0017778369011375071 * k - 0.7591454649749609) - k * (0.0003435319965105553 * k + 0.7063770186160144);
      } // Ensure that only the converted RGB data is returned.


      return data.subarray(0, offset);
    },
    getData: function getData(_ref3) {
      var width = _ref3.width,
          height = _ref3.height,
          _ref3$forceRGB = _ref3.forceRGB,
          forceRGB = _ref3$forceRGB === void 0 ? false : _ref3$forceRGB,
          _ref3$isSourcePDF = _ref3.isSourcePDF,
          isSourcePDF = _ref3$isSourcePDF === void 0 ? false : _ref3$isSourcePDF;

      if (this.numComponents > 4) {
        throw new JpegError("Unsupported color mode");
      } // Type of data: Uint8ClampedArray(width * height * numComponents)


      var data = this._getLinearizedBlockData(width, height, isSourcePDF);

      if (this.numComponents === 1 && forceRGB) {
        var dataLength = data.length;
        var rgbData = new Uint8ClampedArray(dataLength * 3);
        var offset = 0;

        for (var i = 0; i < dataLength; i++) {
          var grayColor = data[i];
          rgbData[offset++] = grayColor;
          rgbData[offset++] = grayColor;
          rgbData[offset++] = grayColor;
        }

        return rgbData;
      } else if (this.numComponents === 3 && this._isColorConversionNeeded) {
        return this._convertYccToRgb(data);
      } else if (this.numComponents === 4) {
        if (this._isColorConversionNeeded) {
          if (forceRGB) {
            return this._convertYcckToRgb(data);
          }

          return this._convertYcckToCmyk(data);
        } else if (forceRGB) {
          return this._convertCmykToRgb(data);
        }
      }

      return data;
    }
  };
  return JpegImage;
}();

exports.JpegImage = JpegImage;

},{}],57:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _default;

function _default(self) {
  var decode = require('./decode');

  self.onmessage = function (_ref) {
    var msg = _ref.data;
    decode(msg.buf, msg.options, function (err, result) {
      if (err) {
        var errValue = err instanceof Error ? err.message : err; // Error is not clonable

        self.postMessage({
          err: errValue
        });
      } else {
        self.postMessage({
          result: result
        });
      }
    });
  };
}

;
module.exports = exports.default;

},{"./decode":58}],58:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = decode;

var _jpg = require("./backend/jpg");

var _color = require("./util/color");

/**
 * Decode the JPEG data
 *
 * @param buf ArrayLike data structure
 * @param options Object { width: number, height: number }
 * @param cb Callback to invoke on completion
 *
 * @callback { width: number, height: number, data: Uint8Array }
 */
function decode(buf, options, cb) {
  // returns: Uint8ClampedArray(width * height * numComponents)
  function getData(j, width, height) {
    var opts = {
      width: width,
      height: height,
      forceRGB: true,
      isSourcePDF: false
    };
    return j.getData(opts);
  }

  try {
    var j = new _jpg.JpegImage();
    j.parse(buf);
    var width = options.width || j.width;
    var height = options.height || j.height;
    var rgbData = getData(j, width, height); // NOTE: each color is RGB without alpha-channel

    var rgbaData = (0, _color.arrayLikeRgbToRgba)(rgbData); // NOTE: convert to RGBA

    var result = {
      width: width,
      height: height,
      data: rgbaData
    };
    cb(null, result);
  } catch (err) {
    cb(err);
  }
}

module.exports = exports.default;

},{"./backend/jpg":56,"./util/color":68}],59:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _default;

function _default(self) {
  var encode = require('./encode');

  self.onmessage = function (_ref) {
    var msg = _ref.data;
    encode(msg.buf, msg.options, function (err, result) {
      if (err) {
        var errValue = err instanceof Error ? err.message : err; // Error is not clonable

        self.postMessage({
          err: errValue
        });
      } else {
        self.postMessage({
          result: result
        });
      }
    });
  };
}

;
module.exports = exports.default;

},{"./encode":60}],60:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = encode;

var _jpgEncode = require("./backend/jpg-encode");

/**
 * Encode the data to JPEG format
 *
 * @param buf Buffer|Uint8Array
 * @param options Object { width: number, height: number, quality: number }
 * @param cb Callback to invoke on completion
 *
 * @callback { width: number, height: number, data: Uint8Array }
 */
function encode(buf, options, cb) {
  try {
    var encoder = new _jpgEncode.JPEGEncoder(options.quality);
    var opts = {
      data: buf,
      width: options.width,
      height: options.height
    };
    var encoded = encoder.encode(opts);
    var result = {
      data: encoded,
      width: options.width,
      height: options.height
    };
    cb(null, result);
  } catch (err) {
    cb(err);
  }
}

module.exports = exports.default;

},{"./backend/jpg-encode":55}],61:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _default;

function _default(self) {
  var exif = require('./exif');

  self.onmessage = function (_ref) {
    var msg = _ref.data;
    exif(msg.buf, {}, function (err, result) {
      if (err) {
        var errValue = err instanceof Error ? err.message : err; // Error is not clonable

        self.postMessage({
          err: errValue
        });
      } else {
        self.postMessage({
          result: result
        });
      }
    });
  };
}

;
module.exports = exports.default;

},{"./exif":62}],62:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exif;

var _exifReader = _interopRequireDefault(require("./backend/exif-reader"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * Read EXIF data from the provided buffer
 *
 * @param buf ArrayBuffer
 * @param options Object { hasMakerNote: true|false }
 * @param cb Callback to invoke on completion
 *
 * @callback Object { name: value, ... }
 */
function exif(buf, options, cb) {
  try {
    var tags = _exifReader["default"].load(buf); // The MakerNote tag can be really large. Remove it to lower memory usage.


    delete tags['MakerNote'];
    cb(null, tags);
  } catch (err) {
    if (err.message === 'No Exif data') {
      cb(null, {});
    } else {
      cb(err);
    }
  }
}

module.exports = exports.default;

},{"./backend/exif-reader":54}],63:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasWorker = void 0;
var hasWorker = typeof window !== 'undefined' && 'Worker' in window;
exports.hasWorker = hasWorker;

if (hasWorker) {
  try {
    var w = require('webworkify')(function () {});

    w.terminate();
  } catch (e) {
    exports.hasWorker = hasWorker = false;
  }
}

},{"webworkify":52}],64:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = info;

var _imageinfo = _interopRequireDefault(require("imageinfo"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * Get image information
 * @param {Buffer} buf Image or image part that contains image parameters
 * @param {function} cb Callback to invoke on completion
 */
function info(buf, cb) {
  setTimeout(function () {
    var info = (0, _imageinfo["default"])(buf);

    if (!info) {
      cb(new Error('Cannot get image info'));
    } else {
      cb(null, {
        type: info.type,
        mimeType: info.mimeType,
        extension: info.format.toLowerCase(),
        width: info.width,
        height: info.height
      });
    }
  }, 0);
}

module.exports = exports.default;

},{"imageinfo":13}],65:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _default = {
  "474946383961": {
    "mimeType": "image/gif",
    "extension": "gif"
  },
  "474946383761": {
    "mimeType": "image/gif",
    "extension": "gif"
  },
  "89504e470d0a1a0a": {
    "mimeType": "image/png",
    "extension": "png"
  },
  "ffd8ff": {
    "mimeType": "image/jpeg",
    "extension": "jpg"
  },
  "57454250": {
    "mimeType": "image/webp",
    "extension": "webp"
  },
  "49492a00": {
    "mimeType": "image/tiff",
    "extension": "tiff"
  },
  "4d4d002a": {
    "mimeType": "image/tiff",
    "extension": "tiff"
  },
  "424d": {
    "mimeType": "image/bmp",
    "extension": "bmp"
  },
  "000000146674797069736f6d": {
    "mimeType": "video/mp4",
    "extension": "mp4"
  },
  "000000186674797033677035": {
    "mimeType": "video/mp4",
    "extension": "mp4"
  },
  "000000146674797071742020": {
    "mimeType": "video/quicktime",
    "extension": "mov"
  },
  "1a45dfa3": {
    "mimeType": "video/webm",
    "extension": "webm"
  },
  "25504446": {
    "mimeType": "application/pdf",
    "extension": "pdf"
  }
};
exports["default"] = _default;
module.exports = exports.default;

},{}],66:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = magic;

var _magicDb = _interopRequireDefault(require("./magic-db"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * Lookup the magic number in magic-number DB
 * @param {Buffer} buf Data buffer
 * @param {function} cb Callback to invoke on completion
 */
function magic(buf, cb) {
  setTimeout(function () {
    var sampleLength = 24;
    var sample = buf.slice(0, sampleLength).toString('hex'); // lookup data

    var found = Object.keys(_magicDb["default"]).find(function (it) {
      return sample.indexOf(it) !== -1;
    });

    if (found) {
      cb(null, _magicDb["default"][found]);
    } else {
      cb(new Error('Magic number not found'));
    }
  }, 0);
}

module.exports = exports.default;

},{"./magic-db":65}],67:[function(require,module,exports){
(function (Buffer){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toBuffer = toBuffer;
exports.toArrayBuffer = toArrayBuffer;
exports.toArrayLike = toArrayLike;

/**
 * Converts the buffer to Buffer
 * @param {Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray} buf Input buffer
 * @returns {Buffer}
 */
function toBuffer(buf) {
  if (buf instanceof ArrayBuffer) {
    return arrayBufferToBuffer(buf);
  } else if (Buffer.isBuffer(buf)) {
    return buf;
  } else if (buf instanceof Uint8Array || buf instanceof Uint8ClampedArray) {
    return Buffer.from(buf);
  } else {
    return buf; // type unknown, trust the user
  }
}
/**
 * Converts any buffer to ArrayBuffer
 * @param {Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray} buf Input buffer
 * @returns {ArrayBuffer}
 */


function toArrayBuffer(buf) {
  if (buf instanceof ArrayBuffer) {
    return buf;
  } else if (Buffer.isBuffer(buf)) {
    return arrayLikeToArrayBuffer(buf);
  } else if (buf instanceof Uint8Array || buf instanceof Uint8ClampedArray) {
    return arrayLikeToArrayBuffer(buf);
  } else {
    return buf; // type unknown, trust the user
  }
}
/**
 * Convert any buffer to array-like type: Uint8Array|Uint8ClampedArray|Buffer
 * @param {Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray} buf
 * @returns {Buffer|Uint8Array}
 */


function toArrayLike(buf) {
  if (buf instanceof Uint8Array || buf instanceof Uint8ClampedArray) {
    return buf;
  } else if (buf instanceof ArrayBuffer) {
    return new Uint8Array(buf);
  } else if (Buffer.isBuffer(buf)) {
    return buf;
  } else {
    return buf; // type unknown, trust the user
  }
}
/**
 * Converts Buffer to ArrayBuffer
 *
 * NOTE: we cannot convert Buffer to ArrayBuffer via `buf.buffer` since the size of the returned ArrayBuffer might be biger than the actual.
 *
 * @param {Buffer|Uint8Array|Uint8ClampedArray} buf
 * @returns {ArrayBuffer}
 */


function arrayLikeToArrayBuffer(buf) {
  var arrBuf = new ArrayBuffer(buf.length);
  var view = new Uint8Array(arrBuf);

  for (var i = 0; i < buf.length; ++i) {
    view[i] = buf[i];
  }

  return arrBuf;
}
/**
 * Convert ArrayBuffer to Buffer
 * @param {ArrayBuffer} arrBuf
 * @returns {Buffer}
 */


function arrayBufferToBuffer(arrBuf) {
  return Buffer.from(new Uint8Array(arrBuf));
}

}).call(this,require("buffer").Buffer)

},{"buffer":9}],68:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.arrayLikeRgbToRgba = arrayLikeRgbToRgba;

/**
 * Converts a buffer of RGB components to RGBA.
 *
 * @param buf {Buffer|Uint8Array|Uint8ClampedArray} array-like structure with RGB data
 */
function arrayLikeRgbToRgba(buf) {
  var filler = 0xFF;
  var result = new Uint8Array(buf.length / 3 * 4);

  for (var i = 0, p = 0; i < buf.length; i += 3) {
    result[p++] = buf[i];
    result[p++] = buf[i + 1];
    result[p++] = buf[i + 2];
    result[p++] = filler;
  }

  return result;
}

},{}],69:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _hasWorker = require("./lib/has-worker");

var bufferUtils = _interopRequireWildcard(require("./lib/util/buffer"));

var _exif = _interopRequireDefault(require("./lib/exif"));

var _decode = _interopRequireDefault(require("./lib/decode"));

var _encode = _interopRequireDefault(require("./lib/encode"));

var _magic = _interopRequireDefault(require("./lib/magic"));

var _info = _interopRequireDefault(require("./lib/info"));

var _exifWorker = _interopRequireDefault(require("./lib/exif-worker"));

var _decodeWorker = _interopRequireDefault(require("./lib/decode-worker"));

var _encodeWorker = _interopRequireDefault(require("./lib/encode-worker"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Decode
 *
 * @param {Buffer|ArrayBuffer|Uint8Array} buf
 * @param {object} options Params: { width: number, height: number }
 * @param {function} cb Callback to invoke on completion
 *
 * @callback { width: number, height: number, data: Uint8Array }
 */
function decodeBuffer(buf, options, cb) {
  if (typeof options === 'function') {
    cb = options;
    options = {};
  }

  try {
    buf = bufferUtils.toArrayLike(buf);

    if (_hasWorker.hasWorker) {
      var wr = require('webworkify')(_decodeWorker["default"]);

      wr.onmessage = function (_ref) {
        var msg = _ref.data;
        var err = msg.err ? new Error(msg.err) : undefined;
        cb(err, msg.result);
      };

      var msg = {
        buf: buf,
        options: options
      };

      if (options.transferable) {
        wr.postMessage(msg, [buf]);
      } else {
        wr.postMessage(msg);
      }
    } else {
      (0, _decode["default"])(buf, options, cb);
    }
  } catch (err) {
    cb(err);
  }
}
/**
 * Encode
 *
 * @param {Buffer|ArrayBuffer|Uint8Array} buf
 * @param {object} options Params { width: number, height: number, quality: number }
 * @param {function} cb Callback to invoke on completion
 *
 * @callback { width: number, height: number, data: Uint8Array }
 */


function encodeBuffer(buf, options, cb) {
  if (typeof options === 'function') {
    cb = options;
    options = {};
  }

  try {
    buf = bufferUtils.toArrayLike(buf);

    if (!options.hasOwnProperty('width') || !options.hasOwnProperty('height')) {
      return cb(new Error('Width & height of the buffer is not provided.'));
    }

    if (_hasWorker.hasWorker) {
      var wr = require('webworkify')(_encodeWorker["default"]);

      wr.onmessage = function (_ref2) {
        var msg = _ref2.data;
        var err = msg.err ? new Error(msg.err) : undefined;
        cb(err, msg.result);
      };

      var msg = {
        buf: buf,
        options: options
      };

      if (options.transferable) {
        wr.postMessage(msg, [buf]);
      } else {
        wr.postMessage(msg);
      }
    } else {
      (0, _encode["default"])(buf, options, cb);
    }
  } catch (err) {
    cb(err);
  }
}
/**
 * Get EXIF
 *
 * @param {Buffer|ArrayBuffer|Uint8Array} buf
 * @param {object} options Params { hasMakerNote: true|false }
 * @param {function} cb Callback to invoke on completion
 *
 * @callback Object { name: value, ... }
 */


function exifBuffer(buf, options, cb) {
  if (typeof options === 'function') {
    cb = options;
    options = {};
  }

  try {
    buf = bufferUtils.toArrayBuffer(buf);

    if (_hasWorker.hasWorker) {
      var wr = require('webworkify')(_exifWorker["default"]);

      wr.onmessage = function (_ref3) {
        var msg = _ref3.data;
        var err = msg.err ? new Error(msg.err) : undefined;
        cb(err, msg.result);
      };

      var msg = {
        buf: buf
      };

      if (options.transferable) {
        wr.postMessage(msg, [buf]);
      } else {
        wr.postMessage(msg);
      }
    } else {
      (0, _exif["default"])(buf, options, cb);
    }
  } catch (err) {
    cb(err);
  }
}
/**
 * Detect mime-type for the Buffer
 * @param {Buffer|ArrayBuffer|Uint8Array} buf Data buffer
 * @param {function} cb Callback to invoke on completion
 */


function magicBuffer(buf, cb) {
  try {
    buf = bufferUtils.toBuffer(buf);
    (0, _magic["default"])(buf, cb);
  } catch (err) {
    cb(err);
  }
}
/**
 * Get image information without reading and decoding a file
 * @param {Buffer|ArrayBuffer|Uint8Array} buf Data buffer
 * @param {function} cb Callback to invoke on completion
 */


function infoBuffer(buf, cb) {
  try {
    buf = bufferUtils.toBuffer(buf);
    (0, _info["default"])(buf, cb);
  } catch (err) {
    cb(err);
  }
}

var _default = {
  decode: decodeBuffer,
  encode: encodeBuffer,
  exif: exifBuffer,
  magic: magicBuffer,
  info: infoBuffer
};
exports["default"] = _default;
module.exports = exports.default;

},{"./lib/decode":58,"./lib/decode-worker":57,"./lib/encode":60,"./lib/encode-worker":59,"./lib/exif":62,"./lib/exif-worker":61,"./lib/has-worker":63,"./lib/info":64,"./lib/magic":66,"./lib/util/buffer":67,"webworkify":52}]},{},[53])(53)
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYXNzZXJ0L2Fzc2VydC5qcyIsIm5vZGVfbW9kdWxlcy9hc3NlcnQvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYXNzZXJ0L25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Fzc2VydC9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL2xpYi9iaW5kaW5nLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktemxpYi9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtdXRpbC1pcy9saWIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaW1hZ2VpbmZvL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvaXMtYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9jb21tb24uanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9hZGxlcjMyLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY3JjMzIuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9kZWZsYXRlLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mZmFzdC5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmxhdGUuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZ0cmVlcy5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL21lc3NhZ2VzLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvdHJlZXMuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi96c3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MtbmV4dGljay1hcmdzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0tYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9saWIvc3RyaW5nX2RlY29kZXIuanMiLCJub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIm5vZGVfbW9kdWxlcy91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy93ZWJ3b3JraWZ5L2luZGV4LmpzIiwic3JjL2luZGV4LmpzIiwic3JjL2xpYi9iYWNrZW5kL2V4aWYtcmVhZGVyLmpzIiwic3JjL2xpYi9iYWNrZW5kL2pwZy1lbmNvZGUuanMiLCJzcmMvbGliL2JhY2tlbmQvanBnLmpzIiwic3JjL2xpYi9kZWNvZGUtd29ya2VyLmpzIiwic3JjL2xpYi9kZWNvZGUuanMiLCJzcmMvbGliL2VuY29kZS13b3JrZXIuanMiLCJzcmMvbGliL2VuY29kZS5qcyIsInNyYy9saWIvZXhpZi13b3JrZXIuanMiLCJzcmMvbGliL2V4aWYuanMiLCJzcmMvbGliL2hhcy13b3JrZXIuanMiLCJzcmMvbGliL2luZm8uanMiLCJzcmMvbGliL21hZ2ljLWRiLmpzIiwic3JjL2xpYi9tYWdpYy5qcyIsInNyYy9saWIvdXRpbC9idWZmZXIuanMiLCJzcmMvbGliL3V0aWwvY29sb3IuanMiLCJzcmMvbWFpbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3haQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaG1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2p2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2dCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3RPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2wxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0c0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdlNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQVY7QUFDQSxNQUFBLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBVjtBQUNBLE1BQUEsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFWO0FBQ0EsTUFBQSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQVY7QUFDQSxNQUFBLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBVjtBQUNBLE1BQUEsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFWLENBM0VnQyxDQTZFaEM7O0FBQ0EsVUFBSSxFQUFFLEdBQUcsRUFBVCxFQUFhO0FBQ1gsUUFBQSxFQUFFLEdBQUcsQ0FBTDtBQUNELE9BRkQsTUFFTyxJQUFJLEVBQUUsSUFBSSxJQUFWLEVBQWdCO0FBQ3JCLFFBQUEsRUFBRSxHQUFHLEdBQUw7QUFDRCxPQUZNLE1BRUE7QUFDTCxRQUFBLEVBQUUsS0FBSyxDQUFQO0FBQ0Q7O0FBQ0QsVUFBSSxFQUFFLEdBQUcsRUFBVCxFQUFhO0FBQ1gsUUFBQSxFQUFFLEdBQUcsQ0FBTDtBQUNELE9BRkQsTUFFTyxJQUFJLEVBQUUsSUFBSSxJQUFWLEVBQWdCO0FBQ3JCLFFBQUEsRUFBRSxHQUFHLEdBQUw7QUFDRCxPQUZNLE1BRUE7QUFDTCxRQUFBLEVBQUUsS0FBSyxDQUFQO0FBQ0Q7O0FBQ0QsVUFBSSxFQUFFLEdBQUcsRUFBVCxFQUFhO0FBQ1gsUUFBQSxFQUFFLEdBQUcsQ0FBTDtBQUNELE9BRkQsTUFFTyxJQUFJLEVBQUUsSUFBSSxJQUFWLEVBQWdCO0FBQ3JCLFFBQUEsRUFBRSxHQUFHLEdBQUw7QUFDRCxPQUZNLE1BRUE7QUFDTCxRQUFBLEVBQUUsS0FBSyxDQUFQO0FBQ0Q7O0FBQ0QsVUFBSSxFQUFFLEdBQUcsRUFBVCxFQUFhO0FBQ1gsUUFBQSxFQUFFLEdBQUcsQ0FBTDtBQUNELE9BRkQsTUFFTyxJQUFJLEVBQUUsSUFBSSxJQUFWLEVBQWdCO0FBQ3JCLFFBQUEsRUFBRSxHQUFHLEdBQUw7QUFDRCxPQUZNLE1BRUE7QUFDTCxRQUFBLEVBQUUsS0FBSyxDQUFQO0FBQ0Q7O0FBQ0QsVUFBSSxF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QXFCLEdBQXJCLENBQU47QUFDQSwyQkFBTSxHQUFOLEVBQVcsRUFBWDtBQUNELEdBSEQsQ0FHRSxPQUFNLEdBQU4sRUFBVztBQUNYLElBQUEsRUFBRSxDQUFDLEdBQUQsQ0FBRjtBQUNEO0FBQ0Y7QUFFRDs7Ozs7OztBQUtBLFNBQVMsVUFBVCxDQUFvQixHQUFwQixFQUF5QixFQUF6QixFQUE2QjtBQUMzQixNQUFJO0FBQ0YsSUFBQSxHQUFHLEdBQUcsV0FBVyxDQUFDLFFBQVosQ0FBcUIsR0FBckIsQ0FBTjtBQUNBLDBCQUFLLEdBQUwsRUFBVSxFQUFWO0FBQ0QsR0FIRCxDQUdFLE9BQU0sR0FBTixFQUFXO0FBQ1gsSUFBQSxFQUFFLENBQUMsR0FBRCxDQUFGO0FBQ0Q7QUFDRjs7ZUFHYztBQUNiLEVBQUEsTUFBTSxFQUFFLFlBREs7QUFFYixFQUFBLE1BQU0sRUFBRSxZQUZLO0FBR2IsRUFBQSxJQUFJLEVBQUUsVUFITztBQUliLEVBQUEsS0FBSyxFQUFFLFdBSk07QUFLYixFQUFBLElBQUksRUFBRTtBQUxPLEMiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIndXNlIHN0cmljdCc7XG5cbnZhciBvYmplY3RBc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbi8vIGNvbXBhcmUgYW5kIGlzQnVmZmVyIHRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvYmxvYi82ODBlOWU1ZTQ4OGYyMmFhYzI3NTk5YTU3ZGM4NDRhNjMxNTkyOGRkL2luZGV4LmpzXG4vLyBvcmlnaW5hbCBub3RpY2U6XG5cbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHggPSBhLmxlbmd0aDtcbiAgdmFyIHkgPSBiLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXTtcbiAgICAgIHkgPSBiW2ldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGlmICh5IDwgeCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gaXNCdWZmZXIoYikge1xuICBpZiAoZ2xvYmFsLkJ1ZmZlciAmJiB0eXBlb2YgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKGIpO1xuICB9XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpO1xufVxuXG4vLyBiYXNlZCBvbiBub2RlIGFzc2VydCwgb3JpZ2luYWwgbm90aWNlOlxuLy8gTkI6IFRoZSBVUkwgdG8gdGhlIENvbW1vbkpTIHNwZWMgaXMga2VwdCBqdXN0IGZvciB0cmFkaXRpb24uXG4vLyAgICAgbm9kZS1hc3NlcnQgaGFzIGV2b2x2ZWQgYSBsb3Qgc2luY2UgdGhlbiwgYm90aCBpbiBBUEkgYW5kIGJlaGF2aW9yLlxuXG4vLyBodHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Vbml0X1Rlc3RpbmcvMS4wXG4vL1xuLy8gVEhJUyBJUyBOT1QgVEVTVEVEIE5PUiBMSUtFTFkgVE8gV09SSyBPVVRTSURFIFY4IVxuLy9cbi8vIE9yaWdpbmFsbHkgZnJvbSBuYXJ3aGFsLmpzIChodHRwOi8vbmFyd2hhbGpzLm9yZylcbi8vIENvcHlyaWdodCAoYykgMjAwOSBUaG9tYXMgUm9iaW5zb24gPDI4MG5vcnRoLmNvbT5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsLycpO1xudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGZ1bmN0aW9uc0hhdmVOYW1lcyA9IChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmb28oKSB7fS5uYW1lID09PSAnZm9vJztcbn0oKSk7XG5mdW5jdGlvbiBwVG9TdHJpbmcgKG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG59XG5mdW5jdGlvbiBpc1ZpZXcoYXJyYnVmKSB7XG4gIGlmIChpc0J1ZmZlcihhcnJidWYpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgZ2xvYmFsLkFycmF5QnVmZmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyhhcnJidWYpO1xuICB9XG4gIGlmICghYXJyYnVmKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChhcnJidWYgaW5zdGFuY2VvZiBEYXRhVmlldykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChhcnJidWYuYnVmZmVyICYmIGFycmJ1Zi5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbi8vIDEuIFRoZSBhc3NlcnQgbW9kdWxlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0aGF0IHRocm93XG4vLyBBc3NlcnRpb25FcnJvcidzIHdoZW4gcGFydGljdWxhciBjb25kaXRpb25zIGFyZSBub3QgbWV0LiBUaGVcbi8vIGFzc2VydCBtb2R1bGUgbXVzdCBjb25mb3JtIHRvIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlLlxuXG52YXIgYXNzZXJ0ID0gbW9kdWxlLmV4cG9ydHMgPSBvaztcblxuLy8gMi4gVGhlIEFzc2VydGlvbkVycm9yIGlzIGRlZmluZWQgaW4gYXNzZXJ0LlxuLy8gbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7IG1lc3NhZ2U6IG1lc3NhZ2UsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkIH0pXG5cbnZhciByZWdleCA9IC9cXHMqZnVuY3Rpb25cXHMrKFteXFwoXFxzXSopXFxzKi87XG4vLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL2Z1bmN0aW9uLnByb3RvdHlwZS5uYW1lL2Jsb2IvYWRlZWVlYzhiZmNjNjA2OGIxODdkN2Q5ZmIzZDViYjFkM2EzMDg5OS9pbXBsZW1lbnRhdGlvbi5qc1xuZnVuY3Rpb24gZ2V0TmFtZShmdW5jKSB7XG4gIGlmICghdXRpbC5pc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChmdW5jdGlvbnNIYXZlTmFtZXMpIHtcbiAgICByZXR1cm4gZnVuYy5uYW1lO1xuICB9XG4gIHZhciBzdHIgPSBmdW5jLnRvU3RyaW5nKCk7XG4gIHZhciBtYXRjaCA9IHN0ci5tYXRjaChyZWdleCk7XG4gIHJldHVybiBtYXRjaCAmJiBtYXRjaFsxXTtcbn1cbmFzc2VydC5Bc3NlcnRpb25FcnJvciA9IGZ1bmN0aW9uIEFzc2VydGlvbkVycm9yKG9wdGlvbnMpIHtcbiAgdGhpcy5uYW1lID0gJ0Fzc2VydGlvbkVycm9yJztcbiAgdGhpcy5hY3R1YWwgPSBvcHRpb25zLmFjdHVhbDtcbiAgdGhpcy5leHBlY3RlZCA9IG9wdGlvbnMuZXhwZWN0ZWQ7XG4gIHRoaXMub3BlcmF0b3IgPSBvcHRpb25zLm9wZXJhdG9yO1xuICBpZiAob3B0aW9ucy5tZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlO1xuICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubWVzc2FnZSA9IGdldE1lc3NhZ2UodGhpcyk7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gdHJ1ZTtcbiAgfVxuICB2YXIgc3RhY2tTdGFydEZ1bmN0aW9uID0gb3B0aW9ucy5zdGFja1N0YXJ0RnVuY3Rpb24gfHwgZmFpbDtcbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgc3RhY2tTdGFydEZ1bmN0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBub24gdjggYnJvd3NlcnMgc28gd2UgY2FuIGhhdmUgYSBzdGFja3RyYWNlXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcigpO1xuICAgIGlmIChlcnIuc3RhY2spIHtcbiAgICAgIHZhciBvdXQgPSBlcnIuc3RhY2s7XG5cbiAgICAgIC8vIHRyeSB0byBzdHJpcCB1c2VsZXNzIGZyYW1lc1xuICAgICAgdmFyIGZuX25hbWUgPSBnZXROYW1lKHN0YWNrU3RhcnRGdW5jdGlvbik7XG4gICAgICB2YXIgaWR4ID0gb3V0LmluZGV4T2YoJ1xcbicgKyBmbl9uYW1lKTtcbiAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAvLyBvbmNlIHdlIGhhdmUgbG9jYXRlZCB0aGUgZnVuY3Rpb24gZnJhbWVcbiAgICAgICAgLy8gd2UgbmVlZCB0byBzdHJpcCBvdXQgZXZlcnl0aGluZyBiZWZvcmUgaXQgKGFuZCBpdHMgbGluZSlcbiAgICAgICAgdmFyIG5leHRfbGluZSA9IG91dC5pbmRleE9mKCdcXG4nLCBpZHggKyAxKTtcbiAgICAgICAgb3V0ID0gb3V0LnN1YnN0cmluZyhuZXh0X2xpbmUgKyAxKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGFjayA9IG91dDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGFzc2VydC5Bc3NlcnRpb25FcnJvciBpbnN0YW5jZW9mIEVycm9yXG51dGlsLmluaGVyaXRzKGFzc2VydC5Bc3NlcnRpb25FcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiB0cnVuY2F0ZShzLCBuKSB7XG4gIGlmICh0eXBlb2YgcyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPCBuID8gcyA6IHMuc2xpY2UoMCwgbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cbmZ1bmN0aW9uIGluc3BlY3Qoc29tZXRoaW5nKSB7XG4gIGlmIChmdW5jdGlvbnNIYXZlTmFtZXMgfHwgIXV0aWwuaXNGdW5jdGlvbihzb21ldGhpbmcpKSB7XG4gICAgcmV0dXJuIHV0aWwuaW5zcGVjdChzb21ldGhpbmcpO1xuICB9XG4gIHZhciByYXduYW1lID0gZ2V0TmFtZShzb21ldGhpbmcpO1xuICB2YXIgbmFtZSA9IHJhd25hbWUgPyAnOiAnICsgcmF3bmFtZSA6ICcnO1xuICByZXR1cm4gJ1tGdW5jdGlvbicgKyAgbmFtZSArICddJztcbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2Uoc2VsZikge1xuICByZXR1cm4gdHJ1bmNhdGUoaW5zcGVjdChzZWxmLmFjdHVhbCksIDEyOCkgKyAnICcgK1xuICAgICAgICAgc2VsZi5vcGVyYXRvciArICcgJyArXG4gICAgICAgICB0cnVuY2F0ZShpbnNwZWN0KHNlbGYuZXhwZWN0ZWQpLCAxMjgpO1xufVxuXG4vLyBBdCBwcmVzZW50IG9ubHkgdGhlIHRocmVlIGtleXMgbWVudGlvbmVkIGFib3ZlIGFyZSB1c2VkIGFuZFxuLy8gdW5kZXJzdG9vZCBieSB0aGUgc3BlYy4gSW1wbGVtZW50YXRpb25zIG9yIHN1YiBtb2R1bGVzIGNhbiBwYXNzXG4vLyBvdGhlciBrZXlzIHRvIHRoZSBBc3NlcnRpb25FcnJvcidzIGNvbnN0cnVjdG9yIC0gdGhleSB3aWxsIGJlXG4vLyBpZ25vcmVkLlxuXG4vLyAzLiBBbGwgb2YgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgbXVzdCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuLy8gd2hlbiBhIGNvcnJlc3BvbmRpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQsIHdpdGggYSBtZXNzYWdlIHRoYXRcbi8vIG1heSBiZSB1bmRlZmluZWQgaWYgbm90IHByb3ZpZGVkLiAgQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0RnVuY3Rpb24pIHtcbiAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgIHN0YWNrU3RhcnRGdW5jdGlvbjogc3RhY2tTdGFydEZ1bmN0aW9uXG4gIH0pO1xufVxuXG4vLyBFWFRFTlNJT04hIGFsbG93cyBmb3Igd2VsbCBiZWhhdmVkIGVycm9ycyBkZWZpbmVkIGVsc2V3aGVyZS5cbmFzc2VydC5mYWlsID0gZmFpbDtcblxuLy8gNC4gUHVyZSBhc3NlcnRpb24gdGVzdHMgd2hldGhlciBhIHZhbHVlIGlzIHRydXRoeSwgYXMgZGV0ZXJtaW5lZFxuLy8gYnkgISFndWFyZC5cbi8vIGFzc2VydC5vayhndWFyZCwgbWVzc2FnZV9vcHQpO1xuLy8gVGhpcyBzdGF0ZW1lbnQgaXMgZXF1aXZhbGVudCB0byBhc3NlcnQuZXF1YWwodHJ1ZSwgISFndWFyZCxcbi8vIG1lc3NhZ2Vfb3B0KTsuIFRvIHRlc3Qgc3RyaWN0bHkgZm9yIHRoZSB2YWx1ZSB0cnVlLCB1c2Vcbi8vIGFzc2VydC5zdHJpY3RFcXVhbCh0cnVlLCBndWFyZCwgbWVzc2FnZV9vcHQpOy5cblxuZnVuY3Rpb24gb2sodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09JywgYXNzZXJ0Lm9rKTtcbn1cbmFzc2VydC5vayA9IG9rO1xuXG4vLyA1LiBUaGUgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHNoYWxsb3csIGNvZXJjaXZlIGVxdWFsaXR5IHdpdGhcbi8vID09LlxuLy8gYXNzZXJ0LmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5lcXVhbCk7XG59O1xuXG4vLyA2LiBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90IGVxdWFsXG4vLyB3aXRoICE9IGFzc2VydC5ub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9JywgYXNzZXJ0Lm5vdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gNy4gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG4vLyBhc3NlcnQuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBmYWxzZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdkZWVwRXF1YWwnLCBhc3NlcnQuZGVlcEVxdWFsKTtcbiAgfVxufTtcblxuYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIGRlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCB0cnVlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBTdHJpY3RFcXVhbCcsIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdCwgbWVtb3MpIHtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoaXNCdWZmZXIoYWN0dWFsKSAmJiBpc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gY29tcGFyZShhY3R1YWwsIGV4cGVjdGVkKSA9PT0gMDtcblxuICAvLyA3LjIuIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIERhdGUgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIERhdGUgb2JqZWN0IHRoYXQgcmVmZXJzIHRvIHRoZSBzYW1lIHRpbWUuXG4gIH0gZWxzZSBpZiAodXRpbC5pc0RhdGUoYWN0dWFsKSAmJiB1dGlsLmlzRGF0ZShleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIC8vIDcuMyBJZiB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMgYSBSZWdFeHAgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIFJlZ0V4cCBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzb3VyY2UgYW5kXG4gIC8vIHByb3BlcnRpZXMgKGBnbG9iYWxgLCBgbXVsdGlsaW5lYCwgYGxhc3RJbmRleGAsIGBpZ25vcmVDYXNlYCkuXG4gIH0gZWxzZSBpZiAodXRpbC5pc1JlZ0V4cChhY3R1YWwpICYmIHV0aWwuaXNSZWdFeHAoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5zb3VyY2UgPT09IGV4cGVjdGVkLnNvdXJjZSAmJlxuICAgICAgICAgICBhY3R1YWwuZ2xvYmFsID09PSBleHBlY3RlZC5nbG9iYWwgJiZcbiAgICAgICAgICAgYWN0dWFsLm11bHRpbGluZSA9PT0gZXhwZWN0ZWQubXVsdGlsaW5lICYmXG4gICAgICAgICAgIGFjdHVhbC5sYXN0SW5kZXggPT09IGV4cGVjdGVkLmxhc3RJbmRleCAmJlxuICAgICAgICAgICBhY3R1YWwuaWdub3JlQ2FzZSA9PT0gZXhwZWN0ZWQuaWdub3JlQ2FzZTtcblxuICAvLyA3LjQuIE90aGVyIHBhaXJzIHRoYXQgZG8gbm90IGJvdGggcGFzcyB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uXG4gIH0gZWxzZSBpZiAoKGFjdHVhbCA9PT0gbnVsbCB8fCB0eXBlb2YgYWN0dWFsICE9PSAnb2JqZWN0JykgJiZcbiAgICAgICAgICAgICAoZXhwZWN0ZWQgPT09IG51bGwgfHwgdHlwZW9mIGV4cGVjdGVkICE9PSAnb2JqZWN0JykpIHtcbiAgICByZXR1cm4gc3RyaWN0ID8gYWN0dWFsID09PSBleHBlY3RlZCA6IGFjdHVhbCA9PSBleHBlY3RlZDtcblxuICAvLyBJZiBib3RoIHZhbHVlcyBhcmUgaW5zdGFuY2VzIG9mIHR5cGVkIGFycmF5cywgd3JhcCB0aGVpciB1bmRlcmx5aW5nXG4gIC8vIEFycmF5QnVmZmVycyBpbiBhIEJ1ZmZlciBlYWNoIHRvIGluY3JlYXNlIHBlcmZvcm1hbmNlXG4gIC8vIFRoaXMgb3B0aW1pemF0aW9uIHJlcXVpcmVzIHRoZSBhcnJheXMgdG8gaGF2ZSB0aGUgc2FtZSB0eXBlIGFzIGNoZWNrZWQgYnlcbiAgLy8gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyAoYWthIHBUb1N0cmluZykuIE5ldmVyIHBlcmZvcm0gYmluYXJ5XG4gIC8vIGNvbXBhcmlzb25zIGZvciBGbG9hdCpBcnJheXMsIHRob3VnaCwgc2luY2UgZS5nLiArMCA9PT0gLTAgYnV0IHRoZWlyXG4gIC8vIGJpdCBwYXR0ZXJucyBhcmUgbm90IGlkZW50aWNhbC5cbiAgfSBlbHNlIGlmIChpc1ZpZXcoYWN0dWFsKSAmJiBpc1ZpZXcoZXhwZWN0ZWQpICYmXG4gICAgICAgICAgICAgcFRvU3RyaW5nKGFjdHVhbCkgPT09IHBUb1N0cmluZyhleHBlY3RlZCkgJiZcbiAgICAgICAgICAgICAhKGFjdHVhbCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSB8fFxuICAgICAgICAgICAgICAgYWN0dWFsIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5KSkge1xuICAgIHJldHVybiBjb21wYXJlKG5ldyBVaW50OEFycmF5KGFjdHVhbC5idWZmZXIpLFxuICAgICAgICAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KGV4cGVjdGVkLmJ1ZmZlcikpID09PSAwO1xuXG4gIC8vIDcuNSBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSBpZiAoaXNCdWZmZXIoYWN0dWFsKSAhPT0gaXNCdWZmZXIoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIG1lbW9zID0gbWVtb3MgfHwge2FjdHVhbDogW10sIGV4cGVjdGVkOiBbXX07XG5cbiAgICB2YXIgYWN0dWFsSW5kZXggPSBtZW1vcy5hY3R1YWwuaW5kZXhPZihhY3R1YWwpO1xuICAgIGlmIChhY3R1YWxJbmRleCAhPT0gLTEpIHtcbiAgICAgIGlmIChhY3R1YWxJbmRleCA9PT0gbWVtb3MuZXhwZWN0ZWQuaW5kZXhPZihleHBlY3RlZCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWVtb3MuYWN0dWFsLnB1c2goYWN0dWFsKTtcbiAgICBtZW1vcy5leHBlY3RlZC5wdXNoKGV4cGVjdGVkKTtcblxuICAgIHJldHVybiBvYmpFcXVpdihhY3R1YWwsIGV4cGVjdGVkLCBzdHJpY3QsIG1lbW9zKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyhvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBzdHJpY3QsIGFjdHVhbFZpc2l0ZWRPYmplY3RzKSB7XG4gIGlmIChhID09PSBudWxsIHx8IGEgPT09IHVuZGVmaW5lZCB8fCBiID09PSBudWxsIHx8IGIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGlmIG9uZSBpcyBhIHByaW1pdGl2ZSwgdGhlIG90aGVyIG11c3QgYmUgc2FtZVxuICBpZiAodXRpbC5pc1ByaW1pdGl2ZShhKSB8fCB1dGlsLmlzUHJpbWl0aXZlKGIpKVxuICAgIHJldHVybiBhID09PSBiO1xuICBpZiAoc3RyaWN0ICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihhKSAhPT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgdmFyIGFJc0FyZ3MgPSBpc0FyZ3VtZW50cyhhKTtcbiAgdmFyIGJJc0FyZ3MgPSBpc0FyZ3VtZW50cyhiKTtcbiAgaWYgKChhSXNBcmdzICYmICFiSXNBcmdzKSB8fCAoIWFJc0FyZ3MgJiYgYklzQXJncykpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoYUlzQXJncykge1xuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIF9kZWVwRXF1YWwoYSwgYiwgc3RyaWN0KTtcbiAgfVxuICB2YXIga2EgPSBvYmplY3RLZXlzKGEpO1xuICB2YXIga2IgPSBvYmplY3RLZXlzKGIpO1xuICB2YXIga2V5LCBpO1xuICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzXG4gIC8vIGhhc093blByb3BlcnR5KVxuICBpZiAoa2EubGVuZ3RoICE9PSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIV9kZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIHN0cmljdCwgYWN0dWFsVmlzaXRlZE9iamVjdHMpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyA4LiBUaGUgbm9uLWVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBmb3IgYW55IGRlZXAgaW5lcXVhbGl0eS5cbi8vIGFzc2VydC5ub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90RGVlcEVxdWFsID0gZnVuY3Rpb24gbm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgZmFsc2UpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcEVxdWFsJywgYXNzZXJ0Lm5vdERlZXBFcXVhbCk7XG4gIH1cbn07XG5cbmFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWwgPSBub3REZWVwU3RyaWN0RXF1YWw7XG5mdW5jdGlvbiBub3REZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCB0cnVlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ25vdERlZXBTdHJpY3RFcXVhbCcsIG5vdERlZXBTdHJpY3RFcXVhbCk7XG4gIH1cbn1cblxuXG4vLyA5LiBUaGUgc3RyaWN0IGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzdHJpY3QgZXF1YWxpdHksIGFzIGRldGVybWluZWQgYnkgPT09LlxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnN0cmljdEVxdWFsID0gZnVuY3Rpb24gc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09PScsIGFzc2VydC5zdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDEwLiBUaGUgc3RyaWN0IG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHN0cmljdCBpbmVxdWFsaXR5LCBhc1xuLy8gZGV0ZXJtaW5lZCBieSAhPT0uICBhc3NlcnQubm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT09JywgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGV4cGVjdGVkKSA9PSAnW29iamVjdCBSZWdFeHBdJykge1xuICAgIHJldHVybiBleHBlY3RlZC50ZXN0KGFjdHVhbCk7XG4gIH1cblxuICB0cnkge1xuICAgIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBleHBlY3RlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gSWdub3JlLiAgVGhlIGluc3RhbmNlb2YgY2hlY2sgZG9lc24ndCB3b3JrIGZvciBhcnJvdyBmdW5jdGlvbnMuXG4gIH1cblxuICBpZiAoRXJyb3IuaXNQcm90b3R5cGVPZihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZXhwZWN0ZWQuY2FsbCh7fSwgYWN0dWFsKSA9PT0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gX3RyeUJsb2NrKGJsb2NrKSB7XG4gIHZhciBlcnJvcjtcbiAgdHJ5IHtcbiAgICBibG9jaygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyb3IgPSBlO1xuICB9XG4gIHJldHVybiBlcnJvcjtcbn1cblxuZnVuY3Rpb24gX3Rocm93cyhzaG91bGRUaHJvdywgYmxvY2ssIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIHZhciBhY3R1YWw7XG5cbiAgaWYgKHR5cGVvZiBibG9jayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYmxvY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgbWVzc2FnZSA9IGV4cGVjdGVkO1xuICAgIGV4cGVjdGVkID0gbnVsbDtcbiAgfVxuXG4gIGFjdHVhbCA9IF90cnlCbG9jayhibG9jayk7XG5cbiAgbWVzc2FnZSA9IChleHBlY3RlZCAmJiBleHBlY3RlZC5uYW1lID8gJyAoJyArIGV4cGVjdGVkLm5hbWUgKyAnKS4nIDogJy4nKSArXG4gICAgICAgICAgICAobWVzc2FnZSA/ICcgJyArIG1lc3NhZ2UgOiAnLicpO1xuXG4gIGlmIChzaG91bGRUaHJvdyAmJiAhYWN0dWFsKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCAnTWlzc2luZyBleHBlY3RlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICB2YXIgdXNlclByb3ZpZGVkTWVzc2FnZSA9IHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJztcbiAgdmFyIGlzVW53YW50ZWRFeGNlcHRpb24gPSAhc2hvdWxkVGhyb3cgJiYgdXRpbC5pc0Vycm9yKGFjdHVhbCk7XG4gIHZhciBpc1VuZXhwZWN0ZWRFeGNlcHRpb24gPSAhc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmICFleHBlY3RlZDtcblxuICBpZiAoKGlzVW53YW50ZWRFeGNlcHRpb24gJiZcbiAgICAgIHVzZXJQcm92aWRlZE1lc3NhZ2UgJiZcbiAgICAgIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB8fFxuICAgICAgaXNVbmV4cGVjdGVkRXhjZXB0aW9uKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCAnR290IHVud2FudGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICgoc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmIGV4cGVjdGVkICYmXG4gICAgICAhZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8ICghc2hvdWxkVGhyb3cgJiYgYWN0dWFsKSkge1xuICAgIHRocm93IGFjdHVhbDtcbiAgfVxufVxuXG4vLyAxMS4gRXhwZWN0ZWQgdG8gdGhyb3cgYW4gZXJyb3I6XG4vLyBhc3NlcnQudGhyb3dzKGJsb2NrLCBFcnJvcl9vcHQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnRocm93cyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzKHRydWUsIGJsb2NrLCBlcnJvciwgbWVzc2FnZSk7XG59O1xuXG4vLyBFWFRFTlNJT04hIFRoaXMgaXMgYW5ub3lpbmcgdG8gd3JpdGUgb3V0c2lkZSB0aGlzIG1vZHVsZS5cbmFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovZXJyb3IsIC8qb3B0aW9uYWwqL21lc3NhZ2UpIHtcbiAgX3Rocm93cyhmYWxzZSwgYmxvY2ssIGVycm9yLCBtZXNzYWdlKTtcbn07XG5cbmFzc2VydC5pZkVycm9yID0gZnVuY3Rpb24oZXJyKSB7IGlmIChlcnIpIHRocm93IGVycjsgfTtcblxuLy8gRXhwb3NlIGEgc3RyaWN0IG9ubHkgdmFyaWFudCBvZiBhc3NlcnRcbmZ1bmN0aW9uIHN0cmljdCh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIXZhbHVlKSBmYWlsKHZhbHVlLCB0cnVlLCBtZXNzYWdlLCAnPT0nLCBzdHJpY3QpO1xufVxuYXNzZXJ0LnN0cmljdCA9IG9iamVjdEFzc2lnbihzdHJpY3QsIGFzc2VydCwge1xuICBlcXVhbDogYXNzZXJ0LnN0cmljdEVxdWFsLFxuICBkZWVwRXF1YWw6IGFzc2VydC5kZWVwU3RyaWN0RXF1YWwsXG4gIG5vdEVxdWFsOiBhc3NlcnQubm90U3RyaWN0RXF1YWwsXG4gIG5vdERlZXBFcXVhbDogYXNzZXJ0Lm5vdERlZXBTdHJpY3RFcXVhbFxufSk7XG5hc3NlcnQuc3RyaWN0LnN0cmljdCA9IGFzc2VydC5zdHJpY3Q7XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhc093bi5jYWxsKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59O1xuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKFxuICAgICAgdWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKVxuICAgICkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIiIsIid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludCBjYW1lbGNhc2U6IFwib2ZmXCIgKi9cblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG52YXIgWnN0cmVhbSA9IHJlcXVpcmUoJ3Bha28vbGliL3psaWIvenN0cmVhbScpO1xudmFyIHpsaWJfZGVmbGF0ZSA9IHJlcXVpcmUoJ3Bha28vbGliL3psaWIvZGVmbGF0ZS5qcycpO1xudmFyIHpsaWJfaW5mbGF0ZSA9IHJlcXVpcmUoJ3Bha28vbGliL3psaWIvaW5mbGF0ZS5qcycpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJ3Bha28vbGliL3psaWIvY29uc3RhbnRzJyk7XG5cbmZvciAodmFyIGtleSBpbiBjb25zdGFudHMpIHtcbiAgZXhwb3J0c1trZXldID0gY29uc3RhbnRzW2tleV07XG59XG5cbi8vIHpsaWIgbW9kZXNcbmV4cG9ydHMuTk9ORSA9IDA7XG5leHBvcnRzLkRFRkxBVEUgPSAxO1xuZXhwb3J0cy5JTkZMQVRFID0gMjtcbmV4cG9ydHMuR1pJUCA9IDM7XG5leHBvcnRzLkdVTlpJUCA9IDQ7XG5leHBvcnRzLkRFRkxBVEVSQVcgPSA1O1xuZXhwb3J0cy5JTkZMQVRFUkFXID0gNjtcbmV4cG9ydHMuVU5aSVAgPSA3O1xuXG52YXIgR1pJUF9IRUFERVJfSUQxID0gMHgxZjtcbnZhciBHWklQX0hFQURFUl9JRDIgPSAweDhiO1xuXG4vKipcbiAqIEVtdWxhdGUgTm9kZSdzIHpsaWIgQysrIGxheWVyIGZvciB1c2UgYnkgdGhlIEpTIGxheWVyIGluIGluZGV4LmpzXG4gKi9cbmZ1bmN0aW9uIFpsaWIobW9kZSkge1xuICBpZiAodHlwZW9mIG1vZGUgIT09ICdudW1iZXInIHx8IG1vZGUgPCBleHBvcnRzLkRFRkxBVEUgfHwgbW9kZSA+IGV4cG9ydHMuVU5aSVApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCYWQgYXJndW1lbnQnKTtcbiAgfVxuXG4gIHRoaXMuZGljdGlvbmFyeSA9IG51bGw7XG4gIHRoaXMuZXJyID0gMDtcbiAgdGhpcy5mbHVzaCA9IDA7XG4gIHRoaXMuaW5pdF9kb25lID0gZmFsc2U7XG4gIHRoaXMubGV2ZWwgPSAwO1xuICB0aGlzLm1lbUxldmVsID0gMDtcbiAgdGhpcy5tb2RlID0gbW9kZTtcbiAgdGhpcy5zdHJhdGVneSA9IDA7XG4gIHRoaXMud2luZG93Qml0cyA9IDA7XG4gIHRoaXMud3JpdGVfaW5fcHJvZ3Jlc3MgPSBmYWxzZTtcbiAgdGhpcy5wZW5kaW5nX2Nsb3NlID0gZmFsc2U7XG4gIHRoaXMuZ3ppcF9pZF9ieXRlc19yZWFkID0gMDtcbn1cblxuWmxpYi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLndyaXRlX2luX3Byb2dyZXNzKSB7XG4gICAgdGhpcy5wZW5kaW5nX2Nsb3NlID0gdHJ1ZTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLnBlbmRpbmdfY2xvc2UgPSBmYWxzZTtcblxuICBhc3NlcnQodGhpcy5pbml0X2RvbmUsICdjbG9zZSBiZWZvcmUgaW5pdCcpO1xuICBhc3NlcnQodGhpcy5tb2RlIDw9IGV4cG9ydHMuVU5aSVApO1xuXG4gIGlmICh0aGlzLm1vZGUgPT09IGV4cG9ydHMuREVGTEFURSB8fCB0aGlzLm1vZGUgPT09IGV4cG9ydHMuR1pJUCB8fCB0aGlzLm1vZGUgPT09IGV4cG9ydHMuREVGTEFURVJBVykge1xuICAgIHpsaWJfZGVmbGF0ZS5kZWZsYXRlRW5kKHRoaXMuc3RybSk7XG4gIH0gZWxzZSBpZiAodGhpcy5tb2RlID09PSBleHBvcnRzLklORkxBVEUgfHwgdGhpcy5tb2RlID09PSBleHBvcnRzLkdVTlpJUCB8fCB0aGlzLm1vZGUgPT09IGV4cG9ydHMuSU5GTEFURVJBVyB8fCB0aGlzLm1vZGUgPT09IGV4cG9ydHMuVU5aSVApIHtcbiAgICB6bGliX2luZmxhdGUuaW5mbGF0ZUVuZCh0aGlzLnN0cm0pO1xuICB9XG5cbiAgdGhpcy5tb2RlID0gZXhwb3J0cy5OT05FO1xuXG4gIHRoaXMuZGljdGlvbmFyeSA9IG51bGw7XG59O1xuXG5abGliLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChmbHVzaCwgaW5wdXQsIGluX29mZiwgaW5fbGVuLCBvdXQsIG91dF9vZmYsIG91dF9sZW4pIHtcbiAgcmV0dXJuIHRoaXMuX3dyaXRlKHRydWUsIGZsdXNoLCBpbnB1dCwgaW5fb2ZmLCBpbl9sZW4sIG91dCwgb3V0X29mZiwgb3V0X2xlbik7XG59O1xuXG5abGliLnByb3RvdHlwZS53cml0ZVN5bmMgPSBmdW5jdGlvbiAoZmx1c2gsIGlucHV0LCBpbl9vZmYsIGluX2xlbiwgb3V0LCBvdXRfb2ZmLCBvdXRfbGVuKSB7XG4gIHJldHVybiB0aGlzLl93cml0ZShmYWxzZSwgZmx1c2gsIGlucHV0LCBpbl9vZmYsIGluX2xlbiwgb3V0LCBvdXRfb2ZmLCBvdXRfbGVuKTtcbn07XG5cblpsaWIucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChhc3luYywgZmx1c2gsIGlucHV0LCBpbl9vZmYsIGluX2xlbiwgb3V0LCBvdXRfb2ZmLCBvdXRfbGVuKSB7XG4gIGFzc2VydC5lcXVhbChhcmd1bWVudHMubGVuZ3RoLCA4KTtcblxuICBhc3NlcnQodGhpcy5pbml0X2RvbmUsICd3cml0ZSBiZWZvcmUgaW5pdCcpO1xuICBhc3NlcnQodGhpcy5tb2RlICE9PSBleHBvcnRzLk5PTkUsICdhbHJlYWR5IGZpbmFsaXplZCcpO1xuICBhc3NlcnQuZXF1YWwoZmFsc2UsIHRoaXMud3JpdGVfaW5fcHJvZ3Jlc3MsICd3cml0ZSBhbHJlYWR5IGluIHByb2dyZXNzJyk7XG4gIGFzc2VydC5lcXVhbChmYWxzZSwgdGhpcy5wZW5kaW5nX2Nsb3NlLCAnY2xvc2UgaXMgcGVuZGluZycpO1xuXG4gIHRoaXMud3JpdGVfaW5fcHJvZ3Jlc3MgPSB0cnVlO1xuXG4gIGFzc2VydC5lcXVhbChmYWxzZSwgZmx1c2ggPT09IHVuZGVmaW5lZCwgJ211c3QgcHJvdmlkZSBmbHVzaCB2YWx1ZScpO1xuXG4gIHRoaXMud3JpdGVfaW5fcHJvZ3Jlc3MgPSB0cnVlO1xuXG4gIGlmIChmbHVzaCAhPT0gZXhwb3J0cy5aX05PX0ZMVVNIICYmIGZsdXNoICE9PSBleHBvcnRzLlpfUEFSVElBTF9GTFVTSCAmJiBmbHVzaCAhPT0gZXhwb3J0cy5aX1NZTkNfRkxVU0ggJiYgZmx1c2ggIT09IGV4cG9ydHMuWl9GVUxMX0ZMVVNIICYmIGZsdXNoICE9PSBleHBvcnRzLlpfRklOSVNIICYmIGZsdXNoICE9PSBleHBvcnRzLlpfQkxPQ0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZmx1c2ggdmFsdWUnKTtcbiAgfVxuXG4gIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgaW5wdXQgPSBCdWZmZXIuYWxsb2MoMCk7XG4gICAgaW5fbGVuID0gMDtcbiAgICBpbl9vZmYgPSAwO1xuICB9XG5cbiAgdGhpcy5zdHJtLmF2YWlsX2luID0gaW5fbGVuO1xuICB0aGlzLnN0cm0uaW5wdXQgPSBpbnB1dDtcbiAgdGhpcy5zdHJtLm5leHRfaW4gPSBpbl9vZmY7XG4gIHRoaXMuc3RybS5hdmFpbF9vdXQgPSBvdXRfbGVuO1xuICB0aGlzLnN0cm0ub3V0cHV0ID0gb3V0O1xuICB0aGlzLnN0cm0ubmV4dF9vdXQgPSBvdXRfb2ZmO1xuICB0aGlzLmZsdXNoID0gZmx1c2g7XG5cbiAgaWYgKCFhc3luYykge1xuICAgIC8vIHN5bmMgdmVyc2lvblxuICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuICAgIGlmICh0aGlzLl9jaGVja0Vycm9yKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hZnRlclN5bmMoKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gYXN5bmMgdmVyc2lvblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX3Byb2Nlc3MoKTtcbiAgICBzZWxmLl9hZnRlcigpO1xuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cblpsaWIucHJvdG90eXBlLl9hZnRlclN5bmMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhdmFpbF9vdXQgPSB0aGlzLnN0cm0uYXZhaWxfb3V0O1xuICB2YXIgYXZhaWxfaW4gPSB0aGlzLnN0cm0uYXZhaWxfaW47XG5cbiAgdGhpcy53cml0ZV9pbl9wcm9ncmVzcyA9IGZhbHNlO1xuXG4gIHJldHVybiBbYXZhaWxfaW4sIGF2YWlsX291dF07XG59O1xuXG5abGliLnByb3RvdHlwZS5fcHJvY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5leHRfZXhwZWN0ZWRfaGVhZGVyX2J5dGUgPSBudWxsO1xuXG4gIC8vIElmIHRoZSBhdmFpbF9vdXQgaXMgbGVmdCBhdCAwLCB0aGVuIGl0IG1lYW5zIHRoYXQgaXQgcmFuIG91dFxuICAvLyBvZiByb29tLiAgSWYgdGhlcmUgd2FzIGF2YWlsX291dCBsZWZ0IG92ZXIsIHRoZW4gaXQgbWVhbnNcbiAgLy8gdGhhdCBhbGwgb2YgdGhlIGlucHV0IHdhcyBjb25zdW1lZC5cbiAgc3dpdGNoICh0aGlzLm1vZGUpIHtcbiAgICBjYXNlIGV4cG9ydHMuREVGTEFURTpcbiAgICBjYXNlIGV4cG9ydHMuR1pJUDpcbiAgICBjYXNlIGV4cG9ydHMuREVGTEFURVJBVzpcbiAgICAgIHRoaXMuZXJyID0gemxpYl9kZWZsYXRlLmRlZmxhdGUodGhpcy5zdHJtLCB0aGlzLmZsdXNoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZXhwb3J0cy5VTlpJUDpcbiAgICAgIGlmICh0aGlzLnN0cm0uYXZhaWxfaW4gPiAwKSB7XG4gICAgICAgIG5leHRfZXhwZWN0ZWRfaGVhZGVyX2J5dGUgPSB0aGlzLnN0cm0ubmV4dF9pbjtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoICh0aGlzLmd6aXBfaWRfYnl0ZXNfcmVhZCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgaWYgKG5leHRfZXhwZWN0ZWRfaGVhZGVyX2J5dGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnN0cm0uaW5wdXRbbmV4dF9leHBlY3RlZF9oZWFkZXJfYnl0ZV0gPT09IEdaSVBfSEVBREVSX0lEMSkge1xuICAgICAgICAgICAgdGhpcy5nemlwX2lkX2J5dGVzX3JlYWQgPSAxO1xuICAgICAgICAgICAgbmV4dF9leHBlY3RlZF9oZWFkZXJfYnl0ZSsrO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zdHJtLmF2YWlsX2luID09PSAxKSB7XG4gICAgICAgICAgICAgIC8vIFRoZSBvbmx5IGF2YWlsYWJsZSBieXRlIHdhcyBhbHJlYWR5IHJlYWQuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1vZGUgPSBleHBvcnRzLklORkxBVEU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChuZXh0X2V4cGVjdGVkX2hlYWRlcl9ieXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5zdHJtLmlucHV0W25leHRfZXhwZWN0ZWRfaGVhZGVyX2J5dGVdID09PSBHWklQX0hFQURFUl9JRDIpIHtcbiAgICAgICAgICAgIHRoaXMuZ3ppcF9pZF9ieXRlc19yZWFkID0gMjtcbiAgICAgICAgICAgIHRoaXMubW9kZSA9IGV4cG9ydHMuR1VOWklQO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBhY3R1YWwgZGlmZmVyZW5jZSBiZXR3ZWVuIElORkxBVEUgYW5kIElORkxBVEVSQVdcbiAgICAgICAgICAgIC8vIChhZnRlciBpbml0aWFsaXphdGlvbikuXG4gICAgICAgICAgICB0aGlzLm1vZGUgPSBleHBvcnRzLklORkxBVEU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG51bWJlciBvZiBnemlwIG1hZ2ljIG51bWJlciBieXRlcyByZWFkJyk7XG4gICAgICB9XG5cbiAgICAvLyBmYWxsdGhyb3VnaFxuICAgIGNhc2UgZXhwb3J0cy5JTkZMQVRFOlxuICAgIGNhc2UgZXhwb3J0cy5HVU5aSVA6XG4gICAgY2FzZSBleHBvcnRzLklORkxBVEVSQVc6XG4gICAgICB0aGlzLmVyciA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlKHRoaXMuc3RybSwgdGhpcy5mbHVzaFxuXG4gICAgICAvLyBJZiBkYXRhIHdhcyBlbmNvZGVkIHdpdGggZGljdGlvbmFyeVxuICAgICAgKTtpZiAodGhpcy5lcnIgPT09IGV4cG9ydHMuWl9ORUVEX0RJQ1QgJiYgdGhpcy5kaWN0aW9uYXJ5KSB7XG4gICAgICAgIC8vIExvYWQgaXRcbiAgICAgICAgdGhpcy5lcnIgPSB6bGliX2luZmxhdGUuaW5mbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCB0aGlzLmRpY3Rpb25hcnkpO1xuICAgICAgICBpZiAodGhpcy5lcnIgPT09IGV4cG9ydHMuWl9PSykge1xuICAgICAgICAgIC8vIEFuZCB0cnkgdG8gZGVjb2RlIGFnYWluXG4gICAgICAgICAgdGhpcy5lcnIgPSB6bGliX2luZmxhdGUuaW5mbGF0ZSh0aGlzLnN0cm0sIHRoaXMuZmx1c2gpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZXJyID09PSBleHBvcnRzLlpfREFUQV9FUlJPUikge1xuICAgICAgICAgIC8vIEJvdGggaW5mbGF0ZVNldERpY3Rpb25hcnkoKSBhbmQgaW5mbGF0ZSgpIHJldHVybiBaX0RBVEFfRVJST1IuXG4gICAgICAgICAgLy8gTWFrZSBpdCBwb3NzaWJsZSBmb3IgQWZ0ZXIoKSB0byB0ZWxsIGEgYmFkIGRpY3Rpb25hcnkgZnJvbSBiYWRcbiAgICAgICAgICAvLyBpbnB1dC5cbiAgICAgICAgICB0aGlzLmVyciA9IGV4cG9ydHMuWl9ORUVEX0RJQ1Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlICh0aGlzLnN0cm0uYXZhaWxfaW4gPiAwICYmIHRoaXMubW9kZSA9PT0gZXhwb3J0cy5HVU5aSVAgJiYgdGhpcy5lcnIgPT09IGV4cG9ydHMuWl9TVFJFQU1fRU5EICYmIHRoaXMuc3RybS5uZXh0X2luWzBdICE9PSAweDAwKSB7XG4gICAgICAgIC8vIEJ5dGVzIHJlbWFpbiBpbiBpbnB1dCBidWZmZXIuIFBlcmhhcHMgdGhpcyBpcyBhbm90aGVyIGNvbXByZXNzZWRcbiAgICAgICAgLy8gbWVtYmVyIGluIHRoZSBzYW1lIGFyY2hpdmUsIG9yIGp1c3QgdHJhaWxpbmcgZ2FyYmFnZS5cbiAgICAgICAgLy8gVHJhaWxpbmcgemVybyBieXRlcyBhcmUgb2theSwgdGhvdWdoLCBzaW5jZSB0aGV5IGFyZSBmcmVxdWVudGx5XG4gICAgICAgIC8vIHVzZWQgZm9yIHBhZGRpbmcuXG5cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB0aGlzLmVyciA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlKHRoaXMuc3RybSwgdGhpcy5mbHVzaCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG1vZGUgJyArIHRoaXMubW9kZSk7XG4gIH1cbn07XG5cblpsaWIucHJvdG90eXBlLl9jaGVja0Vycm9yID0gZnVuY3Rpb24gKCkge1xuICAvLyBBY2NlcHRhYmxlIGVycm9yIHN0YXRlcyBkZXBlbmQgb24gdGhlIHR5cGUgb2YgemxpYiBzdHJlYW0uXG4gIHN3aXRjaCAodGhpcy5lcnIpIHtcbiAgICBjYXNlIGV4cG9ydHMuWl9PSzpcbiAgICBjYXNlIGV4cG9ydHMuWl9CVUZfRVJST1I6XG4gICAgICBpZiAodGhpcy5zdHJtLmF2YWlsX291dCAhPT0gMCAmJiB0aGlzLmZsdXNoID09PSBleHBvcnRzLlpfRklOSVNIKSB7XG4gICAgICAgIHRoaXMuX2Vycm9yKCd1bmV4cGVjdGVkIGVuZCBvZiBmaWxlJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZXhwb3J0cy5aX1NUUkVBTV9FTkQ6XG4gICAgICAvLyBub3JtYWwgc3RhdHVzZXMsIG5vdCBmYXRhbFxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBleHBvcnRzLlpfTkVFRF9ESUNUOlxuICAgICAgaWYgKHRoaXMuZGljdGlvbmFyeSA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2Vycm9yKCdNaXNzaW5nIGRpY3Rpb25hcnknKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2Vycm9yKCdCYWQgZGljdGlvbmFyeScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBzb21ldGhpbmcgZWxzZS5cbiAgICAgIHRoaXMuX2Vycm9yKCdabGliIGVycm9yJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblpsaWIucHJvdG90eXBlLl9hZnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLl9jaGVja0Vycm9yKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYXZhaWxfb3V0ID0gdGhpcy5zdHJtLmF2YWlsX291dDtcbiAgdmFyIGF2YWlsX2luID0gdGhpcy5zdHJtLmF2YWlsX2luO1xuXG4gIHRoaXMud3JpdGVfaW5fcHJvZ3Jlc3MgPSBmYWxzZTtcblxuICAvLyBjYWxsIHRoZSB3cml0ZSgpIGNiXG4gIHRoaXMuY2FsbGJhY2soYXZhaWxfaW4sIGF2YWlsX291dCk7XG5cbiAgaWYgKHRoaXMucGVuZGluZ19jbG9zZSkge1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgfVxufTtcblxuWmxpYi5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgaWYgKHRoaXMuc3RybS5tc2cpIHtcbiAgICBtZXNzYWdlID0gdGhpcy5zdHJtLm1zZztcbiAgfVxuICB0aGlzLm9uZXJyb3IobWVzc2FnZSwgdGhpcy5lcnJcblxuICAvLyBubyBob3BlIG9mIHJlc2N1ZS5cbiAgKTt0aGlzLndyaXRlX2luX3Byb2dyZXNzID0gZmFsc2U7XG4gIGlmICh0aGlzLnBlbmRpbmdfY2xvc2UpIHtcbiAgICB0aGlzLmNsb3NlKCk7XG4gIH1cbn07XG5cblpsaWIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAod2luZG93Qml0cywgbGV2ZWwsIG1lbUxldmVsLCBzdHJhdGVneSwgZGljdGlvbmFyeSkge1xuICBhc3NlcnQoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCB8fCBhcmd1bWVudHMubGVuZ3RoID09PSA1LCAnaW5pdCh3aW5kb3dCaXRzLCBsZXZlbCwgbWVtTGV2ZWwsIHN0cmF0ZWd5LCBbZGljdGlvbmFyeV0pJyk7XG5cbiAgYXNzZXJ0KHdpbmRvd0JpdHMgPj0gOCAmJiB3aW5kb3dCaXRzIDw9IDE1LCAnaW52YWxpZCB3aW5kb3dCaXRzJyk7XG4gIGFzc2VydChsZXZlbCA+PSAtMSAmJiBsZXZlbCA8PSA5LCAnaW52YWxpZCBjb21wcmVzc2lvbiBsZXZlbCcpO1xuXG4gIGFzc2VydChtZW1MZXZlbCA+PSAxICYmIG1lbUxldmVsIDw9IDksICdpbnZhbGlkIG1lbWxldmVsJyk7XG5cbiAgYXNzZXJ0KHN0cmF0ZWd5ID09PSBleHBvcnRzLlpfRklMVEVSRUQgfHwgc3RyYXRlZ3kgPT09IGV4cG9ydHMuWl9IVUZGTUFOX09OTFkgfHwgc3RyYXRlZ3kgPT09IGV4cG9ydHMuWl9STEUgfHwgc3RyYXRlZ3kgPT09IGV4cG9ydHMuWl9GSVhFRCB8fCBzdHJhdGVneSA9PT0gZXhwb3J0cy5aX0RFRkFVTFRfU1RSQVRFR1ksICdpbnZhbGlkIHN0cmF0ZWd5Jyk7XG5cbiAgdGhpcy5faW5pdChsZXZlbCwgd2luZG93Qml0cywgbWVtTGV2ZWwsIHN0cmF0ZWd5LCBkaWN0aW9uYXJ5KTtcbiAgdGhpcy5fc2V0RGljdGlvbmFyeSgpO1xufTtcblxuWmxpYi5wcm90b3R5cGUucGFyYW1zID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ2RlZmxhdGVQYXJhbXMgTm90IHN1cHBvcnRlZCcpO1xufTtcblxuWmxpYi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX3Jlc2V0KCk7XG4gIHRoaXMuX3NldERpY3Rpb25hcnkoKTtcbn07XG5cblpsaWIucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKGxldmVsLCB3aW5kb3dCaXRzLCBtZW1MZXZlbCwgc3RyYXRlZ3ksIGRpY3Rpb25hcnkpIHtcbiAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICB0aGlzLndpbmRvd0JpdHMgPSB3aW5kb3dCaXRzO1xuICB0aGlzLm1lbUxldmVsID0gbWVtTGV2ZWw7XG4gIHRoaXMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcblxuICB0aGlzLmZsdXNoID0gZXhwb3J0cy5aX05PX0ZMVVNIO1xuXG4gIHRoaXMuZXJyID0gZXhwb3J0cy5aX09LO1xuXG4gIGlmICh0aGlzLm1vZGUgPT09IGV4cG9ydHMuR1pJUCB8fCB0aGlzLm1vZGUgPT09IGV4cG9ydHMuR1VOWklQKSB7XG4gICAgdGhpcy53aW5kb3dCaXRzICs9IDE2O1xuICB9XG5cbiAgaWYgKHRoaXMubW9kZSA9PT0gZXhwb3J0cy5VTlpJUCkge1xuICAgIHRoaXMud2luZG93Qml0cyArPSAzMjtcbiAgfVxuXG4gIGlmICh0aGlzLm1vZGUgPT09IGV4cG9ydHMuREVGTEFURVJBVyB8fCB0aGlzLm1vZGUgPT09IGV4cG9ydHMuSU5GTEFURVJBVykge1xuICAgIHRoaXMud2luZG93Qml0cyA9IC0xICogdGhpcy53aW5kb3dCaXRzO1xuICB9XG5cbiAgdGhpcy5zdHJtID0gbmV3IFpzdHJlYW0oKTtcblxuICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgIGNhc2UgZXhwb3J0cy5ERUZMQVRFOlxuICAgIGNhc2UgZXhwb3J0cy5HWklQOlxuICAgIGNhc2UgZXhwb3J0cy5ERUZMQVRFUkFXOlxuICAgICAgdGhpcy5lcnIgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZUluaXQyKHRoaXMuc3RybSwgdGhpcy5sZXZlbCwgZXhwb3J0cy5aX0RFRkxBVEVELCB0aGlzLndpbmRvd0JpdHMsIHRoaXMubWVtTGV2ZWwsIHRoaXMuc3RyYXRlZ3kpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBleHBvcnRzLklORkxBVEU6XG4gICAgY2FzZSBleHBvcnRzLkdVTlpJUDpcbiAgICBjYXNlIGV4cG9ydHMuSU5GTEFURVJBVzpcbiAgICBjYXNlIGV4cG9ydHMuVU5aSVA6XG4gICAgICB0aGlzLmVyciA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlSW5pdDIodGhpcy5zdHJtLCB0aGlzLndpbmRvd0JpdHMpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBtb2RlICcgKyB0aGlzLm1vZGUpO1xuICB9XG5cbiAgaWYgKHRoaXMuZXJyICE9PSBleHBvcnRzLlpfT0spIHtcbiAgICB0aGlzLl9lcnJvcignSW5pdCBlcnJvcicpO1xuICB9XG5cbiAgdGhpcy5kaWN0aW9uYXJ5ID0gZGljdGlvbmFyeTtcblxuICB0aGlzLndyaXRlX2luX3Byb2dyZXNzID0gZmFsc2U7XG4gIHRoaXMuaW5pdF9kb25lID0gdHJ1ZTtcbn07XG5cblpsaWIucHJvdG90eXBlLl9zZXREaWN0aW9uYXJ5ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5kaWN0aW9uYXJ5ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmVyciA9IGV4cG9ydHMuWl9PSztcblxuICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgIGNhc2UgZXhwb3J0cy5ERUZMQVRFOlxuICAgIGNhc2UgZXhwb3J0cy5ERUZMQVRFUkFXOlxuICAgICAgdGhpcy5lcnIgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCB0aGlzLmRpY3Rpb25hcnkpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgaWYgKHRoaXMuZXJyICE9PSBleHBvcnRzLlpfT0spIHtcbiAgICB0aGlzLl9lcnJvcignRmFpbGVkIHRvIHNldCBkaWN0aW9uYXJ5Jyk7XG4gIH1cbn07XG5cblpsaWIucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lcnIgPSBleHBvcnRzLlpfT0s7XG5cbiAgc3dpdGNoICh0aGlzLm1vZGUpIHtcbiAgICBjYXNlIGV4cG9ydHMuREVGTEFURTpcbiAgICBjYXNlIGV4cG9ydHMuREVGTEFURVJBVzpcbiAgICBjYXNlIGV4cG9ydHMuR1pJUDpcbiAgICAgIHRoaXMuZXJyID0gemxpYl9kZWZsYXRlLmRlZmxhdGVSZXNldCh0aGlzLnN0cm0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBleHBvcnRzLklORkxBVEU6XG4gICAgY2FzZSBleHBvcnRzLklORkxBVEVSQVc6XG4gICAgY2FzZSBleHBvcnRzLkdVTlpJUDpcbiAgICAgIHRoaXMuZXJyID0gemxpYl9pbmZsYXRlLmluZmxhdGVSZXNldCh0aGlzLnN0cm0pO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgaWYgKHRoaXMuZXJyICE9PSBleHBvcnRzLlpfT0spIHtcbiAgICB0aGlzLl9lcnJvcignRmFpbGVkIHRvIHJlc2V0IHN0cmVhbScpO1xuICB9XG59O1xuXG5leHBvcnRzLlpsaWIgPSBabGliOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdzdHJlYW0nKS5UcmFuc2Zvcm07XG52YXIgYmluZGluZyA9IHJlcXVpcmUoJy4vYmluZGluZycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jykub2s7XG52YXIga01heExlbmd0aCA9IHJlcXVpcmUoJ2J1ZmZlcicpLmtNYXhMZW5ndGg7XG52YXIga1JhbmdlRXJyb3JNZXNzYWdlID0gJ0Nhbm5vdCBjcmVhdGUgZmluYWwgQnVmZmVyLiBJdCB3b3VsZCBiZSBsYXJnZXIgJyArICd0aGFuIDB4JyArIGtNYXhMZW5ndGgudG9TdHJpbmcoMTYpICsgJyBieXRlcyc7XG5cbi8vIHpsaWIgZG9lc24ndCBwcm92aWRlIHRoZXNlLCBzbyBrbHVkZ2UgdGhlbSBpbiBmb2xsb3dpbmcgdGhlIHNhbWVcbi8vIGNvbnN0IG5hbWluZyBzY2hlbWUgemxpYiB1c2VzLlxuYmluZGluZy5aX01JTl9XSU5ET1dCSVRTID0gODtcbmJpbmRpbmcuWl9NQVhfV0lORE9XQklUUyA9IDE1O1xuYmluZGluZy5aX0RFRkFVTFRfV0lORE9XQklUUyA9IDE1O1xuXG4vLyBmZXdlciB0aGFuIDY0IGJ5dGVzIHBlciBjaHVuayBpcyBzdHVwaWQuXG4vLyB0ZWNobmljYWxseSBpdCBjb3VsZCB3b3JrIHdpdGggYXMgZmV3IGFzIDgsIGJ1dCBldmVuIDY0IGJ5dGVzXG4vLyBpcyBhYnN1cmRseSBsb3cuICBVc3VhbGx5IGEgTUIgb3IgbW9yZSBpcyBiZXN0LlxuYmluZGluZy5aX01JTl9DSFVOSyA9IDY0O1xuYmluZGluZy5aX01BWF9DSFVOSyA9IEluZmluaXR5O1xuYmluZGluZy5aX0RFRkFVTFRfQ0hVTksgPSAxNiAqIDEwMjQ7XG5cbmJpbmRpbmcuWl9NSU5fTUVNTEVWRUwgPSAxO1xuYmluZGluZy5aX01BWF9NRU1MRVZFTCA9IDk7XG5iaW5kaW5nLlpfREVGQVVMVF9NRU1MRVZFTCA9IDg7XG5cbmJpbmRpbmcuWl9NSU5fTEVWRUwgPSAtMTtcbmJpbmRpbmcuWl9NQVhfTEVWRUwgPSA5O1xuYmluZGluZy5aX0RFRkFVTFRfTEVWRUwgPSBiaW5kaW5nLlpfREVGQVVMVF9DT01QUkVTU0lPTjtcblxuLy8gZXhwb3NlIGFsbCB0aGUgemxpYiBjb25zdGFudHNcbnZhciBia2V5cyA9IE9iamVjdC5rZXlzKGJpbmRpbmcpO1xuZm9yICh2YXIgYmsgPSAwOyBiayA8IGJrZXlzLmxlbmd0aDsgYmsrKykge1xuICB2YXIgYmtleSA9IGJrZXlzW2JrXTtcbiAgaWYgKGJrZXkubWF0Y2goL15aLykpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgYmtleSwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IGJpbmRpbmdbYmtleV0sIHdyaXRhYmxlOiBmYWxzZVxuICAgIH0pO1xuICB9XG59XG5cbi8vIHRyYW5zbGF0aW9uIHRhYmxlIGZvciByZXR1cm4gY29kZXMuXG52YXIgY29kZXMgPSB7XG4gIFpfT0s6IGJpbmRpbmcuWl9PSyxcbiAgWl9TVFJFQU1fRU5EOiBiaW5kaW5nLlpfU1RSRUFNX0VORCxcbiAgWl9ORUVEX0RJQ1Q6IGJpbmRpbmcuWl9ORUVEX0RJQ1QsXG4gIFpfRVJSTk86IGJpbmRpbmcuWl9FUlJOTyxcbiAgWl9TVFJFQU1fRVJST1I6IGJpbmRpbmcuWl9TVFJFQU1fRVJST1IsXG4gIFpfREFUQV9FUlJPUjogYmluZGluZy5aX0RBVEFfRVJST1IsXG4gIFpfTUVNX0VSUk9SOiBiaW5kaW5nLlpfTUVNX0VSUk9SLFxuICBaX0JVRl9FUlJPUjogYmluZGluZy5aX0JVRl9FUlJPUixcbiAgWl9WRVJTSU9OX0VSUk9SOiBiaW5kaW5nLlpfVkVSU0lPTl9FUlJPUlxufTtcblxudmFyIGNrZXlzID0gT2JqZWN0LmtleXMoY29kZXMpO1xuZm9yICh2YXIgY2sgPSAwOyBjayA8IGNrZXlzLmxlbmd0aDsgY2srKykge1xuICB2YXIgY2tleSA9IGNrZXlzW2NrXTtcbiAgY29kZXNbY29kZXNbY2tleV1dID0gY2tleTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdjb2RlcycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IE9iamVjdC5mcmVlemUoY29kZXMpLCB3cml0YWJsZTogZmFsc2Vcbn0pO1xuXG5leHBvcnRzLkRlZmxhdGUgPSBEZWZsYXRlO1xuZXhwb3J0cy5JbmZsYXRlID0gSW5mbGF0ZTtcbmV4cG9ydHMuR3ppcCA9IEd6aXA7XG5leHBvcnRzLkd1bnppcCA9IEd1bnppcDtcbmV4cG9ydHMuRGVmbGF0ZVJhdyA9IERlZmxhdGVSYXc7XG5leHBvcnRzLkluZmxhdGVSYXcgPSBJbmZsYXRlUmF3O1xuZXhwb3J0cy5VbnppcCA9IFVuemlwO1xuXG5leHBvcnRzLmNyZWF0ZURlZmxhdGUgPSBmdW5jdGlvbiAobykge1xuICByZXR1cm4gbmV3IERlZmxhdGUobyk7XG59O1xuXG5leHBvcnRzLmNyZWF0ZUluZmxhdGUgPSBmdW5jdGlvbiAobykge1xuICByZXR1cm4gbmV3IEluZmxhdGUobyk7XG59O1xuXG5leHBvcnRzLmNyZWF0ZURlZmxhdGVSYXcgPSBmdW5jdGlvbiAobykge1xuICByZXR1cm4gbmV3IERlZmxhdGVSYXcobyk7XG59O1xuXG5leHBvcnRzLmNyZWF0ZUluZmxhdGVSYXcgPSBmdW5jdGlvbiAobykge1xuICByZXR1cm4gbmV3IEluZmxhdGVSYXcobyk7XG59O1xuXG5leHBvcnRzLmNyZWF0ZUd6aXAgPSBmdW5jdGlvbiAobykge1xuICByZXR1cm4gbmV3IEd6aXAobyk7XG59O1xuXG5leHBvcnRzLmNyZWF0ZUd1bnppcCA9IGZ1bmN0aW9uIChvKSB7XG4gIHJldHVybiBuZXcgR3VuemlwKG8pO1xufTtcblxuZXhwb3J0cy5jcmVhdGVVbnppcCA9IGZ1bmN0aW9uIChvKSB7XG4gIHJldHVybiBuZXcgVW56aXAobyk7XG59O1xuXG4vLyBDb252ZW5pZW5jZSBtZXRob2RzLlxuLy8gY29tcHJlc3MvZGVjb21wcmVzcyBhIHN0cmluZyBvciBidWZmZXIgaW4gb25lIHN0ZXAuXG5leHBvcnRzLmRlZmxhdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBEZWZsYXRlKG9wdHMpLCBidWZmZXIsIGNhbGxiYWNrKTtcbn07XG5cbmV4cG9ydHMuZGVmbGF0ZVN5bmMgPSBmdW5jdGlvbiAoYnVmZmVyLCBvcHRzKSB7XG4gIHJldHVybiB6bGliQnVmZmVyU3luYyhuZXcgRGVmbGF0ZShvcHRzKSwgYnVmZmVyKTtcbn07XG5cbmV4cG9ydHMuZ3ppcCA9IGZ1bmN0aW9uIChidWZmZXIsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cbiAgcmV0dXJuIHpsaWJCdWZmZXIobmV3IEd6aXAob3B0cyksIGJ1ZmZlciwgY2FsbGJhY2spO1xufTtcblxuZXhwb3J0cy5nemlwU3luYyA9IGZ1bmN0aW9uIChidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBHemlwKG9wdHMpLCBidWZmZXIpO1xufTtcblxuZXhwb3J0cy5kZWZsYXRlUmF3ID0gZnVuY3Rpb24gKGJ1ZmZlciwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuICByZXR1cm4gemxpYkJ1ZmZlcihuZXcgRGVmbGF0ZVJhdyhvcHRzKSwgYnVmZmVyLCBjYWxsYmFjayk7XG59O1xuXG5leHBvcnRzLmRlZmxhdGVSYXdTeW5jID0gZnVuY3Rpb24gKGJ1ZmZlciwgb3B0cykge1xuICByZXR1cm4gemxpYkJ1ZmZlclN5bmMobmV3IERlZmxhdGVSYXcob3B0cyksIGJ1ZmZlcik7XG59O1xuXG5leHBvcnRzLnVuemlwID0gZnVuY3Rpb24gKGJ1ZmZlciwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuICByZXR1cm4gemxpYkJ1ZmZlcihuZXcgVW56aXAob3B0cyksIGJ1ZmZlciwgY2FsbGJhY2spO1xufTtcblxuZXhwb3J0cy51bnppcFN5bmMgPSBmdW5jdGlvbiAoYnVmZmVyLCBvcHRzKSB7XG4gIHJldHVybiB6bGliQnVmZmVyU3luYyhuZXcgVW56aXAob3B0cyksIGJ1ZmZlcik7XG59O1xuXG5leHBvcnRzLmluZmxhdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBJbmZsYXRlKG9wdHMpLCBidWZmZXIsIGNhbGxiYWNrKTtcbn07XG5cbmV4cG9ydHMuaW5mbGF0ZVN5bmMgPSBmdW5jdGlvbiAoYnVmZmVyLCBvcHRzKSB7XG4gIHJldHVybiB6bGliQnVmZmVyU3luYyhuZXcgSW5mbGF0ZShvcHRzKSwgYnVmZmVyKTtcbn07XG5cbmV4cG9ydHMuZ3VuemlwID0gZnVuY3Rpb24gKGJ1ZmZlciwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuICByZXR1cm4gemxpYkJ1ZmZlcihuZXcgR3VuemlwKG9wdHMpLCBidWZmZXIsIGNhbGxiYWNrKTtcbn07XG5cbmV4cG9ydHMuZ3VuemlwU3luYyA9IGZ1bmN0aW9uIChidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBHdW56aXAob3B0cyksIGJ1ZmZlcik7XG59O1xuXG5leHBvcnRzLmluZmxhdGVSYXcgPSBmdW5jdGlvbiAoYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBJbmZsYXRlUmF3KG9wdHMpLCBidWZmZXIsIGNhbGxiYWNrKTtcbn07XG5cbmV4cG9ydHMuaW5mbGF0ZVJhd1N5bmMgPSBmdW5jdGlvbiAoYnVmZmVyLCBvcHRzKSB7XG4gIHJldHVybiB6bGliQnVmZmVyU3luYyhuZXcgSW5mbGF0ZVJhdyhvcHRzKSwgYnVmZmVyKTtcbn07XG5cbmZ1bmN0aW9uIHpsaWJCdWZmZXIoZW5naW5lLCBidWZmZXIsIGNhbGxiYWNrKSB7XG4gIHZhciBidWZmZXJzID0gW107XG4gIHZhciBucmVhZCA9IDA7XG5cbiAgZW5naW5lLm9uKCdlcnJvcicsIG9uRXJyb3IpO1xuICBlbmdpbmUub24oJ2VuZCcsIG9uRW5kKTtcblxuICBlbmdpbmUuZW5kKGJ1ZmZlcik7XG4gIGZsb3coKTtcblxuICBmdW5jdGlvbiBmbG93KCkge1xuICAgIHZhciBjaHVuaztcbiAgICB3aGlsZSAobnVsbCAhPT0gKGNodW5rID0gZW5naW5lLnJlYWQoKSkpIHtcbiAgICAgIGJ1ZmZlcnMucHVzaChjaHVuayk7XG4gICAgICBucmVhZCArPSBjaHVuay5sZW5ndGg7XG4gICAgfVxuICAgIGVuZ2luZS5vbmNlKCdyZWFkYWJsZScsIGZsb3cpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25FcnJvcihlcnIpIHtcbiAgICBlbmdpbmUucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uRW5kKTtcbiAgICBlbmdpbmUucmVtb3ZlTGlzdGVuZXIoJ3JlYWRhYmxlJywgZmxvdyk7XG4gICAgY2FsbGJhY2soZXJyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRW5kKCkge1xuICAgIHZhciBidWY7XG4gICAgdmFyIGVyciA9IG51bGw7XG5cbiAgICBpZiAobnJlYWQgPj0ga01heExlbmd0aCkge1xuICAgICAgZXJyID0gbmV3IFJhbmdlRXJyb3Ioa1JhbmdlRXJyb3JNZXNzYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmID0gQnVmZmVyLmNvbmNhdChidWZmZXJzLCBucmVhZCk7XG4gICAgfVxuXG4gICAgYnVmZmVycyA9IFtdO1xuICAgIGVuZ2luZS5jbG9zZSgpO1xuICAgIGNhbGxiYWNrKGVyciwgYnVmKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB6bGliQnVmZmVyU3luYyhlbmdpbmUsIGJ1ZmZlcikge1xuICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gJ3N0cmluZycpIGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGJ1ZmZlcik7XG5cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGEgc3RyaW5nIG9yIGJ1ZmZlcicpO1xuXG4gIHZhciBmbHVzaEZsYWcgPSBlbmdpbmUuX2ZpbmlzaEZsdXNoRmxhZztcblxuICByZXR1cm4gZW5naW5lLl9wcm9jZXNzQ2h1bmsoYnVmZmVyLCBmbHVzaEZsYWcpO1xufVxuXG4vLyBnZW5lcmljIHpsaWJcbi8vIG1pbmltYWwgMi1ieXRlIGhlYWRlclxuZnVuY3Rpb24gRGVmbGF0ZShvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEZWZsYXRlKSkgcmV0dXJuIG5ldyBEZWZsYXRlKG9wdHMpO1xuICBabGliLmNhbGwodGhpcywgb3B0cywgYmluZGluZy5ERUZMQVRFKTtcbn1cblxuZnVuY3Rpb24gSW5mbGF0ZShvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJbmZsYXRlKSkgcmV0dXJuIG5ldyBJbmZsYXRlKG9wdHMpO1xuICBabGliLmNhbGwodGhpcywgb3B0cywgYmluZGluZy5JTkZMQVRFKTtcbn1cblxuLy8gZ3ppcCAtIGJpZ2dlciBoZWFkZXIsIHNhbWUgZGVmbGF0ZSBjb21wcmVzc2lvblxuZnVuY3Rpb24gR3ppcChvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBHemlwKSkgcmV0dXJuIG5ldyBHemlwKG9wdHMpO1xuICBabGliLmNhbGwodGhpcywgb3B0cywgYmluZGluZy5HWklQKTtcbn1cblxuZnVuY3Rpb24gR3VuemlwKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEd1bnppcCkpIHJldHVybiBuZXcgR3VuemlwKG9wdHMpO1xuICBabGliLmNhbGwodGhpcywgb3B0cywgYmluZGluZy5HVU5aSVApO1xufVxuXG4vLyByYXcgLSBubyBoZWFkZXJcbmZ1bmN0aW9uIERlZmxhdGVSYXcob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGVmbGF0ZVJhdykpIHJldHVybiBuZXcgRGVmbGF0ZVJhdyhvcHRzKTtcbiAgWmxpYi5jYWxsKHRoaXMsIG9wdHMsIGJpbmRpbmcuREVGTEFURVJBVyk7XG59XG5cbmZ1bmN0aW9uIEluZmxhdGVSYXcob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW5mbGF0ZVJhdykpIHJldHVybiBuZXcgSW5mbGF0ZVJhdyhvcHRzKTtcbiAgWmxpYi5jYWxsKHRoaXMsIG9wdHMsIGJpbmRpbmcuSU5GTEFURVJBVyk7XG59XG5cbi8vIGF1dG8tZGV0ZWN0IGhlYWRlci5cbmZ1bmN0aW9uIFVuemlwKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFVuemlwKSkgcmV0dXJuIG5ldyBVbnppcChvcHRzKTtcbiAgWmxpYi5jYWxsKHRoaXMsIG9wdHMsIGJpbmRpbmcuVU5aSVApO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRmx1c2hGbGFnKGZsYWcpIHtcbiAgcmV0dXJuIGZsYWcgPT09IGJpbmRpbmcuWl9OT19GTFVTSCB8fCBmbGFnID09PSBiaW5kaW5nLlpfUEFSVElBTF9GTFVTSCB8fCBmbGFnID09PSBiaW5kaW5nLlpfU1lOQ19GTFVTSCB8fCBmbGFnID09PSBiaW5kaW5nLlpfRlVMTF9GTFVTSCB8fCBmbGFnID09PSBiaW5kaW5nLlpfRklOSVNIIHx8IGZsYWcgPT09IGJpbmRpbmcuWl9CTE9DSztcbn1cblxuLy8gdGhlIFpsaWIgY2xhc3MgdGhleSBhbGwgaW5oZXJpdCBmcm9tXG4vLyBUaGlzIHRoaW5nIG1hbmFnZXMgdGhlIHF1ZXVlIG9mIHJlcXVlc3RzLCBhbmQgcmV0dXJuc1xuLy8gdHJ1ZSBvciBmYWxzZSBpZiB0aGVyZSBpcyBhbnl0aGluZyBpbiB0aGUgcXVldWUgd2hlblxuLy8geW91IGNhbGwgdGhlIC53cml0ZSgpIG1ldGhvZC5cblxuZnVuY3Rpb24gWmxpYihvcHRzLCBtb2RlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5fb3B0cyA9IG9wdHMgPSBvcHRzIHx8IHt9O1xuICB0aGlzLl9jaHVua1NpemUgPSBvcHRzLmNodW5rU2l6ZSB8fCBleHBvcnRzLlpfREVGQVVMVF9DSFVOSztcblxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRzKTtcblxuICBpZiAob3B0cy5mbHVzaCAmJiAhaXNWYWxpZEZsdXNoRmxhZyhvcHRzLmZsdXNoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBmbHVzaCBmbGFnOiAnICsgb3B0cy5mbHVzaCk7XG4gIH1cbiAgaWYgKG9wdHMuZmluaXNoRmx1c2ggJiYgIWlzVmFsaWRGbHVzaEZsYWcob3B0cy5maW5pc2hGbHVzaCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZmx1c2ggZmxhZzogJyArIG9wdHMuZmluaXNoRmx1c2gpO1xuICB9XG5cbiAgdGhpcy5fZmx1c2hGbGFnID0gb3B0cy5mbHVzaCB8fCBiaW5kaW5nLlpfTk9fRkxVU0g7XG4gIHRoaXMuX2ZpbmlzaEZsdXNoRmxhZyA9IHR5cGVvZiBvcHRzLmZpbmlzaEZsdXNoICE9PSAndW5kZWZpbmVkJyA/IG9wdHMuZmluaXNoRmx1c2ggOiBiaW5kaW5nLlpfRklOSVNIO1xuXG4gIGlmIChvcHRzLmNodW5rU2l6ZSkge1xuICAgIGlmIChvcHRzLmNodW5rU2l6ZSA8IGV4cG9ydHMuWl9NSU5fQ0hVTksgfHwgb3B0cy5jaHVua1NpemUgPiBleHBvcnRzLlpfTUFYX0NIVU5LKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2h1bmsgc2l6ZTogJyArIG9wdHMuY2h1bmtTaXplKTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0cy53aW5kb3dCaXRzKSB7XG4gICAgaWYgKG9wdHMud2luZG93Qml0cyA8IGV4cG9ydHMuWl9NSU5fV0lORE9XQklUUyB8fCBvcHRzLndpbmRvd0JpdHMgPiBleHBvcnRzLlpfTUFYX1dJTkRPV0JJVFMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB3aW5kb3dCaXRzOiAnICsgb3B0cy53aW5kb3dCaXRzKTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0cy5sZXZlbCkge1xuICAgIGlmIChvcHRzLmxldmVsIDwgZXhwb3J0cy5aX01JTl9MRVZFTCB8fCBvcHRzLmxldmVsID4gZXhwb3J0cy5aX01BWF9MRVZFTCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvbXByZXNzaW9uIGxldmVsOiAnICsgb3B0cy5sZXZlbCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdHMubWVtTGV2ZWwpIHtcbiAgICBpZiAob3B0cy5tZW1MZXZlbCA8IGV4cG9ydHMuWl9NSU5fTUVNTEVWRUwgfHwgb3B0cy5tZW1MZXZlbCA+IGV4cG9ydHMuWl9NQVhfTUVNTEVWRUwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZW1MZXZlbDogJyArIG9wdHMubWVtTGV2ZWwpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRzLnN0cmF0ZWd5KSB7XG4gICAgaWYgKG9wdHMuc3RyYXRlZ3kgIT0gZXhwb3J0cy5aX0ZJTFRFUkVEICYmIG9wdHMuc3RyYXRlZ3kgIT0gZXhwb3J0cy5aX0hVRkZNQU5fT05MWSAmJiBvcHRzLnN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9STEUgJiYgb3B0cy5zdHJhdGVneSAhPSBleHBvcnRzLlpfRklYRUQgJiYgb3B0cy5zdHJhdGVneSAhPSBleHBvcnRzLlpfREVGQVVMVF9TVFJBVEVHWSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmF0ZWd5OiAnICsgb3B0cy5zdHJhdGVneSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdHMuZGljdGlvbmFyeSkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKG9wdHMuZGljdGlvbmFyeSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkaWN0aW9uYXJ5OiBpdCBzaG91bGQgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9oYW5kbGUgPSBuZXcgYmluZGluZy5abGliKG1vZGUpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5faGFkRXJyb3IgPSBmYWxzZTtcbiAgdGhpcy5faGFuZGxlLm9uZXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgZXJybm8pIHtcbiAgICAvLyB0aGVyZSBpcyBubyB3YXkgdG8gY2xlYW5seSByZWNvdmVyLlxuICAgIC8vIGNvbnRpbnVpbmcgb25seSBvYnNjdXJlcyBwcm9ibGVtcy5cbiAgICBfY2xvc2Uoc2VsZik7XG4gICAgc2VsZi5faGFkRXJyb3IgPSB0cnVlO1xuXG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIGVycm9yLmVycm5vID0gZXJybm87XG4gICAgZXJyb3IuY29kZSA9IGV4cG9ydHMuY29kZXNbZXJybm9dO1xuICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gIH07XG5cbiAgdmFyIGxldmVsID0gZXhwb3J0cy5aX0RFRkFVTFRfQ09NUFJFU1NJT047XG4gIGlmICh0eXBlb2Ygb3B0cy5sZXZlbCA9PT0gJ251bWJlcicpIGxldmVsID0gb3B0cy5sZXZlbDtcblxuICB2YXIgc3RyYXRlZ3kgPSBleHBvcnRzLlpfREVGQVVMVF9TVFJBVEVHWTtcbiAgaWYgKHR5cGVvZiBvcHRzLnN0cmF0ZWd5ID09PSAnbnVtYmVyJykgc3RyYXRlZ3kgPSBvcHRzLnN0cmF0ZWd5O1xuXG4gIHRoaXMuX2hhbmRsZS5pbml0KG9wdHMud2luZG93Qml0cyB8fCBleHBvcnRzLlpfREVGQVVMVF9XSU5ET1dCSVRTLCBsZXZlbCwgb3B0cy5tZW1MZXZlbCB8fCBleHBvcnRzLlpfREVGQVVMVF9NRU1MRVZFTCwgc3RyYXRlZ3ksIG9wdHMuZGljdGlvbmFyeSk7XG5cbiAgdGhpcy5fYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKHRoaXMuX2NodW5rU2l6ZSk7XG4gIHRoaXMuX29mZnNldCA9IDA7XG4gIHRoaXMuX2xldmVsID0gbGV2ZWw7XG4gIHRoaXMuX3N0cmF0ZWd5ID0gc3RyYXRlZ3k7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCB0aGlzLmNsb3NlKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ19jbG9zZWQnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gIV90aGlzLl9oYW5kbGU7XG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxudXRpbC5pbmhlcml0cyhabGliLCBUcmFuc2Zvcm0pO1xuXG5abGliLnByb3RvdHlwZS5wYXJhbXMgPSBmdW5jdGlvbiAobGV2ZWwsIHN0cmF0ZWd5LCBjYWxsYmFjaykge1xuICBpZiAobGV2ZWwgPCBleHBvcnRzLlpfTUlOX0xFVkVMIHx8IGxldmVsID4gZXhwb3J0cy5aX01BWF9MRVZFTCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIGNvbXByZXNzaW9uIGxldmVsOiAnICsgbGV2ZWwpO1xuICB9XG4gIGlmIChzdHJhdGVneSAhPSBleHBvcnRzLlpfRklMVEVSRUQgJiYgc3RyYXRlZ3kgIT0gZXhwb3J0cy5aX0hVRkZNQU5fT05MWSAmJiBzdHJhdGVneSAhPSBleHBvcnRzLlpfUkxFICYmIHN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9GSVhFRCAmJiBzdHJhdGVneSAhPSBleHBvcnRzLlpfREVGQVVMVF9TVFJBVEVHWSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc3RyYXRlZ3k6ICcgKyBzdHJhdGVneSk7XG4gIH1cblxuICBpZiAodGhpcy5fbGV2ZWwgIT09IGxldmVsIHx8IHRoaXMuX3N0cmF0ZWd5ICE9PSBzdHJhdGVneSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmZsdXNoKGJpbmRpbmcuWl9TWU5DX0ZMVVNILCBmdW5jdGlvbiAoKSB7XG4gICAgICBhc3NlcnQoc2VsZi5faGFuZGxlLCAnemxpYiBiaW5kaW5nIGNsb3NlZCcpO1xuICAgICAgc2VsZi5faGFuZGxlLnBhcmFtcyhsZXZlbCwgc3RyYXRlZ3kpO1xuICAgICAgaWYgKCFzZWxmLl9oYWRFcnJvcikge1xuICAgICAgICBzZWxmLl9sZXZlbCA9IGxldmVsO1xuICAgICAgICBzZWxmLl9zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjayk7XG4gIH1cbn07XG5cblpsaWIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICBhc3NlcnQodGhpcy5faGFuZGxlLCAnemxpYiBiaW5kaW5nIGNsb3NlZCcpO1xuICByZXR1cm4gdGhpcy5faGFuZGxlLnJlc2V0KCk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBfZmx1c2ggZnVuY3Rpb24gY2FsbGVkIGJ5IHRoZSB0cmFuc2Zvcm0gY2xhc3MsXG4vLyBpbnRlcm5hbGx5LCB3aGVuIHRoZSBsYXN0IGNodW5rIGhhcyBiZWVuIHdyaXR0ZW4uXG5abGliLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdGhpcy5fdHJhbnNmb3JtKEJ1ZmZlci5hbGxvYygwKSwgJycsIGNhbGxiYWNrKTtcbn07XG5cblpsaWIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKGtpbmQsIGNhbGxiYWNrKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIHZhciB3cyA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBraW5kID09PSAnZnVuY3Rpb24nIHx8IGtpbmQgPT09IHVuZGVmaW5lZCAmJiAhY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGtpbmQ7XG4gICAga2luZCA9IGJpbmRpbmcuWl9GVUxMX0ZMVVNIO1xuICB9XG5cbiAgaWYgKHdzLmVuZGVkKSB7XG4gICAgaWYgKGNhbGxiYWNrKSBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrKTtcbiAgfSBlbHNlIGlmICh3cy5lbmRpbmcpIHtcbiAgICBpZiAoY2FsbGJhY2spIHRoaXMub25jZSgnZW5kJywgY2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKHdzLm5lZWREcmFpbikge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdGhpcy5vbmNlKCdkcmFpbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5mbHVzaChraW5kLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZmx1c2hGbGFnID0ga2luZDtcbiAgICB0aGlzLndyaXRlKEJ1ZmZlci5hbGxvYygwKSwgJycsIGNhbGxiYWNrKTtcbiAgfVxufTtcblxuWmxpYi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgX2Nsb3NlKHRoaXMsIGNhbGxiYWNrKTtcbiAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgdGhpcyk7XG59O1xuXG5mdW5jdGlvbiBfY2xvc2UoZW5naW5lLCBjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2spIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2spO1xuXG4gIC8vIENhbGxlciBtYXkgaW52b2tlIC5jbG9zZSBhZnRlciBhIHpsaWIgZXJyb3IgKHdoaWNoIHdpbGwgbnVsbCBfaGFuZGxlKS5cbiAgaWYgKCFlbmdpbmUuX2hhbmRsZSkgcmV0dXJuO1xuXG4gIGVuZ2luZS5faGFuZGxlLmNsb3NlKCk7XG4gIGVuZ2luZS5faGFuZGxlID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZW1pdENsb3NlTlQoc2VsZikge1xuICBzZWxmLmVtaXQoJ2Nsb3NlJyk7XG59XG5cblpsaWIucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgZmx1c2hGbGFnO1xuICB2YXIgd3MgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgZW5kaW5nID0gd3MuZW5kaW5nIHx8IHdzLmVuZGVkO1xuICB2YXIgbGFzdCA9IGVuZGluZyAmJiAoIWNodW5rIHx8IHdzLmxlbmd0aCA9PT0gY2h1bmsubGVuZ3RoKTtcblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHJldHVybiBjYihuZXcgRXJyb3IoJ2ludmFsaWQgaW5wdXQnKSk7XG5cbiAgaWYgKCF0aGlzLl9oYW5kbGUpIHJldHVybiBjYihuZXcgRXJyb3IoJ3psaWIgYmluZGluZyBjbG9zZWQnKSk7XG5cbiAgLy8gSWYgaXQncyB0aGUgbGFzdCBjaHVuaywgb3IgYSBmaW5hbCBmbHVzaCwgd2UgdXNlIHRoZSBaX0ZJTklTSCBmbHVzaCBmbGFnXG4gIC8vIChvciB3aGF0ZXZlciBmbGFnIHdhcyBwcm92aWRlZCB1c2luZyBvcHRzLmZpbmlzaEZsdXNoKS5cbiAgLy8gSWYgaXQncyBleHBsaWNpdGx5IGZsdXNoaW5nIGF0IHNvbWUgb3RoZXIgdGltZSwgdGhlbiB3ZSB1c2VcbiAgLy8gWl9GVUxMX0ZMVVNILiBPdGhlcndpc2UsIHVzZSBaX05PX0ZMVVNIIGZvciBtYXhpbXVtIGNvbXByZXNzaW9uXG4gIC8vIGdvb2RuZXNzLlxuICBpZiAobGFzdCkgZmx1c2hGbGFnID0gdGhpcy5fZmluaXNoRmx1c2hGbGFnO2Vsc2Uge1xuICAgIGZsdXNoRmxhZyA9IHRoaXMuX2ZsdXNoRmxhZztcbiAgICAvLyBvbmNlIHdlJ3ZlIGZsdXNoZWQgdGhlIGxhc3Qgb2YgdGhlIHF1ZXVlLCBzdG9wIGZsdXNoaW5nIGFuZFxuICAgIC8vIGdvIGJhY2sgdG8gdGhlIG5vcm1hbCBiZWhhdmlvci5cbiAgICBpZiAoY2h1bmsubGVuZ3RoID49IHdzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fZmx1c2hGbGFnID0gdGhpcy5fb3B0cy5mbHVzaCB8fCBiaW5kaW5nLlpfTk9fRkxVU0g7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fcHJvY2Vzc0NodW5rKGNodW5rLCBmbHVzaEZsYWcsIGNiKTtcbn07XG5cblpsaWIucHJvdG90eXBlLl9wcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbiAoY2h1bmssIGZsdXNoRmxhZywgY2IpIHtcbiAgdmFyIGF2YWlsSW5CZWZvcmUgPSBjaHVuayAmJiBjaHVuay5sZW5ndGg7XG4gIHZhciBhdmFpbE91dEJlZm9yZSA9IHRoaXMuX2NodW5rU2l6ZSAtIHRoaXMuX29mZnNldDtcbiAgdmFyIGluT2ZmID0gMDtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIGFzeW5jID0gdHlwZW9mIGNiID09PSAnZnVuY3Rpb24nO1xuXG4gIGlmICghYXN5bmMpIHtcbiAgICB2YXIgYnVmZmVycyA9IFtdO1xuICAgIHZhciBucmVhZCA9IDA7XG5cbiAgICB2YXIgZXJyb3I7XG4gICAgdGhpcy5vbignZXJyb3InLCBmdW5jdGlvbiAoZXIpIHtcbiAgICAgIGVycm9yID0gZXI7XG4gICAgfSk7XG5cbiAgICBhc3NlcnQodGhpcy5faGFuZGxlLCAnemxpYiBiaW5kaW5nIGNsb3NlZCcpO1xuICAgIGRvIHtcbiAgICAgIHZhciByZXMgPSB0aGlzLl9oYW5kbGUud3JpdGVTeW5jKGZsdXNoRmxhZywgY2h1bmssIC8vIGluXG4gICAgICBpbk9mZiwgLy8gaW5fb2ZmXG4gICAgICBhdmFpbEluQmVmb3JlLCAvLyBpbl9sZW5cbiAgICAgIHRoaXMuX2J1ZmZlciwgLy8gb3V0XG4gICAgICB0aGlzLl9vZmZzZXQsIC8vb3V0X29mZlxuICAgICAgYXZhaWxPdXRCZWZvcmUpOyAvLyBvdXRfbGVuXG4gICAgfSB3aGlsZSAoIXRoaXMuX2hhZEVycm9yICYmIGNhbGxiYWNrKHJlc1swXSwgcmVzWzFdKSk7XG5cbiAgICBpZiAodGhpcy5faGFkRXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIGlmIChucmVhZCA+PSBrTWF4TGVuZ3RoKSB7XG4gICAgICBfY2xvc2UodGhpcyk7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihrUmFuZ2VFcnJvck1lc3NhZ2UpO1xuICAgIH1cblxuICAgIHZhciBidWYgPSBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMsIG5yZWFkKTtcbiAgICBfY2xvc2UodGhpcyk7XG5cbiAgICByZXR1cm4gYnVmO1xuICB9XG5cbiAgYXNzZXJ0KHRoaXMuX2hhbmRsZSwgJ3psaWIgYmluZGluZyBjbG9zZWQnKTtcbiAgdmFyIHJlcSA9IHRoaXMuX2hhbmRsZS53cml0ZShmbHVzaEZsYWcsIGNodW5rLCAvLyBpblxuICBpbk9mZiwgLy8gaW5fb2ZmXG4gIGF2YWlsSW5CZWZvcmUsIC8vIGluX2xlblxuICB0aGlzLl9idWZmZXIsIC8vIG91dFxuICB0aGlzLl9vZmZzZXQsIC8vb3V0X29mZlxuICBhdmFpbE91dEJlZm9yZSk7IC8vIG91dF9sZW5cblxuICByZXEuYnVmZmVyID0gY2h1bms7XG4gIHJlcS5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gIGZ1bmN0aW9uIGNhbGxiYWNrKGF2YWlsSW5BZnRlciwgYXZhaWxPdXRBZnRlcikge1xuICAgIC8vIFdoZW4gdGhlIGNhbGxiYWNrIGlzIHVzZWQgaW4gYW4gYXN5bmMgd3JpdGUsIHRoZSBjYWxsYmFjaydzXG4gICAgLy8gY29udGV4dCBpcyB0aGUgYHJlcWAgb2JqZWN0IHRoYXQgd2FzIGNyZWF0ZWQuIFRoZSByZXEgb2JqZWN0XG4gICAgLy8gaXMgPT09IHRoaXMuX2hhbmRsZSwgYW5kIHRoYXQncyB3aHkgaXQncyBpbXBvcnRhbnQgdG8gbnVsbFxuICAgIC8vIG91dCB0aGUgdmFsdWVzIGFmdGVyIHRoZXkgYXJlIGRvbmUgYmVpbmcgdXNlZC4gYHRoaXMuX2hhbmRsZWBcbiAgICAvLyBjYW4gc3RheSBpbiBtZW1vcnkgbG9uZ2VyIHRoYW4gdGhlIGNhbGxiYWNrIGFuZCBidWZmZXIgYXJlIG5lZWRlZC5cbiAgICBpZiAodGhpcykge1xuICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgICAgdGhpcy5jYWxsYmFjayA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHNlbGYuX2hhZEVycm9yKSByZXR1cm47XG5cbiAgICB2YXIgaGF2ZSA9IGF2YWlsT3V0QmVmb3JlIC0gYXZhaWxPdXRBZnRlcjtcbiAgICBhc3NlcnQoaGF2ZSA+PSAwLCAnaGF2ZSBzaG91bGQgbm90IGdvIGRvd24nKTtcblxuICAgIGlmIChoYXZlID4gMCkge1xuICAgICAgdmFyIG91dCA9IHNlbGYuX2J1ZmZlci5zbGljZShzZWxmLl9vZmZzZXQsIHNlbGYuX29mZnNldCArIGhhdmUpO1xuICAgICAgc2VsZi5fb2Zmc2V0ICs9IGhhdmU7XG4gICAgICAvLyBzZXJ2ZSBzb21lIG91dHB1dCB0byB0aGUgY29uc3VtZXIuXG4gICAgICBpZiAoYXN5bmMpIHtcbiAgICAgICAgc2VsZi5wdXNoKG91dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWZmZXJzLnB1c2gob3V0KTtcbiAgICAgICAgbnJlYWQgKz0gb3V0Lmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBleGhhdXN0ZWQgdGhlIG91dHB1dCBidWZmZXIsIG9yIHVzZWQgYWxsIHRoZSBpbnB1dCBjcmVhdGUgYSBuZXcgb25lLlxuICAgIGlmIChhdmFpbE91dEFmdGVyID09PSAwIHx8IHNlbGYuX29mZnNldCA+PSBzZWxmLl9jaHVua1NpemUpIHtcbiAgICAgIGF2YWlsT3V0QmVmb3JlID0gc2VsZi5fY2h1bmtTaXplO1xuICAgICAgc2VsZi5fb2Zmc2V0ID0gMDtcbiAgICAgIHNlbGYuX2J1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShzZWxmLl9jaHVua1NpemUpO1xuICAgIH1cblxuICAgIGlmIChhdmFpbE91dEFmdGVyID09PSAwKSB7XG4gICAgICAvLyBOb3QgYWN0dWFsbHkgZG9uZS4gIE5lZWQgdG8gcmVwcm9jZXNzLlxuICAgICAgLy8gQWxzbywgdXBkYXRlIHRoZSBhdmFpbEluQmVmb3JlIHRvIHRoZSBhdmFpbEluQWZ0ZXIgdmFsdWUsXG4gICAgICAvLyBzbyB0aGF0IGlmIHdlIGhhdmUgdG8gaGl0IGl0IGEgdGhpcmQgKGZvdXJ0aCwgZXRjLikgdGltZSxcbiAgICAgIC8vIGl0J2xsIGhhdmUgdGhlIGNvcnJlY3QgYnl0ZSBjb3VudHMuXG4gICAgICBpbk9mZiArPSBhdmFpbEluQmVmb3JlIC0gYXZhaWxJbkFmdGVyO1xuICAgICAgYXZhaWxJbkJlZm9yZSA9IGF2YWlsSW5BZnRlcjtcblxuICAgICAgaWYgKCFhc3luYykgcmV0dXJuIHRydWU7XG5cbiAgICAgIHZhciBuZXdSZXEgPSBzZWxmLl9oYW5kbGUud3JpdGUoZmx1c2hGbGFnLCBjaHVuaywgaW5PZmYsIGF2YWlsSW5CZWZvcmUsIHNlbGYuX2J1ZmZlciwgc2VsZi5fb2Zmc2V0LCBzZWxmLl9jaHVua1NpemUpO1xuICAgICAgbmV3UmVxLmNhbGxiYWNrID0gY2FsbGJhY2s7IC8vIHRoaXMgc2FtZSBmdW5jdGlvblxuICAgICAgbmV3UmVxLmJ1ZmZlciA9IGNodW5rO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghYXN5bmMpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIGZpbmlzaGVkIHdpdGggdGhlIGNodW5rLlxuICAgIGNiKCk7XG4gIH1cbn07XG5cbnV0aWwuaW5oZXJpdHMoRGVmbGF0ZSwgWmxpYik7XG51dGlsLmluaGVyaXRzKEluZmxhdGUsIFpsaWIpO1xudXRpbC5pbmhlcml0cyhHemlwLCBabGliKTtcbnV0aWwuaW5oZXJpdHMoR3VuemlwLCBabGliKTtcbnV0aWwuaW5oZXJpdHMoRGVmbGF0ZVJhdywgWmxpYik7XG51dGlsLmluaGVyaXRzKEluZmxhdGVSYXcsIFpsaWIpO1xudXRpbC5pbmhlcml0cyhVbnppcCwgWmxpYik7IiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbnZhciBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0geyBfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICE9IG51bGwgJiZcbiAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIHZhciB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB2YXIgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oXG4gICAgICB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoXG4gICAgKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbkJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbkJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgdmFyIGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBidWYgPSBCdWZmZXIuZnJvbShidWYpXG4gICAgfVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG4gICAgKVxuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXG4gIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcbiAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpXG4gIH0gZWxzZSBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuXG5mdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICBpZiAoQXJyYXkuaXNBcnJheSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZyk7XG4gIH1cbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSBCdWZmZXIuaXNCdWZmZXI7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBvYmplY3RDcmVhdGVQb2x5ZmlsbFxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBvYmplY3RLZXlzUG9seWZpbGxcbnZhciBiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgZnVuY3Rpb25CaW5kUG9seWZpbGxcblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdfZXZlbnRzJykpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxudmFyIGhhc0RlZmluZVByb3BlcnR5O1xudHJ5IHtcbiAgdmFyIG8gPSB7fTtcbiAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sICd4JywgeyB2YWx1ZTogMCB9KTtcbiAgaGFzRGVmaW5lUHJvcGVydHkgPSBvLnggPT09IDA7XG59IGNhdGNoIChlcnIpIHsgaGFzRGVmaW5lUHJvcGVydHkgPSBmYWxzZSB9XG5pZiAoaGFzRGVmaW5lUHJvcGVydHkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgICAgLy8gY2hlY2sgd2hldGhlciB0aGUgaW5wdXQgaXMgYSBwb3NpdGl2ZSBudW1iZXIgKHdob3NlIHZhbHVlIGlzIHplcm8gb3JcbiAgICAgIC8vIGdyZWF0ZXIgYW5kIG5vdCBhIE5hTikuXG4gICAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBhcmcgIT09IGFyZylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICAgICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBkZWZhdWx0TWF4TGlzdGVuZXJzO1xufVxuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiblwiIGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiAkZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiAkZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuLy8gVGhlc2Ugc3RhbmRhbG9uZSBlbWl0KiBmdW5jdGlvbnMgYXJlIHVzZWQgdG8gb3B0aW1pemUgY2FsbGluZyBvZiBldmVudFxuLy8gaGFuZGxlcnMgZm9yIGZhc3QgY2FzZXMgYmVjYXVzZSBlbWl0KCkgaXRzZWxmIG9mdGVuIGhhcyBhIHZhcmlhYmxlIG51bWJlciBvZlxuLy8gYXJndW1lbnRzIGFuZCBjYW4gYmUgZGVvcHRpbWl6ZWQgYmVjYXVzZSBvZiB0aGF0LiBUaGVzZSBmdW5jdGlvbnMgYWx3YXlzIGhhdmVcbi8vIHRoZSBzYW1lIG51bWJlciBvZiBhcmd1bWVudHMgYW5kIHRodXMgZG8gbm90IGdldCBkZW9wdGltaXplZCwgc28gdGhlIGNvZGVcbi8vIGluc2lkZSB0aGVtIGNhbiBleGVjdXRlIGZhc3Rlci5cbmZ1bmN0aW9uIGVtaXROb25lKGhhbmRsZXIsIGlzRm4sIHNlbGYpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZik7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRPbmUoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSkge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdFR3byhoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxLCBhcmcyKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxLCBhcmcyKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEsIGFyZzIpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0VGhyZWUoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0TWFueShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmdzKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuYXBwbHkoc2VsZiwgYXJncyk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBldmVudHM7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cylcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09IG51bGwpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSlcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmICghaGFuZGxlcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGlzRm4gPSB0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJztcbiAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgc3dpdGNoIChsZW4pIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICBjYXNlIDE6XG4gICAgICBlbWl0Tm9uZShoYW5kbGVyLCBpc0ZuLCB0aGlzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICAgIGVtaXRPbmUoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzpcbiAgICAgIGVtaXRUd28oaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0OlxuICAgICAgZW1pdFRocmVlKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10pO1xuICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICBkZWZhdWx0OlxuICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICBlbWl0TWFueShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKCFldmVudHMpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmICghZXhpc3RpbmcpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgICAgaWYgKHByZXBlbmQpIHtcbiAgICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIGlmICghZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBtID0gJGdldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgICAgaWYgKG0gJiYgbSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSkge1xuICAgICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgXCInICsgU3RyaW5nKHR5cGUpICsgJ1wiIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQuJyk7XG4gICAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gJ29iamVjdCcgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCclczogJXMnLCB3Lm5hbWUsIHcubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsIGFyZ3VtZW50c1swXSk7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsIGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKTtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgICBhcmd1bWVudHNbMl0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSlcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gYmluZC5jYWxsKG9uY2VXcmFwcGVyLCBzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKCFldmVudHMpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKCFsaXN0KVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKCFldmVudHMpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoIWV2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IG9iamVjdEtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoIWV2ZW50cylcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmICghZXZsaXN0ZW5lcilcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID8gdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0Lm93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuLy8gQWJvdXQgMS41eCBmYXN0ZXIgdGhhbiB0aGUgdHdvLWFyZyB2ZXJzaW9uIG9mIEFycmF5I3NwbGljZSgpLlxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAodmFyIGkgPSBpbmRleCwgayA9IGkgKyAxLCBuID0gbGlzdC5sZW5ndGg7IGsgPCBuOyBpICs9IDEsIGsgKz0gMSlcbiAgICBsaXN0W2ldID0gbGlzdFtrXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBvYmplY3RDcmVhdGVQb2x5ZmlsbChwcm90bykge1xuICB2YXIgRiA9IGZ1bmN0aW9uKCkge307XG4gIEYucHJvdG90eXBlID0gcHJvdG87XG4gIHJldHVybiBuZXcgRjtcbn1cbmZ1bmN0aW9uIG9iamVjdEtleXNQb2x5ZmlsbChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIgayBpbiBvYmopIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrKSkge1xuICAgIGtleXMucHVzaChrKTtcbiAgfVxuICByZXR1cm4gaztcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQmluZFBvbHlmaWxsKGNvbnRleHQpIHtcbiAgdmFyIGZuID0gdGhpcztcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsImZ1bmN0aW9uIHJlYWRVSW50MzIoYnVmZmVyLCBvZmZzZXQsIGJpZ0VuZGlhbikge1xuXHRpZiAoYnVmZmVyLnJlYWRVSW50MzIpIHtcblx0XHRyZXR1cm4gYnVmZmVyLnJlYWRVSW50MzIob2Zmc2V0LCBiaWdFbmRpYW4pO1xuXHR9XG5cblx0dmFyIHZhbHVlO1xuXHRpZiAoYmlnRW5kaWFuKSB7XG5cdFx0aWYgKGJ1ZmZlci5yZWFkVUludDMyQkUpIHtcblx0XHRcdHJldHVybiBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG5cdFx0fVxuXHRcdHZhbHVlID0gKGJ1ZmZlcltvZmZzZXRdIDw8IDI0KSArIChidWZmZXJbb2Zmc2V0KzFdIDw8IDE2KSArIChidWZmZXJbb2Zmc2V0KzJdIDw8IDgpICsgYnVmZmVyW29mZnNldCszXTtcblx0fVxuXHRlbHNlIHtcblx0XHRpZiAoYnVmZmVyLnJlYWRVSW50MzJMRSkge1xuXHRcdFx0cmV0dXJuIGJ1ZmZlci5yZWFkVUludDMyTEUob2Zmc2V0KTtcblx0XHR9XG5cdFx0dmFsdWUgPSBidWZmZXJbb2Zmc2V0XSArIChidWZmZXJbb2Zmc2V0KzFdIDw8IDgpICsgKGJ1ZmZlcltvZmZzZXQrMl0gPDwgMTYpICsgKGJ1ZmZlcltvZmZzZXQrM10gPDwgMjQpO1xuXHR9XG5cdHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gcmVhZFVJbnQxNihidWZmZXIsIG9mZnNldCwgYmlnRW5kaWFuKSB7XG5cdGlmIChidWZmZXIucmVhZFVJbnQxNikge1xuXHRcdHJldHVybiBidWZmZXIucmVhZFVJbnQxNihvZmZzZXQsIGJpZ0VuZGlhbik7XG5cdH1cblxuXHR2YXIgdmFsdWU7XG5cdGlmIChiaWdFbmRpYW4pIHtcblx0XHRpZiAoYnVmZmVyLnJlYWRVSW50MTZCRSkge1xuXHRcdFx0cmV0dXJuIGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcblx0XHR9XG5cdFx0dmFsdWUgPSAoYnVmZmVyW29mZnNldF0gPDwgOCkgKyBidWZmZXJbb2Zmc2V0KzFdO1xuXHR9XG5cdGVsc2Uge1xuXHRcdGlmIChidWZmZXIucmVhZFVJbnQxNkxFKSB7XG5cdFx0XHRyZXR1cm4gYnVmZmVyLnJlYWRVSW50MTZMRShvZmZzZXQpO1xuXHRcdH1cblx0XHR2YWx1ZSA9IGJ1ZmZlcltvZmZzZXRdICsgKGJ1ZmZlcltvZmZzZXQrMV0gPDwgOCk7XG5cdH1cblx0cmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiByZWFkQml0KGJ1ZmZlciwgb2Zmc2V0LCBiaXRPZmZzZXQpIHtcblx0aWYgKGJpdE9mZnNldCA+IDcpIHtcblx0XHRvZmZzZXQgKz0gTWF0aC5mbG9vcihiaXRPZmZzZXQgLyA4KTtcblx0XHRiaXRPZmZzZXQgPSBiaXRPZmZzZXQgJSA4O1xuXHR9XG5cblx0dmFyIGIgPSBidWZmZXJbb2Zmc2V0XTtcblx0aWYgKGJpdE9mZnNldCA8IDcpIHtcblx0XHRiID4+Pj0gKDcgLSBiaXRPZmZzZXQpO1xuXHR9XG5cblx0dmFyIHZhbCA9IGIgJiAweDAxO1xuXHRyZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiByZWFkQml0cyhidWZmZXIsIG9mZnNldCwgYml0T2Zmc2V0LCBiaXRMZW4sIHNpZ25lZCkge1xuXHR2YXIgdmFsID0gMDtcblx0XG5cdHZhciBuZWcgPSBmYWxzZTtcblx0aWYgKHNpZ25lZCkge1xuXHRcdGlmIChyZWFkQml0KGJ1ZmZlciwgb2Zmc2V0LCBiaXRPZmZzZXQpID4gMCkge1xuXHRcdFx0bmVnID0gdHJ1ZTtcblx0XHR9XG5cdFx0Yml0TGVuLS07XG5cdFx0Yml0T2Zmc2V0Kys7XG5cdH1cblxuXHR2YXIgYnl0ZXMgPSBbXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBiaXRMZW47IGkrKykge1xuXHRcdHZhciBiID0gcmVhZEJpdChidWZmZXIsIG9mZnNldCwgYml0T2Zmc2V0ICsgaSk7XG5cdFx0aWYgKGk+MCAmJiAoYml0TGVuIC0gaSkgJSA4ID09IDApIHtcblx0XHRcdGJ5dGVzLnB1c2godmFsKTtcblx0XHRcdHZhbCA9IDA7XG5cdFx0fVxuXHRcdHZhbCA8PD0gMTtcblx0XHR2YWwgfD0gYjtcblx0fVxuXHRieXRlcy5wdXNoKHZhbCk7XG5cblx0dmFsID0gbmV3IEJ1ZmZlcihieXRlcyk7XG5cdHZhbC5uZWdhdGl2ZSA9IG5lZz90cnVlOmZhbHNlO1xuXHRyZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBpbWFnZUluZm9QbmcoYnVmZmVyKSB7XG5cdHZhciBpbWFnZUhlYWRlciA9IFsweDQ5LCAweDQ4LCAweDQ0LCAweDUyXSxcblx0XHRwb3MgPSAxMjtcblxuXHRpZiAoIWNoZWNrU2lnKGJ1ZmZlciwgcG9zLCBpbWFnZUhlYWRlcikpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRwb3MgKz0gNDtcblx0cmV0dXJuIHtcblx0XHR0eXBlOiAnaW1hZ2UnLFxuXHRcdGZvcm1hdDogJ1BORycsXG5cdFx0bWltZVR5cGU6ICdpbWFnZS9wbmcnLFxuXHRcdHdpZHRoOiByZWFkVUludDMyKGJ1ZmZlciwgcG9zLCB0cnVlKSxcblx0XHRoZWlnaHQ6IHJlYWRVSW50MzIoYnVmZmVyLCBwb3MrNCwgdHJ1ZSksXG5cdH07XG59XG5cbmZ1bmN0aW9uIGltYWdlSW5mb0pwZyhidWZmZXIpIHtcblx0dmFyIHBvcyA9IDIsXG5cdFx0bGVuID0gYnVmZmVyLmxlbmd0aCxcblx0XHRzaXplU2lnID0gWzB4ZmYsIFsweGMwLCAweGMyXV07XG5cblx0d2hpbGUgKHBvcyA8IGxlbikge1xuXHRcdGlmIChjaGVja1NpZyhidWZmZXIsIHBvcywgc2l6ZVNpZykpIHtcblx0XHRcdHBvcyArPSA1O1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dHlwZTogJ2ltYWdlJyxcblx0XHRcdFx0Zm9ybWF0OiAnSlBHJyxcblx0XHRcdFx0bWltZVR5cGU6ICdpbWFnZS9qcGVnJyxcblx0XHRcdFx0d2lkdGg6IHJlYWRVSW50MTYoYnVmZmVyLCBwb3MrMiwgdHJ1ZSksXG5cdFx0XHRcdGhlaWdodDogcmVhZFVJbnQxNihidWZmZXIsIHBvcywgdHJ1ZSksXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHBvcyArPSAyO1xuXHRcdHZhciBzaXplID0gcmVhZFVJbnQxNihidWZmZXIsIHBvcywgdHJ1ZSk7XG5cdFx0cG9zICs9IHNpemU7XG5cdH1cbn1cblxuZnVuY3Rpb24gaW1hZ2VJbmZvR2lmKGJ1ZmZlcikge1xuXHR2YXIgcG9zID0gNjtcblxuXHRyZXR1cm4ge1xuXHRcdHR5cGU6ICdpbWFnZScsXG5cdFx0Zm9ybWF0OiAnR0lGJyxcblx0XHRtaW1lVHlwZTogJ2ltYWdlL2dpZicsXG5cdFx0d2lkdGg6IHJlYWRVSW50MTYoYnVmZmVyLCBwb3MsIGZhbHNlKSxcblx0XHRoZWlnaHQ6IHJlYWRVSW50MTYoYnVmZmVyLCBwb3MrMiwgZmFsc2UpLFxuXHR9O1xufVxuXG5mdW5jdGlvbiBpbWFnZUluZm9Td2YoYnVmZmVyKSB7XG5cdHZhciBwb3MgPSA4LFxuXHRcdGJpdFBvcyA9IDAsXG5cdFx0dmFsO1xuXG5cdGlmIChidWZmZXJbMF0gPT09IDB4NDMpIHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gSWYgeW91IGhhdmUgemxpYiBhdmFpbGFibGUgKCBucG0gaW5zdGFsbCB6bGliICkgdGhlbiB3ZSBjYW4gcmVhZCBjb21wcmVzc2VkIGZsYXNoIGZpbGVzXG5cdFx0XHRidWZmZXIgPSByZXF1aXJlKCd6bGliJykuaW5mbGF0ZShidWZmZXIuc2xpY2UoOCwgMTAwKSk7XG5cdFx0XHRwb3MgPSAwO1xuXHRcdH1cblx0XHRjYXRjaCAoZXgpIHtcblx0XHRcdC8vIENhbid0IGdldCB3aWR0aC9oZWlnaHQgb2YgY29tcHJlc3NlZCBmbGFzaCBmaWxlcy4uLiB5ZXQgKG5lZWQgemxpYilcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHR5cGU6ICdmbGFzaCcsXG5cdFx0XHRcdGZvcm1hdDogJ1NXRicsXG5cdFx0XHRcdG1pbWVUeXBlOiAnYXBwbGljYXRpb24veC1zaG9ja3dhdmUtZmxhc2gnLFxuXHRcdFx0XHR3aWR0aDogbnVsbCxcblx0XHRcdFx0aGVpZ2h0OiBudWxsLFxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHZhciBudW1CaXRzID0gcmVhZEJpdHMoYnVmZmVyLCBwb3MsIGJpdFBvcywgNSlbMF07XG5cdGJpdFBvcyArPSA1O1xuXHRcblx0dmFsID0gcmVhZEJpdHMoYnVmZmVyLCBwb3MsIGJpdFBvcywgbnVtQml0cywgdHJ1ZSk7XG5cdHZhciB4TWluID0gKG51bUJpdHMgPiA5ID8gcmVhZFVJbnQxNih2YWwsIDAsIHRydWUpIDogdmFsWzBdKSAqICh2YWwubmVnYXRpdmUgPyAtMSA6IDEpO1xuXHRiaXRQb3MgKz0gbnVtQml0cztcblxuXHR2YWwgPSByZWFkQml0cyhidWZmZXIsIHBvcywgYml0UG9zLCBudW1CaXRzLCB0cnVlKTtcblx0dmFyIHhNYXggPSAobnVtQml0cyA+IDkgPyByZWFkVUludDE2KHZhbCwgMCwgdHJ1ZSkgOiB2YWxbMF0pICogKHZhbC5uZWdhdGl2ZSA/IC0xIDogMSk7XG5cdGJpdFBvcyArPSBudW1CaXRzO1xuXG5cdHZhbCA9IHJlYWRCaXRzKGJ1ZmZlciwgcG9zLCBiaXRQb3MsIG51bUJpdHMsIHRydWUpO1xuXHR2YXIgeU1pbiA9IChudW1CaXRzID4gOSA/IHJlYWRVSW50MTYodmFsLCAwLCB0cnVlKSA6IHZhbFswXSkgKiAodmFsLm5lZ2F0aXZlID8gLTEgOiAxKTtcblx0Yml0UG9zICs9IG51bUJpdHM7XG5cblx0dmFsID0gcmVhZEJpdHMoYnVmZmVyLCBwb3MsIGJpdFBvcywgbnVtQml0cywgdHJ1ZSk7XG5cdHZhciB5TWF4ID0gKG51bUJpdHMgPiA5ID8gcmVhZFVJbnQxNih2YWwsIDAsIHRydWUpIDogdmFsWzBdKSAqICh2YWwubmVnYXRpdmUgPyAtMSA6IDEpO1xuXG5cdHJldHVybiB7XG5cdFx0dHlwZTogJ2ZsYXNoJyxcblx0XHRmb3JtYXQ6ICdTV0YnLFxuXHRcdG1pbWVUeXBlOiAnYXBwbGljYXRpb24veC1zaG9ja3dhdmUtZmxhc2gnLFxuXHRcdHdpZHRoOiBNYXRoLmNlaWwoKHhNYXggLSB4TWluKSAvIDIwKSxcblx0XHRoZWlnaHQ6IE1hdGguY2VpbCgoeU1heCAtIHlNaW4pIC8gMjApLFxuXHR9O1xufVxuXG5mdW5jdGlvbiBjaGVja1NpZyhidWZmZXIsIG9mZnNldCwgc2lnKSB7XG5cdHZhciBsZW4gPSBzaWcubGVuZ3RoO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0dmFyIGIgPSBidWZmZXJbaStvZmZzZXRdLFxuXHRcdFx0cyA9IHNpZ1tpXSxcblx0XHRcdG0gPSBmYWxzZTtcblxuXHRcdGlmICgnbnVtYmVyJyA9PSB0eXBlb2Ygcykge1xuXHRcdFx0bSA9IHMgPT09IGI7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Zm9yICh2YXIgayBpbiBzKSB7XG5cdFx0XHRcdHZhciBvID0gc1trXTtcblx0XHRcdFx0aWYgKG8gPT09IGIpIHtcblx0XHRcdFx0XHRtID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICghbSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGltYWdlSW5mbyhidWZmZXIsIHBhdGgpIHtcblx0dmFyIHBuZ1NpZyA9IFsweDg5LCAweDUwLCAweDRlLCAweDQ3LCAweDBkLCAweDBhLCAweDFhLCAweDBhXTtcblx0dmFyIGpwZ1NpZyA9IFsweGZmLCAweGQ4LCAweGZmXTtcblx0dmFyIGdpZlNpZyA9IFsweDQ3LCAweDQ5LCAweDQ2LCAweDM4LCBbMHgzNywgMHgzOV0sIDB4NjFdO1xuXHR2YXIgc3dmU2lnID0gW1sweDQ2LCAweDQzXSwgMHg1NywgMHg1M107XG5cblx0aWYgKGNoZWNrU2lnKGJ1ZmZlciwgMCwgcG5nU2lnKSkgcmV0dXJuIGltYWdlSW5mb1BuZyhidWZmZXIpO1xuXHRpZiAoY2hlY2tTaWcoYnVmZmVyLCAwLCBqcGdTaWcpKSByZXR1cm4gaW1hZ2VJbmZvSnBnKGJ1ZmZlcik7XG5cdGlmIChjaGVja1NpZyhidWZmZXIsIDAsIGdpZlNpZykpIHJldHVybiBpbWFnZUluZm9HaWYoYnVmZmVyKTtcblx0aWYgKGNoZWNrU2lnKGJ1ZmZlciwgMCwgc3dmU2lnKSkgcmV0dXJuIGltYWdlSW5mb1N3ZihidWZmZXIpO1xuXG5cdHJldHVybiBmYWxzZTtcbn07XG5cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICB9XG4gIH1cbn1cbiIsIi8qIVxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxuLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiAoaXNCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSB8fCAhIW9iai5faXNCdWZmZXIpXG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyIChvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKVxufVxuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBUWVBFRF9PSyA9ICAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgVWludDE2QXJyYXkgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgSW50MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcpO1xuXG5mdW5jdGlvbiBfaGFzKG9iaiwga2V5KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuXG5leHBvcnRzLmFzc2lnbiA9IGZ1bmN0aW9uIChvYmogLypmcm9tMSwgZnJvbTIsIGZyb20zLCAuLi4qLykge1xuICB2YXIgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHdoaWxlIChzb3VyY2VzLmxlbmd0aCkge1xuICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCk7XG4gICAgaWYgKCFzb3VyY2UpIHsgY29udGludWU7IH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzb3VyY2UgKyAnbXVzdCBiZSBub24tb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcCBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChfaGFzKHNvdXJjZSwgcCkpIHtcbiAgICAgICAgb2JqW3BdID0gc291cmNlW3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5cbi8vIHJlZHVjZSBidWZmZXIgc2l6ZSwgYXZvaWRpbmcgbWVtIGNvcHlcbmV4cG9ydHMuc2hyaW5rQnVmID0gZnVuY3Rpb24gKGJ1Ziwgc2l6ZSkge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gc2l6ZSkgeyByZXR1cm4gYnVmOyB9XG4gIGlmIChidWYuc3ViYXJyYXkpIHsgcmV0dXJuIGJ1Zi5zdWJhcnJheSgwLCBzaXplKTsgfVxuICBidWYubGVuZ3RoID0gc2l6ZTtcbiAgcmV0dXJuIGJ1Zjtcbn07XG5cblxudmFyIGZuVHlwZWQgPSB7XG4gIGFycmF5U2V0OiBmdW5jdGlvbiAoZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHtcbiAgICBpZiAoc3JjLnN1YmFycmF5ICYmIGRlc3Quc3ViYXJyYXkpIHtcbiAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNfb2Zmcywgc3JjX29mZnMgKyBsZW4pLCBkZXN0X29mZnMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBGYWxsYmFjayB0byBvcmRpbmFyeSBhcnJheVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RbZGVzdF9vZmZzICsgaV0gPSBzcmNbc3JjX29mZnMgKyBpXTtcbiAgICB9XG4gIH0sXG4gIC8vIEpvaW4gYXJyYXkgb2YgY2h1bmtzIHRvIHNpbmdsZSBhcnJheS5cbiAgZmxhdHRlbkNodW5rczogZnVuY3Rpb24gKGNodW5rcykge1xuICAgIHZhciBpLCBsLCBsZW4sIHBvcywgY2h1bmssIHJlc3VsdDtcblxuICAgIC8vIGNhbGN1bGF0ZSBkYXRhIGxlbmd0aFxuICAgIGxlbiA9IDA7XG4gICAgZm9yIChpID0gMCwgbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGxlbiArPSBjaHVua3NbaV0ubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIGpvaW4gY2h1bmtzXG4gICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICBwb3MgPSAwO1xuICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjaHVuayA9IGNodW5rc1tpXTtcbiAgICAgIHJlc3VsdC5zZXQoY2h1bmssIHBvcyk7XG4gICAgICBwb3MgKz0gY2h1bmsubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbnZhciBmblVudHlwZWQgPSB7XG4gIGFycmF5U2V0OiBmdW5jdGlvbiAoZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07XG4gICAgfVxuICB9LFxuICAvLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuXG4gIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uIChjaHVua3MpIHtcbiAgICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCBjaHVua3MpO1xuICB9XG59O1xuXG5cbi8vIEVuYWJsZS9EaXNhYmxlIHR5cGVkIGFycmF5cyB1c2UsIGZvciB0ZXN0aW5nXG4vL1xuZXhwb3J0cy5zZXRUeXBlZCA9IGZ1bmN0aW9uIChvbikge1xuICBpZiAob24pIHtcbiAgICBleHBvcnRzLkJ1ZjggID0gVWludDhBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjE2ID0gVWludDE2QXJyYXk7XG4gICAgZXhwb3J0cy5CdWYzMiA9IEludDMyQXJyYXk7XG4gICAgZXhwb3J0cy5hc3NpZ24oZXhwb3J0cywgZm5UeXBlZCk7XG4gIH0gZWxzZSB7XG4gICAgZXhwb3J0cy5CdWY4ICA9IEFycmF5O1xuICAgIGV4cG9ydHMuQnVmMTYgPSBBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjMyID0gQXJyYXk7XG4gICAgZXhwb3J0cy5hc3NpZ24oZXhwb3J0cywgZm5VbnR5cGVkKTtcbiAgfVxufTtcblxuZXhwb3J0cy5zZXRUeXBlZChUWVBFRF9PSyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIE5vdGU6IGFkbGVyMzIgdGFrZXMgMTIlIGZvciBsZXZlbCAwIGFuZCAyJSBmb3IgbGV2ZWwgNi5cbi8vIEl0IGlzbid0IHdvcnRoIGl0IHRvIG1ha2UgYWRkaXRpb25hbCBvcHRpbWl6YXRpb25zIGFzIGluIG9yaWdpbmFsLlxuLy8gU21hbGwgc2l6ZSBpcyBwcmVmZXJhYmxlLlxuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIGFkbGVyMzIoYWRsZXIsIGJ1ZiwgbGVuLCBwb3MpIHtcbiAgdmFyIHMxID0gKGFkbGVyICYgMHhmZmZmKSB8MCxcbiAgICAgIHMyID0gKChhZGxlciA+Pj4gMTYpICYgMHhmZmZmKSB8MCxcbiAgICAgIG4gPSAwO1xuXG4gIHdoaWxlIChsZW4gIT09IDApIHtcbiAgICAvLyBTZXQgbGltaXQgfiB0d2ljZSBsZXNzIHRoYW4gNTU1MiwgdG8ga2VlcFxuICAgIC8vIHMyIGluIDMxLWJpdHMsIGJlY2F1c2Ugd2UgZm9yY2Ugc2lnbmVkIGludHMuXG4gICAgLy8gaW4gb3RoZXIgY2FzZSAlPSB3aWxsIGZhaWwuXG4gICAgbiA9IGxlbiA+IDIwMDAgPyAyMDAwIDogbGVuO1xuICAgIGxlbiAtPSBuO1xuXG4gICAgZG8ge1xuICAgICAgczEgPSAoczEgKyBidWZbcG9zKytdKSB8MDtcbiAgICAgIHMyID0gKHMyICsgczEpIHwwO1xuICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICBzMSAlPSA2NTUyMTtcbiAgICBzMiAlPSA2NTUyMTtcbiAgfVxuXG4gIHJldHVybiAoczEgfCAoczIgPDwgMTYpKSB8MDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkbGVyMzI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xuICBaX05PX0ZMVVNIOiAgICAgICAgIDAsXG4gIFpfUEFSVElBTF9GTFVTSDogICAgMSxcbiAgWl9TWU5DX0ZMVVNIOiAgICAgICAyLFxuICBaX0ZVTExfRkxVU0g6ICAgICAgIDMsXG4gIFpfRklOSVNIOiAgICAgICAgICAgNCxcbiAgWl9CTE9DSzogICAgICAgICAgICA1LFxuICBaX1RSRUVTOiAgICAgICAgICAgIDYsXG5cbiAgLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAgKi9cbiAgWl9PSzogICAgICAgICAgICAgICAwLFxuICBaX1NUUkVBTV9FTkQ6ICAgICAgIDEsXG4gIFpfTkVFRF9ESUNUOiAgICAgICAgMixcbiAgWl9FUlJOTzogICAgICAgICAgIC0xLFxuICBaX1NUUkVBTV9FUlJPUjogICAgLTIsXG4gIFpfREFUQV9FUlJPUjogICAgICAtMyxcbiAgLy9aX01FTV9FUlJPUjogICAgIC00LFxuICBaX0JVRl9FUlJPUjogICAgICAgLTUsXG4gIC8vWl9WRVJTSU9OX0VSUk9SOiAtNixcblxuICAvKiBjb21wcmVzc2lvbiBsZXZlbHMgKi9cbiAgWl9OT19DT01QUkVTU0lPTjogICAgICAgICAwLFxuICBaX0JFU1RfU1BFRUQ6ICAgICAgICAgICAgIDEsXG4gIFpfQkVTVF9DT01QUkVTU0lPTjogICAgICAgOSxcbiAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OOiAgIC0xLFxuXG5cbiAgWl9GSUxURVJFRDogICAgICAgICAgICAgICAxLFxuICBaX0hVRkZNQU5fT05MWTogICAgICAgICAgIDIsXG4gIFpfUkxFOiAgICAgICAgICAgICAgICAgICAgMyxcbiAgWl9GSVhFRDogICAgICAgICAgICAgICAgICA0LFxuICBaX0RFRkFVTFRfU1RSQVRFR1k6ICAgICAgIDAsXG5cbiAgLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuICBaX0JJTkFSWTogICAgICAgICAgICAgICAgIDAsXG4gIFpfVEVYVDogICAgICAgICAgICAgICAgICAgMSxcbiAgLy9aX0FTQ0lJOiAgICAgICAgICAgICAgICAxLCAvLyA9IFpfVEVYVCAoZGVwcmVjYXRlZClcbiAgWl9VTktOT1dOOiAgICAgICAgICAgICAgICAyLFxuXG4gIC8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xuICBaX0RFRkxBVEVEOiAgICAgICAgICAgICAgIDhcbiAgLy9aX05VTEw6ICAgICAgICAgICAgICAgICBudWxsIC8vIFVzZSAtMSBvciBudWxsIGlubGluZSwgZGVwZW5kaW5nIG9uIHZhciB0eXBlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBOb3RlOiB3ZSBjYW4ndCBnZXQgc2lnbmlmaWNhbnQgc3BlZWQgYm9vc3QgaGVyZS5cbi8vIFNvIHdyaXRlIGNvZGUgdG8gbWluaW1pemUgc2l6ZSAtIG5vIHByZWdlbmVyYXRlZCB0YWJsZXNcbi8vIGFuZCBhcnJheSB0b29scyBkZXBlbmRlbmNpZXMuXG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLy8gVXNlIG9yZGluYXJ5IGFycmF5LCBzaW5jZSB1bnR5cGVkIG1ha2VzIG5vIGJvb3N0IGhlcmVcbmZ1bmN0aW9uIG1ha2VUYWJsZSgpIHtcbiAgdmFyIGMsIHRhYmxlID0gW107XG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCAyNTY7IG4rKykge1xuICAgIGMgPSBuO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgODsgaysrKSB7XG4gICAgICBjID0gKChjICYgMSkgPyAoMHhFREI4ODMyMCBeIChjID4+PiAxKSkgOiAoYyA+Pj4gMSkpO1xuICAgIH1cbiAgICB0YWJsZVtuXSA9IGM7XG4gIH1cblxuICByZXR1cm4gdGFibGU7XG59XG5cbi8vIENyZWF0ZSB0YWJsZSBvbiBsb2FkLiBKdXN0IDI1NSBzaWduZWQgbG9uZ3MuIE5vdCBhIHByb2JsZW0uXG52YXIgY3JjVGFibGUgPSBtYWtlVGFibGUoKTtcblxuXG5mdW5jdGlvbiBjcmMzMihjcmMsIGJ1ZiwgbGVuLCBwb3MpIHtcbiAgdmFyIHQgPSBjcmNUYWJsZSxcbiAgICAgIGVuZCA9IHBvcyArIGxlbjtcblxuICBjcmMgXj0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IHBvczsgaSA8IGVuZDsgaSsrKSB7XG4gICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0WyhjcmMgXiBidWZbaV0pICYgMHhGRl07XG4gIH1cblxuICByZXR1cm4gKGNyYyBeICgtMSkpOyAvLyA+Pj4gMDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyYzMyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbnZhciB1dGlscyAgID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG52YXIgdHJlZXMgICA9IHJlcXVpcmUoJy4vdHJlZXMnKTtcbnZhciBhZGxlcjMyID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG52YXIgY3JjMzIgICA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbnZhciBtc2cgICAgID0gcmVxdWlyZSgnLi9tZXNzYWdlcycpO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG52YXIgWl9OT19GTFVTSCAgICAgID0gMDtcbnZhciBaX1BBUlRJQUxfRkxVU0ggPSAxO1xuLy92YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcbnZhciBaX0ZVTExfRkxVU0ggICAgPSAzO1xudmFyIFpfRklOSVNIICAgICAgICA9IDQ7XG52YXIgWl9CTE9DSyAgICAgICAgID0gNTtcbi8vdmFyIFpfVFJFRVMgICAgICAgICA9IDY7XG5cblxuLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICovXG52YXIgWl9PSyAgICAgICAgICAgID0gMDtcbnZhciBaX1NUUkVBTV9FTkQgICAgPSAxO1xuLy92YXIgWl9ORUVEX0RJQ1QgICAgID0gMjtcbi8vdmFyIFpfRVJSTk8gICAgICAgICA9IC0xO1xudmFyIFpfU1RSRUFNX0VSUk9SICA9IC0yO1xudmFyIFpfREFUQV9FUlJPUiAgICA9IC0zO1xuLy92YXIgWl9NRU1fRVJST1IgICAgID0gLTQ7XG52YXIgWl9CVUZfRVJST1IgICAgID0gLTU7XG4vL3ZhciBaX1ZFUlNJT05fRVJST1IgPSAtNjtcblxuXG4vKiBjb21wcmVzc2lvbiBsZXZlbHMgKi9cbi8vdmFyIFpfTk9fQ09NUFJFU1NJT04gICAgICA9IDA7XG4vL3ZhciBaX0JFU1RfU1BFRUQgICAgICAgICAgPSAxO1xuLy92YXIgWl9CRVNUX0NPTVBSRVNTSU9OICAgID0gOTtcbnZhciBaX0RFRkFVTFRfQ09NUFJFU1NJT04gPSAtMTtcblxuXG52YXIgWl9GSUxURVJFRCAgICAgICAgICAgID0gMTtcbnZhciBaX0hVRkZNQU5fT05MWSAgICAgICAgPSAyO1xudmFyIFpfUkxFICAgICAgICAgICAgICAgICA9IDM7XG52YXIgWl9GSVhFRCAgICAgICAgICAgICAgID0gNDtcbnZhciBaX0RFRkFVTFRfU1RSQVRFR1kgICAgPSAwO1xuXG4vKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG4vL3ZhciBaX0JJTkFSWSAgICAgICAgICAgICAgPSAwO1xuLy92YXIgWl9URVhUICAgICAgICAgICAgICAgID0gMTtcbi8vdmFyIFpfQVNDSUkgICAgICAgICAgICAgICA9IDE7IC8vID0gWl9URVhUXG52YXIgWl9VTktOT1dOICAgICAgICAgICAgID0gMjtcblxuXG4vKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbnZhciBaX0RFRkxBVEVEICA9IDg7XG5cbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxudmFyIE1BWF9NRU1fTEVWRUwgPSA5O1xuLyogTWF4aW11bSB2YWx1ZSBmb3IgbWVtTGV2ZWwgaW4gZGVmbGF0ZUluaXQyICovXG52YXIgTUFYX1dCSVRTID0gMTU7XG4vKiAzMksgTFo3NyB3aW5kb3cgKi9cbnZhciBERUZfTUVNX0xFVkVMID0gODtcblxuXG52YXIgTEVOR1RIX0NPREVTICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG52YXIgTElURVJBTFMgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xudmFyIExfQ09ERVMgICAgICAgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7XG4vKiBudW1iZXIgb2YgTGl0ZXJhbCBvciBMZW5ndGggY29kZXMsIGluY2x1ZGluZyB0aGUgRU5EX0JMT0NLIGNvZGUgKi9cbnZhciBEX0NPREVTICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cbnZhciBCTF9DT0RFUyAgICAgID0gMTk7XG4vKiBudW1iZXIgb2YgY29kZXMgdXNlZCB0byB0cmFuc2ZlciB0aGUgYml0IGxlbmd0aHMgKi9cbnZhciBIRUFQX1NJWkUgICAgID0gMiAqIExfQ09ERVMgKyAxO1xuLyogbWF4aW11bSBoZWFwIHNpemUgKi9cbnZhciBNQVhfQklUUyAgPSAxNTtcbi8qIEFsbCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JJVFMgYml0cyAqL1xuXG52YXIgTUlOX01BVENIID0gMztcbnZhciBNQVhfTUFUQ0ggPSAyNTg7XG52YXIgTUlOX0xPT0tBSEVBRCA9IChNQVhfTUFUQ0ggKyBNSU5fTUFUQ0ggKyAxKTtcblxudmFyIFBSRVNFVF9ESUNUID0gMHgyMDtcblxudmFyIElOSVRfU1RBVEUgPSA0MjtcbnZhciBFWFRSQV9TVEFURSA9IDY5O1xudmFyIE5BTUVfU1RBVEUgPSA3MztcbnZhciBDT01NRU5UX1NUQVRFID0gOTE7XG52YXIgSENSQ19TVEFURSA9IDEwMztcbnZhciBCVVNZX1NUQVRFID0gMTEzO1xudmFyIEZJTklTSF9TVEFURSA9IDY2NjtcblxudmFyIEJTX05FRURfTU9SRSAgICAgID0gMTsgLyogYmxvY2sgbm90IGNvbXBsZXRlZCwgbmVlZCBtb3JlIGlucHV0IG9yIG1vcmUgb3V0cHV0ICovXG52YXIgQlNfQkxPQ0tfRE9ORSAgICAgPSAyOyAvKiBibG9jayBmbHVzaCBwZXJmb3JtZWQgKi9cbnZhciBCU19GSU5JU0hfU1RBUlRFRCA9IDM7IC8qIGZpbmlzaCBzdGFydGVkLCBuZWVkIG9ubHkgbW9yZSBvdXRwdXQgYXQgbmV4dCBkZWZsYXRlICovXG52YXIgQlNfRklOSVNIX0RPTkUgICAgPSA0OyAvKiBmaW5pc2ggZG9uZSwgYWNjZXB0IG5vIG1vcmUgaW5wdXQgb3Igb3V0cHV0ICovXG5cbnZhciBPU19DT0RFID0gMHgwMzsgLy8gVW5peCA6KSAuIERvbid0IGRldGVjdCwgdXNlIHRoaXMgZGVmYXVsdC5cblxuZnVuY3Rpb24gZXJyKHN0cm0sIGVycm9yQ29kZSkge1xuICBzdHJtLm1zZyA9IG1zZ1tlcnJvckNvZGVdO1xuICByZXR1cm4gZXJyb3JDb2RlO1xufVxuXG5mdW5jdGlvbiByYW5rKGYpIHtcbiAgcmV0dXJuICgoZikgPDwgMSkgLSAoKGYpID4gNCA/IDkgOiAwKTtcbn1cblxuZnVuY3Rpb24gemVybyhidWYpIHsgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7IHdoaWxlICgtLWxlbiA+PSAwKSB7IGJ1ZltsZW5dID0gMDsgfSB9XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZS4gQWxsIGRlZmxhdGUoKSBvdXRwdXQgZ29lc1xuICogdGhyb3VnaCB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdFxuICogdG8gYXZvaWQgYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPm91dHB1dCBidWZmZXIgYW5kIGNvcHlpbmcgaW50byBpdC5cbiAqIChTZWUgYWxzbyByZWFkX2J1ZigpKS5cbiAqL1xuZnVuY3Rpb24gZmx1c2hfcGVuZGluZyhzdHJtKSB7XG4gIHZhciBzID0gc3RybS5zdGF0ZTtcblxuICAvL190cl9mbHVzaF9iaXRzKHMpO1xuICB2YXIgbGVuID0gcy5wZW5kaW5nO1xuICBpZiAobGVuID4gc3RybS5hdmFpbF9vdXQpIHtcbiAgICBsZW4gPSBzdHJtLmF2YWlsX291dDtcbiAgfVxuICBpZiAobGVuID09PSAwKSB7IHJldHVybjsgfVxuXG4gIHV0aWxzLmFycmF5U2V0KHN0cm0ub3V0cHV0LCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmdfb3V0LCBsZW4sIHN0cm0ubmV4dF9vdXQpO1xuICBzdHJtLm5leHRfb3V0ICs9IGxlbjtcbiAgcy5wZW5kaW5nX291dCArPSBsZW47XG4gIHN0cm0udG90YWxfb3V0ICs9IGxlbjtcbiAgc3RybS5hdmFpbF9vdXQgLT0gbGVuO1xuICBzLnBlbmRpbmcgLT0gbGVuO1xuICBpZiAocy5wZW5kaW5nID09PSAwKSB7XG4gICAgcy5wZW5kaW5nX291dCA9IDA7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBmbHVzaF9ibG9ja19vbmx5KHMsIGxhc3QpIHtcbiAgdHJlZXMuX3RyX2ZsdXNoX2Jsb2NrKHMsIChzLmJsb2NrX3N0YXJ0ID49IDAgPyBzLmJsb2NrX3N0YXJ0IDogLTEpLCBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCwgbGFzdCk7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBmbHVzaF9wZW5kaW5nKHMuc3RybSk7XG59XG5cblxuZnVuY3Rpb24gcHV0X2J5dGUocywgYikge1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGI7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUHV0IGEgc2hvcnQgaW4gdGhlIHBlbmRpbmcgYnVmZmVyLiBUaGUgMTYtYml0IHZhbHVlIGlzIHB1dCBpbiBNU0Igb3JkZXIuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBzdHJlYW0gc3RhdGUgaXMgY29ycmVjdCBhbmQgdGhlcmUgaXMgZW5vdWdoIHJvb20gaW5cbiAqIHBlbmRpbmdfYnVmLlxuICovXG5mdW5jdGlvbiBwdXRTaG9ydE1TQihzLCBiKSB7XG4vLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgPj4gOCkpO1xuLy8gIHB1dF9ieXRlKHMsIChCeXRlKShiICYgMHhmZikpO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IChiID4+PiA4KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYiAmIDB4ZmY7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZWFkIGEgbmV3IGJ1ZmZlciBmcm9tIHRoZSBjdXJyZW50IGlucHV0IHN0cmVhbSwgdXBkYXRlIHRoZSBhZGxlcjMyXG4gKiBhbmQgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuICBBbGwgZGVmbGF0ZSgpIGlucHV0IGdvZXMgdGhyb3VnaFxuICogdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXQgdG8gYXZvaWRcbiAqIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5pbnB1dCBidWZmZXIgYW5kIGNvcHlpbmcgZnJvbSBpdC5cbiAqIChTZWUgYWxzbyBmbHVzaF9wZW5kaW5nKCkpLlxuICovXG5mdW5jdGlvbiByZWFkX2J1ZihzdHJtLCBidWYsIHN0YXJ0LCBzaXplKSB7XG4gIHZhciBsZW4gPSBzdHJtLmF2YWlsX2luO1xuXG4gIGlmIChsZW4gPiBzaXplKSB7IGxlbiA9IHNpemU7IH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm4gMDsgfVxuXG4gIHN0cm0uYXZhaWxfaW4gLT0gbGVuO1xuXG4gIC8vIHptZW1jcHkoYnVmLCBzdHJtLT5uZXh0X2luLCBsZW4pO1xuICB1dGlscy5hcnJheVNldChidWYsIHN0cm0uaW5wdXQsIHN0cm0ubmV4dF9pbiwgbGVuLCBzdGFydCk7XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDEpIHtcbiAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpO1xuICB9XG5cbiAgZWxzZSBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAyKSB7XG4gICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gKz0gbGVuO1xuICBzdHJtLnRvdGFsX2luICs9IGxlbjtcblxuICByZXR1cm4gbGVuO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2V0IG1hdGNoX3N0YXJ0IHRvIHRoZSBsb25nZXN0IG1hdGNoIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBzdHJpbmcgYW5kXG4gKiByZXR1cm4gaXRzIGxlbmd0aC4gTWF0Y2hlcyBzaG9ydGVyIG9yIGVxdWFsIHRvIHByZXZfbGVuZ3RoIGFyZSBkaXNjYXJkZWQsXG4gKiBpbiB3aGljaCBjYXNlIHRoZSByZXN1bHQgaXMgZXF1YWwgdG8gcHJldl9sZW5ndGggYW5kIG1hdGNoX3N0YXJ0IGlzXG4gKiBnYXJiYWdlLlxuICogSU4gYXNzZXJ0aW9uczogY3VyX21hdGNoIGlzIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluIGZvciB0aGUgY3VycmVudFxuICogICBzdHJpbmcgKHN0cnN0YXJ0KSBhbmQgaXRzIGRpc3RhbmNlIGlzIDw9IE1BWF9ESVNULCBhbmQgcHJldl9sZW5ndGggPj0gMVxuICogT1VUIGFzc2VydGlvbjogdGhlIG1hdGNoIGxlbmd0aCBpcyBub3QgZ3JlYXRlciB0aGFuIHMtPmxvb2thaGVhZC5cbiAqL1xuZnVuY3Rpb24gbG9uZ2VzdF9tYXRjaChzLCBjdXJfbWF0Y2gpIHtcbiAgdmFyIGNoYWluX2xlbmd0aCA9IHMubWF4X2NoYWluX2xlbmd0aDsgICAgICAvKiBtYXggaGFzaCBjaGFpbiBsZW5ndGggKi9cbiAgdmFyIHNjYW4gPSBzLnN0cnN0YXJ0OyAvKiBjdXJyZW50IHN0cmluZyAqL1xuICB2YXIgbWF0Y2g7ICAgICAgICAgICAgICAgICAgICAgICAvKiBtYXRjaGVkIHN0cmluZyAqL1xuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IG1hdGNoICovXG4gIHZhciBiZXN0X2xlbiA9IHMucHJldl9sZW5ndGg7ICAgICAgICAgICAgICAvKiBiZXN0IG1hdGNoIGxlbmd0aCBzbyBmYXIgKi9cbiAgdmFyIG5pY2VfbWF0Y2ggPSBzLm5pY2VfbWF0Y2g7ICAgICAgICAgICAgIC8qIHN0b3AgaWYgbWF0Y2ggbG9uZyBlbm91Z2ggKi9cbiAgdmFyIGxpbWl0ID0gKHMuc3Ryc3RhcnQgPiAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkgP1xuICAgICAgcy5zdHJzdGFydCAtIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIDogMC8qTklMKi87XG5cbiAgdmFyIF93aW4gPSBzLndpbmRvdzsgLy8gc2hvcnRjdXRcblxuICB2YXIgd21hc2sgPSBzLndfbWFzaztcbiAgdmFyIHByZXYgID0gcy5wcmV2O1xuXG4gIC8qIFN0b3Agd2hlbiBjdXJfbWF0Y2ggYmVjb21lcyA8PSBsaW1pdC4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsXG4gICAqIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmcgb2Ygd2luZG93IGluZGV4IDAuXG4gICAqL1xuXG4gIHZhciBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIO1xuICB2YXIgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gIHZhciBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuXG4gIC8qIFRoZSBjb2RlIGlzIG9wdGltaXplZCBmb3IgSEFTSF9CSVRTID49IDggYW5kIE1BWF9NQVRDSC0yIG11bHRpcGxlIG9mIDE2LlxuICAgKiBJdCBpcyBlYXN5IHRvIGdldCByaWQgb2YgdGhpcyBvcHRpbWl6YXRpb24gaWYgbmVjZXNzYXJ5LlxuICAgKi9cbiAgLy8gQXNzZXJ0KHMtPmhhc2hfYml0cyA+PSA4ICYmIE1BWF9NQVRDSCA9PSAyNTgsIFwiQ29kZSB0b28gY2xldmVyXCIpO1xuXG4gIC8qIERvIG5vdCB3YXN0ZSB0b28gbXVjaCB0aW1lIGlmIHdlIGFscmVhZHkgaGF2ZSBhIGdvb2QgbWF0Y2g6ICovXG4gIGlmIChzLnByZXZfbGVuZ3RoID49IHMuZ29vZF9tYXRjaCkge1xuICAgIGNoYWluX2xlbmd0aCA+Pj0gMjtcbiAgfVxuICAvKiBEbyBub3QgbG9vayBmb3IgbWF0Y2hlcyBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgaW5wdXQuIFRoaXMgaXMgbmVjZXNzYXJ5XG4gICAqIHRvIG1ha2UgZGVmbGF0ZSBkZXRlcm1pbmlzdGljLlxuICAgKi9cbiAgaWYgKG5pY2VfbWF0Y2ggPiBzLmxvb2thaGVhZCkgeyBuaWNlX21hdGNoID0gcy5sb29rYWhlYWQ7IH1cblxuICAvLyBBc3NlcnQoKHVsZylzLT5zdHJzdGFydCA8PSBzLT53aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFELCBcIm5lZWQgbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICAvLyBBc3NlcnQoY3VyX21hdGNoIDwgcy0+c3Ryc3RhcnQsIFwibm8gZnV0dXJlXCIpO1xuICAgIG1hdGNoID0gY3VyX21hdGNoO1xuXG4gICAgLyogU2tpcCB0byBuZXh0IG1hdGNoIGlmIHRoZSBtYXRjaCBsZW5ndGggY2Fubm90IGluY3JlYXNlXG4gICAgICogb3IgaWYgdGhlIG1hdGNoIGxlbmd0aCBpcyBsZXNzIHRoYW4gMi4gIE5vdGUgdGhhdCB0aGUgY2hlY2tzIGJlbG93XG4gICAgICogZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBvY2N1ciBvY2Nhc2lvbmFsbHkgZm9yIHBlcmZvcm1hbmNlXG4gICAgICogcmVhc29ucy4gIFRoZXJlZm9yZSB1bmluaXRpYWxpemVkIG1lbW9yeSB3aWxsIGJlIGFjY2Vzc2VkLCBhbmRcbiAgICAgKiBjb25kaXRpb25hbCBqdW1wcyB3aWxsIGJlIG1hZGUgdGhhdCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzLlxuICAgICAqIEhvd2V2ZXIgdGhlIGxlbmd0aCBvZiB0aGUgbWF0Y2ggaXMgbGltaXRlZCB0byB0aGUgbG9va2FoZWFkLCBzb1xuICAgICAqIHRoZSBvdXRwdXQgb2YgZGVmbGF0ZSBpcyBub3QgYWZmZWN0ZWQgYnkgdGhlIHVuaW5pdGlhbGl6ZWQgdmFsdWVzLlxuICAgICAqL1xuXG4gICAgaWYgKF93aW5bbWF0Y2ggKyBiZXN0X2xlbl0gICAgICE9PSBzY2FuX2VuZCAgfHxcbiAgICAgICAgX3dpblttYXRjaCArIGJlc3RfbGVuIC0gMV0gIT09IHNjYW5fZW5kMSB8fFxuICAgICAgICBfd2luW21hdGNoXSAgICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuXSB8fFxuICAgICAgICBfd2luWysrbWF0Y2hdICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuICsgMV0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qIFRoZSBjaGVjayBhdCBiZXN0X2xlbi0xIGNhbiBiZSByZW1vdmVkIGJlY2F1c2UgaXQgd2lsbCBiZSBtYWRlXG4gICAgICogYWdhaW4gbGF0ZXIuIChUaGlzIGhldXJpc3RpYyBpcyBub3QgYWx3YXlzIGEgd2luLilcbiAgICAgKiBJdCBpcyBub3QgbmVjZXNzYXJ5IHRvIGNvbXBhcmUgc2NhblsyXSBhbmQgbWF0Y2hbMl0gc2luY2UgdGhleVxuICAgICAqIGFyZSBhbHdheXMgZXF1YWwgd2hlbiB0aGUgb3RoZXIgYnl0ZXMgbWF0Y2gsIGdpdmVuIHRoYXRcbiAgICAgKiB0aGUgaGFzaCBrZXlzIGFyZSBlcXVhbCBhbmQgdGhhdCBIQVNIX0JJVFMgPj0gOC5cbiAgICAgKi9cbiAgICBzY2FuICs9IDI7XG4gICAgbWF0Y2grKztcbiAgICAvLyBBc3NlcnQoKnNjYW4gPT0gKm1hdGNoLCBcIm1hdGNoWzJdP1wiKTtcblxuICAgIC8qIFdlIGNoZWNrIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgZXZlcnkgOHRoIGNvbXBhcmlzb247XG4gICAgICogdGhlIDI1NnRoIGNoZWNrIHdpbGwgYmUgbWFkZSBhdCBzdHJzdGFydCsyNTguXG4gICAgICovXG4gICAgZG8ge1xuICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovXG4gICAgfSB3aGlsZSAoX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuXG4gICAgLy8gQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1bnNpZ25lZCkocy0+d2luZG93X3NpemUtMSksIFwid2lsZCBzY2FuXCIpO1xuXG4gICAgbGVuID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgIHNjYW4gPSBzdHJlbmQgLSBNQVhfTUFUQ0g7XG5cbiAgICBpZiAobGVuID4gYmVzdF9sZW4pIHtcbiAgICAgIHMubWF0Y2hfc3RhcnQgPSBjdXJfbWF0Y2g7XG4gICAgICBiZXN0X2xlbiA9IGxlbjtcbiAgICAgIGlmIChsZW4gPj0gbmljZV9tYXRjaCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHNjYW5fZW5kMSAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xuICAgICAgc2Nhbl9lbmQgICA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTtcbiAgICB9XG4gIH0gd2hpbGUgKChjdXJfbWF0Y2ggPSBwcmV2W2N1cl9tYXRjaCAmIHdtYXNrXSkgPiBsaW1pdCAmJiAtLWNoYWluX2xlbmd0aCAhPT0gMCk7XG5cbiAgaWYgKGJlc3RfbGVuIDw9IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIGJlc3RfbGVuO1xuICB9XG4gIHJldHVybiBzLmxvb2thaGVhZDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZpbGwgdGhlIHdpbmRvdyB3aGVuIHRoZSBsb29rYWhlYWQgYmVjb21lcyBpbnN1ZmZpY2llbnQuXG4gKiBVcGRhdGVzIHN0cnN0YXJ0IGFuZCBsb29rYWhlYWQuXG4gKlxuICogSU4gYXNzZXJ0aW9uOiBsb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEXG4gKiBPVVQgYXNzZXJ0aW9uczogc3Ryc3RhcnQgPD0gd2luZG93X3NpemUtTUlOX0xPT0tBSEVBRFxuICogICAgQXQgbGVhc3Qgb25lIGJ5dGUgaGFzIGJlZW4gcmVhZCwgb3IgYXZhaWxfaW4gPT0gMDsgcmVhZHMgYXJlXG4gKiAgICBwZXJmb3JtZWQgZm9yIGF0IGxlYXN0IHR3byBieXRlcyAocmVxdWlyZWQgZm9yIHRoZSB6aXAgdHJhbnNsYXRlX2VvbFxuICogICAgb3B0aW9uIC0tIG5vdCBzdXBwb3J0ZWQgaGVyZSkuXG4gKi9cbmZ1bmN0aW9uIGZpbGxfd2luZG93KHMpIHtcbiAgdmFyIF93X3NpemUgPSBzLndfc2l6ZTtcbiAgdmFyIHAsIG4sIG0sIG1vcmUsIHN0cjtcblxuICAvL0Fzc2VydChzLT5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFELCBcImFscmVhZHkgZW5vdWdoIGxvb2thaGVhZFwiKTtcblxuICBkbyB7XG4gICAgbW9yZSA9IHMud2luZG93X3NpemUgLSBzLmxvb2thaGVhZCAtIHMuc3Ryc3RhcnQ7XG5cbiAgICAvLyBKUyBpbnRzIGhhdmUgMzIgYml0LCBibG9jayBiZWxvdyBub3QgbmVlZGVkXG4gICAgLyogRGVhbCB3aXRoICFAIyQlIDY0SyBsaW1pdDogKi9cbiAgICAvL2lmIChzaXplb2YoaW50KSA8PSAyKSB7XG4gICAgLy8gICAgaWYgKG1vcmUgPT0gMCAmJiBzLT5zdHJzdGFydCA9PSAwICYmIHMtPmxvb2thaGVhZCA9PSAwKSB7XG4gICAgLy8gICAgICAgIG1vcmUgPSB3c2l6ZTtcbiAgICAvL1xuICAgIC8vICB9IGVsc2UgaWYgKG1vcmUgPT0gKHVuc2lnbmVkKSgtMSkpIHtcbiAgICAvLyAgICAgICAgLyogVmVyeSB1bmxpa2VseSwgYnV0IHBvc3NpYmxlIG9uIDE2IGJpdCBtYWNoaW5lIGlmXG4gICAgLy8gICAgICAgICAqIHN0cnN0YXJ0ID09IDAgJiYgbG9va2FoZWFkID09IDEgKGlucHV0IGRvbmUgYSBieXRlIGF0IHRpbWUpXG4gICAgLy8gICAgICAgICAqL1xuICAgIC8vICAgICAgICBtb3JlLS07XG4gICAgLy8gICAgfVxuICAgIC8vfVxuXG5cbiAgICAvKiBJZiB0aGUgd2luZG93IGlzIGFsbW9zdCBmdWxsIGFuZCB0aGVyZSBpcyBpbnN1ZmZpY2llbnQgbG9va2FoZWFkLFxuICAgICAqIG1vdmUgdGhlIHVwcGVyIGhhbGYgdG8gdGhlIGxvd2VyIG9uZSB0byBtYWtlIHJvb20gaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICovXG4gICAgaWYgKHMuc3Ryc3RhcnQgPj0gX3dfc2l6ZSArIChfd19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcblxuICAgICAgdXRpbHMuYXJyYXlTZXQocy53aW5kb3csIHMud2luZG93LCBfd19zaXplLCBfd19zaXplLCAwKTtcbiAgICAgIHMubWF0Y2hfc3RhcnQgLT0gX3dfc2l6ZTtcbiAgICAgIHMuc3Ryc3RhcnQgLT0gX3dfc2l6ZTtcbiAgICAgIC8qIHdlIG5vdyBoYXZlIHN0cnN0YXJ0ID49IE1BWF9ESVNUICovXG4gICAgICBzLmJsb2NrX3N0YXJ0IC09IF93X3NpemU7XG5cbiAgICAgIC8qIFNsaWRlIHRoZSBoYXNoIHRhYmxlIChjb3VsZCBiZSBhdm9pZGVkIHdpdGggMzIgYml0IHZhbHVlc1xuICAgICAgIGF0IHRoZSBleHBlbnNlIG9mIG1lbW9yeSB1c2FnZSkuIFdlIHNsaWRlIGV2ZW4gd2hlbiBsZXZlbCA9PSAwXG4gICAgICAgdG8ga2VlcCB0aGUgaGFzaCB0YWJsZSBjb25zaXN0ZW50IGlmIHdlIHN3aXRjaCBiYWNrIHRvIGxldmVsID4gMFxuICAgICAgIGxhdGVyLiAoVXNpbmcgbGV2ZWwgMCBwZXJtYW5lbnRseSBpcyBub3QgYW4gb3B0aW1hbCB1c2FnZSBvZlxuICAgICAgIHpsaWIsIHNvIHdlIGRvbid0IGNhcmUgYWJvdXQgdGhpcyBwYXRob2xvZ2ljYWwgY2FzZS4pXG4gICAgICAgKi9cblxuICAgICAgbiA9IHMuaGFzaF9zaXplO1xuICAgICAgcCA9IG47XG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLmhlYWRbLS1wXTtcbiAgICAgICAgcy5oZWFkW3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgICBuID0gX3dfc2l6ZTtcbiAgICAgIHAgPSBuO1xuICAgICAgZG8ge1xuICAgICAgICBtID0gcy5wcmV2Wy0tcF07XG4gICAgICAgIHMucHJldltwXSA9IChtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDApO1xuICAgICAgICAvKiBJZiBuIGlzIG5vdCBvbiBhbnkgaGFzaCBjaGFpbiwgcHJldltuXSBpcyBnYXJiYWdlIGJ1dFxuICAgICAgICAgKiBpdHMgdmFsdWUgd2lsbCBuZXZlciBiZSB1c2VkLlxuICAgICAgICAgKi9cbiAgICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAgIG1vcmUgKz0gX3dfc2l6ZTtcbiAgICB9XG4gICAgaWYgKHMuc3RybS5hdmFpbF9pbiA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLyogSWYgdGhlcmUgd2FzIG5vIHNsaWRpbmc6XG4gICAgICogICAgc3Ryc3RhcnQgPD0gV1NJWkUrTUFYX0RJU1QtMSAmJiBsb29rYWhlYWQgPD0gTUlOX0xPT0tBSEVBRCAtIDEgJiZcbiAgICAgKiAgICBtb3JlID09IHdpbmRvd19zaXplIC0gbG9va2FoZWFkIC0gc3Ryc3RhcnRcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gKE1JTl9MT09LQUhFQUQtMSArIFdTSVpFICsgTUFYX0RJU1QtMSlcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gMipXU0laRSArIDJcbiAgICAgKiBJbiB0aGUgQklHX01FTSBvciBNTUFQIGNhc2UgKG5vdCB5ZXQgc3VwcG9ydGVkKSxcbiAgICAgKiAgIHdpbmRvd19zaXplID09IGlucHV0X3NpemUgKyBNSU5fTE9PS0FIRUFEICAmJlxuICAgICAqICAgc3Ryc3RhcnQgKyBzLT5sb29rYWhlYWQgPD0gaW5wdXRfc2l6ZSA9PiBtb3JlID49IE1JTl9MT09LQUhFQUQuXG4gICAgICogT3RoZXJ3aXNlLCB3aW5kb3dfc2l6ZSA9PSAyKldTSVpFIHNvIG1vcmUgPj0gMi5cbiAgICAgKiBJZiB0aGVyZSB3YXMgc2xpZGluZywgbW9yZSA+PSBXU0laRS4gU28gaW4gYWxsIGNhc2VzLCBtb3JlID49IDIuXG4gICAgICovXG4gICAgLy9Bc3NlcnQobW9yZSA+PSAyLCBcIm1vcmUgPCAyXCIpO1xuICAgIG4gPSByZWFkX2J1ZihzLnN0cm0sIHMud2luZG93LCBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQsIG1vcmUpO1xuICAgIHMubG9va2FoZWFkICs9IG47XG5cbiAgICAvKiBJbml0aWFsaXplIHRoZSBoYXNoIHZhbHVlIG5vdyB0aGF0IHdlIGhhdmUgc29tZSBpbnB1dDogKi9cbiAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIHN0ciA9IHMuc3Ryc3RhcnQgLSBzLmluc2VydDtcbiAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzdHJdO1xuXG4gICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIDFdKTsgKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIDFdKSAmIHMuaGFzaF9tYXNrO1xuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICBDYWxsIHVwZGF0ZV9oYXNoKCkgTUlOX01BVENILTMgbW9yZSB0aW1lc1xuLy8jZW5kaWZcbiAgICAgIHdoaWxlIChzLmluc2VydCkge1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4gICAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjtcbiAgICAgICAgc3RyKys7XG4gICAgICAgIHMuaW5zZXJ0LS07XG4gICAgICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0IDwgTUlOX01BVENIKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlIHdob2xlIGlucHV0IGhhcyBsZXNzIHRoYW4gTUlOX01BVENIIGJ5dGVzLCBpbnNfaCBpcyBnYXJiYWdlLFxuICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBpbXBvcnRhbnQgc2luY2Ugb25seSBsaXRlcmFsIGJ5dGVzIHdpbGwgYmUgZW1pdHRlZC5cbiAgICAgKi9cblxuICB9IHdoaWxlIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgcy5zdHJtLmF2YWlsX2luICE9PSAwKTtcblxuICAvKiBJZiB0aGUgV0lOX0lOSVQgYnl0ZXMgYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBkYXRhIGhhdmUgbmV2ZXIgYmVlblxuICAgKiB3cml0dGVuLCB0aGVuIHplcm8gdGhvc2UgYnl0ZXMgaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHJlcG9ydHMgb2ZcbiAgICogdGhlIHVzZSBvZiB1bmluaXRpYWxpemVkIChvciB1bmluaXRpYWxpc2VkIGFzIEp1bGlhbiB3cml0ZXMpIGJ5dGVzIGJ5XG4gICAqIHRoZSBsb25nZXN0IG1hdGNoIHJvdXRpbmVzLiAgVXBkYXRlIHRoZSBoaWdoIHdhdGVyIG1hcmsgZm9yIHRoZSBuZXh0XG4gICAqIHRpbWUgdGhyb3VnaCBoZXJlLiAgV0lOX0lOSVQgaXMgc2V0IHRvIE1BWF9NQVRDSCBzaW5jZSB0aGUgbG9uZ2VzdCBtYXRjaFxuICAgKiByb3V0aW5lcyBhbGxvdyBzY2FubmluZyB0byBzdHJzdGFydCArIE1BWF9NQVRDSCwgaWdub3JpbmcgbG9va2FoZWFkLlxuICAgKi9cbi8vICBpZiAocy5oaWdoX3dhdGVyIDwgcy53aW5kb3dfc2l6ZSkge1xuLy8gICAgdmFyIGN1cnIgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQ7XG4vLyAgICB2YXIgaW5pdCA9IDA7XG4vL1xuLy8gICAgaWYgKHMuaGlnaF93YXRlciA8IGN1cnIpIHtcbi8vICAgICAgLyogUHJldmlvdXMgaGlnaCB3YXRlciBtYXJrIGJlbG93IGN1cnJlbnQgZGF0YSAtLSB6ZXJvIFdJTl9JTklUXG4vLyAgICAgICAqIGJ5dGVzIG9yIHVwIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9IHMud2luZG93X3NpemUgLSBjdXJyO1xuLy8gICAgICBpZiAoaW5pdCA+IFdJTl9JTklUKVxuLy8gICAgICAgIGluaXQgPSBXSU5fSU5JVDtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgY3VyciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyID0gY3VyciArIGluaXQ7XG4vLyAgICB9XG4vLyAgICBlbHNlIGlmIChzLT5oaWdoX3dhdGVyIDwgKHVsZyljdXJyICsgV0lOX0lOSVQpIHtcbi8vICAgICAgLyogSGlnaCB3YXRlciBtYXJrIGF0IG9yIGFib3ZlIGN1cnJlbnQgZGF0YSwgYnV0IGJlbG93IGN1cnJlbnQgZGF0YVxuLy8gICAgICAgKiBwbHVzIFdJTl9JTklUIC0tIHplcm8gb3V0IHRvIGN1cnJlbnQgZGF0YSBwbHVzIFdJTl9JTklULCBvciB1cFxuLy8gICAgICAgKiB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSAodWxnKWN1cnIgKyBXSU5fSU5JVCAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIGlmIChpbml0ID4gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyKVxuLy8gICAgICAgIGluaXQgPSBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIHMtPmhpZ2hfd2F0ZXIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciArPSBpbml0O1xuLy8gICAgfVxuLy8gIH1cbi8vXG4vLyAgQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUgLSBNSU5fTE9PS0FIRUFELFxuLy8gICAgXCJub3QgZW5vdWdoIHJvb20gZm9yIHNlYXJjaFwiKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5IHdpdGhvdXQgY29tcHJlc3Npb24gYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVyblxuICogdGhlIGN1cnJlbnQgYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IGluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBzaW5jZVxuICogdW5jb21wcmVzc2libGUgZGF0YSBpcyBwcm9iYWJseSBub3QgdXNlZnVsLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWRcbiAqIG9ubHkgZm9yIHRoZSBsZXZlbD0wIGNvbXByZXNzaW9uIG9wdGlvbi5cbiAqIE5PVEU6IHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIG9wdGltaXplZCB0byBhdm9pZCBleHRyYSBjb3B5aW5nIGZyb21cbiAqIHdpbmRvdyB0byBwZW5kaW5nX2J1Zi5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9zdG9yZWQocywgZmx1c2gpIHtcbiAgLyogU3RvcmVkIGJsb2NrcyBhcmUgbGltaXRlZCB0byAweGZmZmYgYnl0ZXMsIHBlbmRpbmdfYnVmIGlzIGxpbWl0ZWRcbiAgICogdG8gcGVuZGluZ19idWZfc2l6ZSwgYW5kIGVhY2ggc3RvcmVkIGJsb2NrIGhhcyBhIDUgYnl0ZSBoZWFkZXI6XG4gICAqL1xuICB2YXIgbWF4X2Jsb2NrX3NpemUgPSAweGZmZmY7XG5cbiAgaWYgKG1heF9ibG9ja19zaXplID4gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNSkge1xuICAgIG1heF9ibG9ja19zaXplID0gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNTtcbiAgfVxuXG4gIC8qIENvcHkgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIGlucHV0IHRvIG91dHB1dDogKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIEZpbGwgdGhlIHdpbmRvdyBhcyBtdWNoIGFzIHBvc3NpYmxlOiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSAxKSB7XG5cbiAgICAgIC8vQXNzZXJ0KHMtPnN0cnN0YXJ0IDwgcy0+d19zaXplK01BWF9ESVNUKHMpIHx8XG4gICAgICAvLyAgcy0+YmxvY2tfc3RhcnQgPj0gKGxvbmcpcy0+d19zaXplLCBcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICBpZiAoIShzLnN0cnN0YXJ0IDwgcy53X3NpemUgKyAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB8fFxuLy8gICAgICAgIHMuYmxvY2tfc3RhcnQgPj0gcy53X3NpemUpKSB7XG4vLyAgICAgICAgdGhyb3cgIG5ldyBFcnJvcihcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICB9XG5cbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuICAgIC8vQXNzZXJ0KHMtPmJsb2NrX3N0YXJ0ID49IDBMLCBcImJsb2NrIGdvbmVcIik7XG4vLyAgICBpZiAocy5ibG9ja19zdGFydCA8IDApIHRocm93IG5ldyBFcnJvcihcImJsb2NrIGdvbmVcIik7XG5cbiAgICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkO1xuICAgIHMubG9va2FoZWFkID0gMDtcblxuICAgIC8qIEVtaXQgYSBzdG9yZWQgYmxvY2sgaWYgcGVuZGluZ19idWYgd2lsbCBiZSBmdWxsOiAqL1xuICAgIHZhciBtYXhfc3RhcnQgPSBzLmJsb2NrX3N0YXJ0ICsgbWF4X2Jsb2NrX3NpemU7XG5cbiAgICBpZiAocy5zdHJzdGFydCA9PT0gMCB8fCBzLnN0cnN0YXJ0ID49IG1heF9zdGFydCkge1xuICAgICAgLyogc3Ryc3RhcnQgPT0gMCBpcyBwb3NzaWJsZSB3aGVuIHdyYXBhcm91bmQgb24gMTYtYml0IG1hY2hpbmUgKi9cbiAgICAgIHMubG9va2FoZWFkID0gcy5zdHJzdGFydCAtIG1heF9zdGFydDtcbiAgICAgIHMuc3Ryc3RhcnQgPSBtYXhfc3RhcnQ7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuXG5cbiAgICB9XG4gICAgLyogRmx1c2ggaWYgd2UgbWF5IGhhdmUgdG8gc2xpZGUsIG90aGVyd2lzZSBibG9ja19zdGFydCBtYXkgYmVjb21lXG4gICAgICogbmVnYXRpdmUgYW5kIHRoZSBkYXRhIHdpbGwgYmUgZ29uZTpcbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQgPj0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG5cbiAgcy5pbnNlcnQgPSAwO1xuXG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuXG4gIGlmIChzLnN0cnN0YXJ0ID4gcy5ibG9ja19zdGFydCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19ORUVEX01PUkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHJlc3MgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVybiB0aGUgY3VycmVudFxuICogYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHBlcmZvcm0gbGF6eSBldmFsdWF0aW9uIG9mIG1hdGNoZXMgYW5kIGluc2VydHNcbiAqIG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IG9ubHkgZm9yIHVubWF0Y2hlZCBzdHJpbmdzIG9yIGZvciBzaG9ydFxuICogbWF0Y2hlcy4gSXQgaXMgdXNlZCBvbmx5IGZvciB0aGUgZmFzdCBjb21wcmVzc2lvbiBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX2Zhc3QocywgZmx1c2gpIHtcbiAgdmFyIGhhc2hfaGVhZDsgICAgICAgIC8qIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gKi9cbiAgdmFyIGJmbHVzaDsgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICogQXQgdGhpcyBwb2ludCB3ZSBoYXZlIGFsd2F5cyBtYXRjaF9sZW5ndGggPCBNSU5fTUFUQ0hcbiAgICAgKi9cbiAgICBpZiAoaGFzaF9oZWFkICE9PSAwLypOSUwqLyAmJiAoKHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQpIDw9IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSkge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG4gICAgfVxuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vIGNoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoKTsgLy8gZm9yIGRlYnVnIG9ubHlcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG5cbiAgICAgIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGhcbiAgICAgICAqIGlzIG5vdCB0b28gbGFyZ2UuIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAgICAgKi9cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSBzLm1heF9sYXp5X21hdGNoLyptYXhfaW5zZXJ0X2xlbmd0aCovICYmIHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgICBzLm1hdGNoX2xlbmd0aC0tOyAvKiBzdHJpbmcgYXQgc3Ryc3RhcnQgYWxyZWFkeSBpbiB0YWJsZSAqL1xuICAgICAgICBkbyB7XG4gICAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgICAvKiBzdHJzdGFydCBuZXZlciBleGNlZWRzIFdTSVpFLU1BWF9NQVRDSCwgc28gdGhlcmUgYXJlXG4gICAgICAgICAgICogYWx3YXlzIE1JTl9NQVRDSCBieXRlcyBhaGVhZC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgfSB3aGlsZSAoLS1zLm1hdGNoX2xlbmd0aCAhPT0gMCk7XG4gICAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIH0gZWxzZVxuICAgICAge1xuICAgICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzLnN0cnN0YXJ0XTtcbiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCsxXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyAxXSkgJiBzLmhhc2hfbWFzaztcblxuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICAgICAgICAgIENhbGwgVVBEQVRFX0hBU0goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgICAvKiBJZiBsb29rYWhlYWQgPCBNSU5fTUFUQ0gsIGluc19oIGlzIGdhcmJhZ2UsIGJ1dCBpdCBkb2VzIG5vdFxuICAgICAgICAgKiBtYXR0ZXIgc2luY2UgaXQgd2lsbCBiZSByZWNvbXB1dGVkIGF0IG5leHQgZGVmbGF0ZSBjYWxsLlxuICAgICAgICAgKi9cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9ICgocy5zdHJzdGFydCA8IChNSU5fTUFUQ0ggLSAxKSkgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMSk7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTYW1lIGFzIGFib3ZlLCBidXQgYWNoaWV2ZXMgYmV0dGVyIGNvbXByZXNzaW9uLiBXZSB1c2UgYSBsYXp5XG4gKiBldmFsdWF0aW9uIGZvciBtYXRjaGVzOiBhIG1hdGNoIGlzIGZpbmFsbHkgYWRvcHRlZCBvbmx5IGlmIHRoZXJlIGlzXG4gKiBubyBiZXR0ZXIgbWF0Y2ggYXQgdGhlIG5leHQgd2luZG93IHBvc2l0aW9uLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3Nsb3cocywgZmx1c2gpIHtcbiAgdmFyIGhhc2hfaGVhZDsgICAgICAgICAgLyogaGVhZCBvZiBoYXNoIGNoYWluICovXG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICB2YXIgbWF4X2luc2VydDtcblxuICAvKiBQcm9jZXNzIHRoZSBpbnB1dCBibG9jay4gKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cblxuICAgIC8qIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcbiAgICAgKiBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcbiAgICAgKi9cbiAgICBoYXNoX2hlYWQgPSAwLypOSUwqLztcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgLyoqKi9cbiAgICB9XG5cbiAgICAvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxuICAgICAqL1xuICAgIHMucHJldl9sZW5ndGggPSBzLm1hdGNoX2xlbmd0aDtcbiAgICBzLnByZXZfbWF0Y2ggPSBzLm1hdGNoX3N0YXJ0O1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcblxuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmIHMucHJldl9sZW5ndGggPCBzLm1heF9sYXp5X21hdGNoICYmXG4gICAgICAgIHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkvKk1BWF9ESVNUKHMpKi8pIHtcbiAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7XG4gICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xuXG4gICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gNSAmJlxuICAgICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfRklMVEVSRUQgfHwgKHMubWF0Y2hfbGVuZ3RoID09PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQgPiA0MDk2LypUT09fRkFSKi8pKSkge1xuXG4gICAgICAgIC8qIElmIHByZXZfbWF0Y2ggaXMgYWxzbyBNSU5fTUFUQ0gsIG1hdGNoX3N0YXJ0IGlzIGdhcmJhZ2VcbiAgICAgICAgICogYnV0IHdlIHdpbGwgaWdub3JlIHRoZSBjdXJyZW50IG1hdGNoIGFueXdheS5cbiAgICAgICAgICovXG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHN0ZXAgYW5kIHRoZSBjdXJyZW50XG4gICAgICogbWF0Y2ggaXMgbm90IGJldHRlciwgb3V0cHV0IHRoZSBwcmV2aW91cyBtYXRjaDpcbiAgICAgKi9cbiAgICBpZiAocy5wcmV2X2xlbmd0aCA+PSBNSU5fTUFUQ0ggJiYgcy5tYXRjaF9sZW5ndGggPD0gcy5wcmV2X2xlbmd0aCkge1xuICAgICAgbWF4X2luc2VydCA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCAtIE1JTl9NQVRDSDtcbiAgICAgIC8qIERvIG5vdCBpbnNlcnQgc3RyaW5ncyBpbiBoYXNoIHRhYmxlIGJleW9uZCB0aGlzLiAqL1xuXG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQtMSwgcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoKTtcblxuICAgICAgLyoqKl90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLFxuICAgICAgICAgICAgICAgICAgICAgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuICAgICAgLyogSW5zZXJ0IGluIGhhc2ggdGFibGUgYWxsIHN0cmluZ3MgdXAgdG8gdGhlIGVuZCBvZiB0aGUgbWF0Y2guXG4gICAgICAgKiBzdHJzdGFydC0xIGFuZCBzdHJzdGFydCBhcmUgYWxyZWFkeSBpbnNlcnRlZC4gSWYgdGhlcmUgaXMgbm90XG4gICAgICAgKiBlbm91Z2ggbG9va2FoZWFkLCB0aGUgbGFzdCB0d28gc3RyaW5ncyBhcmUgbm90IGluc2VydGVkIGluXG4gICAgICAgKiB0aGUgaGFzaCB0YWJsZS5cbiAgICAgICAqL1xuICAgICAgcy5sb29rYWhlYWQgLT0gcy5wcmV2X2xlbmd0aCAtIDE7XG4gICAgICBzLnByZXZfbGVuZ3RoIC09IDI7XG4gICAgICBkbyB7XG4gICAgICAgIGlmICgrK3Muc3Ryc3RhcnQgPD0gbWF4X2luc2VydCkge1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoLS1zLnByZXZfbGVuZ3RoICE9PSAwKTtcbiAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqKi9cbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAgIC8qIElmIHRoZXJlIHdhcyBubyBtYXRjaCBhdCB0aGUgcHJldmlvdXMgcG9zaXRpb24sIG91dHB1dCBhXG4gICAgICAgKiBzaW5nbGUgbGl0ZXJhbC4gSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYnV0IHRoZSBjdXJyZW50IG1hdGNoXG4gICAgICAgKiBpcyBsb25nZXIsIHRydW5jYXRlIHRoZSBwcmV2aW91cyBtYXRjaCB0byBhIHNpbmdsZSBsaXRlcmFsLlxuICAgICAgICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0tfT05MWShzLCAwKSAqKiovXG4gICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgICAvKioqL1xuICAgICAgfVxuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIFRoZXJlIGlzIG5vIHByZXZpb3VzIG1hdGNoIHRvIGNvbXBhcmUgd2l0aCwgd2FpdCBmb3JcbiAgICAgICAqIHRoZSBuZXh0IHN0ZXAgdG8gZGVjaWRlLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDE7XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZmx1c2ggIT0gWl9OT19GTFVTSCwgXCJubyBmbHVzaD9cIik7XG4gIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTtcblxuICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgfVxuICBzLmluc2VydCA9IHMuc3Ryc3RhcnQgPCBNSU5fTUFUQ0ggLSAxID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDE7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRm9yIFpfUkxFLCBzaW1wbHkgbG9vayBmb3IgcnVucyBvZiBieXRlcywgZ2VuZXJhdGUgbWF0Y2hlcyBvbmx5IG9mIGRpc3RhbmNlXG4gKiBvbmUuICBEbyBub3QgbWFpbnRhaW4gYSBoYXNoIHRhYmxlLiAgKEl0IHdpbGwgYmUgcmVnZW5lcmF0ZWQgaWYgdGhpcyBydW4gb2ZcbiAqIGRlZmxhdGUgc3dpdGNoZXMgYXdheSBmcm9tIFpfUkxFLilcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9ybGUocywgZmx1c2gpIHtcbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cbiAgdmFyIHByZXY7ICAgICAgICAgICAgICAvKiBieXRlIGF0IGRpc3RhbmNlIG9uZSB0byBtYXRjaCAqL1xuICB2YXIgc2Nhbiwgc3RyZW5kOyAgICAgIC8qIHNjYW4gZ29lcyB1cCB0byBzdHJlbmQgZm9yIGxlbmd0aCBvZiBydW4gKi9cblxuICB2YXIgX3dpbiA9IHMud2luZG93O1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbG9uZ2VzdCBydW4sIHBsdXMgb25lIGZvciB0aGUgdW5yb2xsZWQgbG9vcC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0ggJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cblxuICAgIC8qIFNlZSBob3cgbWFueSB0aW1lcyB0aGUgcHJldmlvdXMgYnl0ZSByZXBlYXRzICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCA+IDApIHtcbiAgICAgIHNjYW4gPSBzLnN0cnN0YXJ0IC0gMTtcbiAgICAgIHByZXYgPSBfd2luW3NjYW5dO1xuICAgICAgaWYgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dKSB7XG4gICAgICAgIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICAgICAgfSB3aGlsZSAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBzY2FuIDwgc3RyZW5kKTtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+IHMubG9va2FoZWFkKSB7XG4gICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBzLmxvb2thaGVhZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9Bc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVJbnQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcbiAgICB9XG5cbiAgICAvKiBFbWl0IG1hdGNoIGlmIGhhdmUgcnVuIG9mIE1JTl9NQVRDSCBvciBsb25nZXIsIGVsc2UgZW1pdCBsaXRlcmFsICovXG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy9jaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LCBzLnN0cnN0YXJ0IC0gMSwgcy5tYXRjaF9sZW5ndGgpO1xuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIE5vIG1hdGNoLCBvdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9IDA7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9IVUZGTUFOX09OTFksIGRvIG5vdCBsb29rIGZvciBtYXRjaGVzLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS5cbiAqIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mIGRlZmxhdGUgc3dpdGNoZXMgYXdheSBmcm9tIEh1ZmZtYW4uKVxuICovXG5mdW5jdGlvbiBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIHtcbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgYSBsaXRlcmFsIHRvIHdyaXRlLiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICBicmVhazsgICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIE91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuICAgIHMubG9va2FoZWFkLS07XG4gICAgcy5zdHJzdGFydCsrO1xuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiBWYWx1ZXMgZm9yIG1heF9sYXp5X21hdGNoLCBnb29kX21hdGNoIGFuZCBtYXhfY2hhaW5fbGVuZ3RoLCBkZXBlbmRpbmcgb25cbiAqIHRoZSBkZXNpcmVkIHBhY2sgbGV2ZWwgKDAuLjkpLiBUaGUgdmFsdWVzIGdpdmVuIGJlbG93IGhhdmUgYmVlbiB0dW5lZCB0b1xuICogZXhjbHVkZSB3b3JzdCBjYXNlIHBlcmZvcm1hbmNlIGZvciBwYXRob2xvZ2ljYWwgZmlsZXMuIEJldHRlciB2YWx1ZXMgbWF5IGJlXG4gKiBmb3VuZCBmb3Igc3BlY2lmaWMgZmlsZXMuXG4gKi9cbmZ1bmN0aW9uIENvbmZpZyhnb29kX2xlbmd0aCwgbWF4X2xhenksIG5pY2VfbGVuZ3RoLCBtYXhfY2hhaW4sIGZ1bmMpIHtcbiAgdGhpcy5nb29kX2xlbmd0aCA9IGdvb2RfbGVuZ3RoO1xuICB0aGlzLm1heF9sYXp5ID0gbWF4X2xhenk7XG4gIHRoaXMubmljZV9sZW5ndGggPSBuaWNlX2xlbmd0aDtcbiAgdGhpcy5tYXhfY2hhaW4gPSBtYXhfY2hhaW47XG4gIHRoaXMuZnVuYyA9IGZ1bmM7XG59XG5cbnZhciBjb25maWd1cmF0aW9uX3RhYmxlO1xuXG5jb25maWd1cmF0aW9uX3RhYmxlID0gW1xuICAvKiAgICAgIGdvb2QgbGF6eSBuaWNlIGNoYWluICovXG4gIG5ldyBDb25maWcoMCwgMCwgMCwgMCwgZGVmbGF0ZV9zdG9yZWQpLCAgICAgICAgICAvKiAwIHN0b3JlIG9ubHkgKi9cbiAgbmV3IENvbmZpZyg0LCA0LCA4LCA0LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgIC8qIDEgbWF4IHNwZWVkLCBubyBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg0LCA1LCAxNiwgOCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgIC8qIDIgKi9cbiAgbmV3IENvbmZpZyg0LCA2LCAzMiwgMzIsIGRlZmxhdGVfZmFzdCksICAgICAgICAgIC8qIDMgKi9cblxuICBuZXcgQ29uZmlnKDQsIDQsIDE2LCAxNiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAgLyogNCBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMzIsIDMyLCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgIC8qIDUgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMTI4LCAxMjgsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDYgKi9cbiAgbmV3IENvbmZpZyg4LCAzMiwgMTI4LCAyNTYsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDcgKi9cbiAgbmV3IENvbmZpZygzMiwgMTI4LCAyNTgsIDEwMjQsIGRlZmxhdGVfc2xvdyksICAgIC8qIDggKi9cbiAgbmV3IENvbmZpZygzMiwgMjU4LCAyNTgsIDQwOTYsIGRlZmxhdGVfc2xvdykgICAgIC8qIDkgbWF4IGNvbXByZXNzaW9uICovXG5dO1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgXCJsb25nZXN0IG1hdGNoXCIgcm91dGluZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtXG4gKi9cbmZ1bmN0aW9uIGxtX2luaXQocykge1xuICBzLndpbmRvd19zaXplID0gMiAqIHMud19zaXplO1xuXG4gIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG5cbiAgLyogU2V0IHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyczpcbiAgICovXG4gIHMubWF4X2xhenlfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9sYXp5O1xuICBzLmdvb2RfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmdvb2RfbGVuZ3RoO1xuICBzLm5pY2VfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm5pY2VfbGVuZ3RoO1xuICBzLm1heF9jaGFpbl9sZW5ndGggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9jaGFpbjtcblxuICBzLnN0cnN0YXJ0ID0gMDtcbiAgcy5ibG9ja19zdGFydCA9IDA7XG4gIHMubG9va2FoZWFkID0gMDtcbiAgcy5pbnNlcnQgPSAwO1xuICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIHMuaW5zX2ggPSAwO1xufVxuXG5cbmZ1bmN0aW9uIERlZmxhdGVTdGF0ZSgpIHtcbiAgdGhpcy5zdHJtID0gbnVsbDsgICAgICAgICAgICAvKiBwb2ludGVyIGJhY2sgdG8gdGhpcyB6bGliIHN0cmVhbSAqL1xuICB0aGlzLnN0YXR1cyA9IDA7ICAgICAgICAgICAgLyogYXMgdGhlIG5hbWUgaW1wbGllcyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmID0gbnVsbDsgICAgICAvKiBvdXRwdXQgc3RpbGwgcGVuZGluZyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmX3NpemUgPSAwOyAgLyogc2l6ZSBvZiBwZW5kaW5nX2J1ZiAqL1xuICB0aGlzLnBlbmRpbmdfb3V0ID0gMDsgICAgICAgLyogbmV4dCBwZW5kaW5nIGJ5dGUgdG8gb3V0cHV0IHRvIHRoZSBzdHJlYW0gKi9cbiAgdGhpcy5wZW5kaW5nID0gMDsgICAgICAgICAgIC8qIG5iIG9mIGJ5dGVzIGluIHRoZSBwZW5kaW5nIGJ1ZmZlciAqL1xuICB0aGlzLndyYXAgPSAwOyAgICAgICAgICAgICAgLyogYml0IDAgdHJ1ZSBmb3IgemxpYiwgYml0IDEgdHJ1ZSBmb3IgZ3ppcCAqL1xuICB0aGlzLmd6aGVhZCA9IG51bGw7ICAgICAgICAgLyogZ3ppcCBoZWFkZXIgaW5mb3JtYXRpb24gdG8gd3JpdGUgKi9cbiAgdGhpcy5nemluZGV4ID0gMDsgICAgICAgICAgIC8qIHdoZXJlIGluIGV4dHJhLCBuYW1lLCBvciBjb21tZW50ICovXG4gIHRoaXMubWV0aG9kID0gWl9ERUZMQVRFRDsgLyogY2FuIG9ubHkgYmUgREVGTEFURUQgKi9cbiAgdGhpcy5sYXN0X2ZsdXNoID0gLTE7ICAgLyogdmFsdWUgb2YgZmx1c2ggcGFyYW0gZm9yIHByZXZpb3VzIGRlZmxhdGUgY2FsbCAqL1xuXG4gIHRoaXMud19zaXplID0gMDsgIC8qIExaNzcgd2luZG93IHNpemUgKDMySyBieSBkZWZhdWx0KSAqL1xuICB0aGlzLndfYml0cyA9IDA7ICAvKiBsb2cyKHdfc2l6ZSkgICg4Li4xNikgKi9cbiAgdGhpcy53X21hc2sgPSAwOyAgLyogd19zaXplIC0gMSAqL1xuXG4gIHRoaXMud2luZG93ID0gbnVsbDtcbiAgLyogU2xpZGluZyB3aW5kb3cuIElucHV0IGJ5dGVzIGFyZSByZWFkIGludG8gdGhlIHNlY29uZCBoYWxmIG9mIHRoZSB3aW5kb3csXG4gICAqIGFuZCBtb3ZlIHRvIHRoZSBmaXJzdCBoYWxmIGxhdGVyIHRvIGtlZXAgYSBkaWN0aW9uYXJ5IG9mIGF0IGxlYXN0IHdTaXplXG4gICAqIGJ5dGVzLiBXaXRoIHRoaXMgb3JnYW5pemF0aW9uLCBtYXRjaGVzIGFyZSBsaW1pdGVkIHRvIGEgZGlzdGFuY2Ugb2ZcbiAgICogd1NpemUtTUFYX01BVENIIGJ5dGVzLCBidXQgdGhpcyBlbnN1cmVzIHRoYXQgSU8gaXMgYWx3YXlzXG4gICAqIHBlcmZvcm1lZCB3aXRoIGEgbGVuZ3RoIG11bHRpcGxlIG9mIHRoZSBibG9jayBzaXplLlxuICAgKi9cblxuICB0aGlzLndpbmRvd19zaXplID0gMDtcbiAgLyogQWN0dWFsIHNpemUgb2Ygd2luZG93OiAyKndTaXplLCBleGNlcHQgd2hlbiB0aGUgdXNlciBpbnB1dCBidWZmZXJcbiAgICogaXMgZGlyZWN0bHkgdXNlZCBhcyBzbGlkaW5nIHdpbmRvdy5cbiAgICovXG5cbiAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgLyogTGluayB0byBvbGRlciBzdHJpbmcgd2l0aCBzYW1lIGhhc2ggaW5kZXguIFRvIGxpbWl0IHRoZSBzaXplIG9mIHRoaXNcbiAgICogYXJyYXkgdG8gNjRLLCB0aGlzIGxpbmsgaXMgbWFpbnRhaW5lZCBvbmx5IGZvciB0aGUgbGFzdCAzMksgc3RyaW5ncy5cbiAgICogQW4gaW5kZXggaW4gdGhpcyBhcnJheSBpcyB0aHVzIGEgd2luZG93IGluZGV4IG1vZHVsbyAzMksuXG4gICAqL1xuXG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgLyogSGVhZHMgb2YgdGhlIGhhc2ggY2hhaW5zIG9yIE5JTC4gKi9cblxuICB0aGlzLmluc19oID0gMDsgICAgICAgLyogaGFzaCBpbmRleCBvZiBzdHJpbmcgdG8gYmUgaW5zZXJ0ZWQgKi9cbiAgdGhpcy5oYXNoX3NpemUgPSAwOyAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiBoYXNoIHRhYmxlICovXG4gIHRoaXMuaGFzaF9iaXRzID0gMDsgICAvKiBsb2cyKGhhc2hfc2l6ZSkgKi9cbiAgdGhpcy5oYXNoX21hc2sgPSAwOyAgIC8qIGhhc2hfc2l6ZS0xICovXG5cbiAgdGhpcy5oYXNoX3NoaWZ0ID0gMDtcbiAgLyogTnVtYmVyIG9mIGJpdHMgYnkgd2hpY2ggaW5zX2ggbXVzdCBiZSBzaGlmdGVkIGF0IGVhY2ggaW5wdXRcbiAgICogc3RlcC4gSXQgbXVzdCBiZSBzdWNoIHRoYXQgYWZ0ZXIgTUlOX01BVENIIHN0ZXBzLCB0aGUgb2xkZXN0XG4gICAqIGJ5dGUgbm8gbG9uZ2VyIHRha2VzIHBhcnQgaW4gdGhlIGhhc2gga2V5LCB0aGF0IGlzOlxuICAgKiAgIGhhc2hfc2hpZnQgKiBNSU5fTUFUQ0ggPj0gaGFzaF9iaXRzXG4gICAqL1xuXG4gIHRoaXMuYmxvY2tfc3RhcnQgPSAwO1xuICAvKiBXaW5kb3cgcG9zaXRpb24gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgY3VycmVudCBvdXRwdXQgYmxvY2suIEdldHNcbiAgICogbmVnYXRpdmUgd2hlbiB0aGUgd2luZG93IGlzIG1vdmVkIGJhY2t3YXJkcy5cbiAgICovXG5cbiAgdGhpcy5tYXRjaF9sZW5ndGggPSAwOyAgICAgIC8qIGxlbmd0aCBvZiBiZXN0IG1hdGNoICovXG4gIHRoaXMucHJldl9tYXRjaCA9IDA7ICAgICAgICAvKiBwcmV2aW91cyBtYXRjaCAqL1xuICB0aGlzLm1hdGNoX2F2YWlsYWJsZSA9IDA7ICAgLyogc2V0IGlmIHByZXZpb3VzIG1hdGNoIGV4aXN0cyAqL1xuICB0aGlzLnN0cnN0YXJ0ID0gMDsgICAgICAgICAgLyogc3RhcnQgb2Ygc3RyaW5nIHRvIGluc2VydCAqL1xuICB0aGlzLm1hdGNoX3N0YXJ0ID0gMDsgICAgICAgLyogc3RhcnQgb2YgbWF0Y2hpbmcgc3RyaW5nICovXG4gIHRoaXMubG9va2FoZWFkID0gMDsgICAgICAgICAvKiBudW1iZXIgb2YgdmFsaWQgYnl0ZXMgYWhlYWQgaW4gd2luZG93ICovXG5cbiAgdGhpcy5wcmV2X2xlbmd0aCA9IDA7XG4gIC8qIExlbmd0aCBvZiB0aGUgYmVzdCBtYXRjaCBhdCBwcmV2aW91cyBzdGVwLiBNYXRjaGVzIG5vdCBncmVhdGVyIHRoYW4gdGhpc1xuICAgKiBhcmUgZGlzY2FyZGVkLiBUaGlzIGlzIHVzZWQgaW4gdGhlIGxhenkgbWF0Y2ggZXZhbHVhdGlvbi5cbiAgICovXG5cbiAgdGhpcy5tYXhfY2hhaW5fbGVuZ3RoID0gMDtcbiAgLyogVG8gc3BlZWQgdXAgZGVmbGF0aW9uLCBoYXNoIGNoYWlucyBhcmUgbmV2ZXIgc2VhcmNoZWQgYmV5b25kIHRoaXNcbiAgICogbGVuZ3RoLiAgQSBoaWdoZXIgbGltaXQgaW1wcm92ZXMgY29tcHJlc3Npb24gcmF0aW8gYnV0IGRlZ3JhZGVzIHRoZVxuICAgKiBzcGVlZC5cbiAgICovXG5cbiAgdGhpcy5tYXhfbGF6eV9tYXRjaCA9IDA7XG4gIC8qIEF0dGVtcHQgdG8gZmluZCBhIGJldHRlciBtYXRjaCBvbmx5IHdoZW4gdGhlIGN1cnJlbnQgbWF0Y2ggaXMgc3RyaWN0bHlcbiAgICogc21hbGxlciB0aGFuIHRoaXMgdmFsdWUuIFRoaXMgbWVjaGFuaXNtIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb25cbiAgICogbGV2ZWxzID49IDQuXG4gICAqL1xuICAvLyBUaGF0J3MgYWxpYXMgdG8gbWF4X2xhenlfbWF0Y2gsIGRvbid0IHVzZSBkaXJlY3RseVxuICAvL3RoaXMubWF4X2luc2VydF9sZW5ndGggPSAwO1xuICAvKiBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdFxuICAgKiBncmVhdGVyIHRoYW4gdGhpcyBsZW5ndGguIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAqIG1heF9pbnNlcnRfbGVuZ3RoIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb24gbGV2ZWxzIDw9IDMuXG4gICAqL1xuXG4gIHRoaXMubGV2ZWwgPSAwOyAgICAgLyogY29tcHJlc3Npb24gbGV2ZWwgKDEuLjkpICovXG4gIHRoaXMuc3RyYXRlZ3kgPSAwOyAgLyogZmF2b3Igb3IgZm9yY2UgSHVmZm1hbiBjb2RpbmcqL1xuXG4gIHRoaXMuZ29vZF9tYXRjaCA9IDA7XG4gIC8qIFVzZSBhIGZhc3RlciBzZWFyY2ggd2hlbiB0aGUgcHJldmlvdXMgbWF0Y2ggaXMgbG9uZ2VyIHRoYW4gdGhpcyAqL1xuXG4gIHRoaXMubmljZV9tYXRjaCA9IDA7IC8qIFN0b3Agc2VhcmNoaW5nIHdoZW4gY3VycmVudCBtYXRjaCBleGNlZWRzIHRoaXMgKi9cblxuICAgICAgICAgICAgICAvKiB1c2VkIGJ5IHRyZWVzLmM6ICovXG5cbiAgLyogRGlkbid0IHVzZSBjdF9kYXRhIHR5cGVkZWYgYmVsb3cgdG8gc3VwcHJlc3MgY29tcGlsZXIgd2FybmluZyAqL1xuXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgZHluX2x0cmVlW0hFQVBfU0laRV07ICAgLyogbGl0ZXJhbCBhbmQgbGVuZ3RoIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fZHRyZWVbMipEX0NPREVTKzFdOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgYmxfdHJlZVsyKkJMX0NPREVTKzFdOyAgLyogSHVmZm1hbiB0cmVlIGZvciBiaXQgbGVuZ3RocyAqL1xuXG4gIC8vIFVzZSBmbGF0IGFycmF5IG9mIERPVUJMRSBzaXplLCB3aXRoIGludGVybGVhdmVkIGZhdGEsXG4gIC8vIGJlY2F1c2UgSlMgZG9lcyBub3Qgc3VwcG9ydCBlZmZlY3RpdmVcbiAgdGhpcy5keW5fbHRyZWUgID0gbmV3IHV0aWxzLkJ1ZjE2KEhFQVBfU0laRSAqIDIpO1xuICB0aGlzLmR5bl9kdHJlZSAgPSBuZXcgdXRpbHMuQnVmMTYoKDIgKiBEX0NPREVTICsgMSkgKiAyKTtcbiAgdGhpcy5ibF90cmVlICAgID0gbmV3IHV0aWxzLkJ1ZjE2KCgyICogQkxfQ09ERVMgKyAxKSAqIDIpO1xuICB6ZXJvKHRoaXMuZHluX2x0cmVlKTtcbiAgemVybyh0aGlzLmR5bl9kdHJlZSk7XG4gIHplcm8odGhpcy5ibF90cmVlKTtcblxuICB0aGlzLmxfZGVzYyAgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgbGl0ZXJhbCB0cmVlICovXG4gIHRoaXMuZF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBkaXN0YW5jZSB0cmVlICovXG4gIHRoaXMuYmxfZGVzYyAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBiaXQgbGVuZ3RoIHRyZWUgKi9cblxuICAvL3VzaCBibF9jb3VudFtNQVhfQklUUysxXTtcbiAgdGhpcy5ibF9jb3VudCA9IG5ldyB1dGlscy5CdWYxNihNQVhfQklUUyArIDEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvL2ludCBoZWFwWzIqTF9DT0RFUysxXTsgICAgICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgdGhpcy5oZWFwID0gbmV3IHV0aWxzLkJ1ZjE2KDIgKiBMX0NPREVTICsgMSk7ICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgemVybyh0aGlzLmhlYXApO1xuXG4gIHRoaXMuaGVhcF9sZW4gPSAwOyAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgaGVhcCAqL1xuICB0aGlzLmhlYXBfbWF4ID0gMDsgICAgICAgICAgICAgICAvKiBlbGVtZW50IG9mIGxhcmdlc3QgZnJlcXVlbmN5ICovXG4gIC8qIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uIGhlYXBbMF0gaXMgbm90IHVzZWQuXG4gICAqIFRoZSBzYW1lIGhlYXAgYXJyYXkgaXMgdXNlZCB0byBidWlsZCBhbGwgdHJlZXMuXG4gICAqL1xuXG4gIHRoaXMuZGVwdGggPSBuZXcgdXRpbHMuQnVmMTYoMiAqIExfQ09ERVMgKyAxKTsgLy91Y2ggZGVwdGhbMipMX0NPREVTKzFdO1xuICB6ZXJvKHRoaXMuZGVwdGgpO1xuICAvKiBEZXB0aCBvZiBlYWNoIHN1YnRyZWUgdXNlZCBhcyB0aWUgYnJlYWtlciBmb3IgdHJlZXMgb2YgZXF1YWwgZnJlcXVlbmN5XG4gICAqL1xuXG4gIHRoaXMubF9idWYgPSAwOyAgICAgICAgICAvKiBidWZmZXIgaW5kZXggZm9yIGxpdGVyYWxzIG9yIGxlbmd0aHMgKi9cblxuICB0aGlzLmxpdF9idWZzaXplID0gMDtcbiAgLyogU2l6ZSBvZiBtYXRjaCBidWZmZXIgZm9yIGxpdGVyYWxzL2xlbmd0aHMuICBUaGVyZSBhcmUgNCByZWFzb25zIGZvclxuICAgKiBsaW1pdGluZyBsaXRfYnVmc2l6ZSB0byA2NEs6XG4gICAqICAgLSBmcmVxdWVuY2llcyBjYW4gYmUga2VwdCBpbiAxNiBiaXQgY291bnRlcnNcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciB0aGUgZmlyc3QgYmxvY2ssIGFsbCBpbnB1dFxuICAgKiAgICAgZGF0YSBpcyBzdGlsbCBpbiB0aGUgd2luZG93IHNvIHdlIGNhbiBzdGlsbCBlbWl0IGEgc3RvcmVkIGJsb2NrIGV2ZW5cbiAgICogICAgIHdoZW4gaW5wdXQgY29tZXMgZnJvbSBzdGFuZGFyZCBpbnB1dC4gIChUaGlzIGNhbiBhbHNvIGJlIGRvbmUgZm9yXG4gICAqICAgICBhbGwgYmxvY2tzIGlmIGxpdF9idWZzaXplIGlzIG5vdCBncmVhdGVyIHRoYW4gMzJLLilcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciBhIGZpbGUgc21hbGxlciB0aGFuIDY0Sywgd2UgY2FuXG4gICAqICAgICBldmVuIGVtaXQgYSBzdG9yZWQgZmlsZSBpbnN0ZWFkIG9mIGEgc3RvcmVkIGJsb2NrIChzYXZpbmcgNSBieXRlcykuXG4gICAqICAgICBUaGlzIGlzIGFwcGxpY2FibGUgb25seSBmb3IgemlwIChub3QgZ3ppcCBvciB6bGliKS5cbiAgICogICAtIGNyZWF0aW5nIG5ldyBIdWZmbWFuIHRyZWVzIGxlc3MgZnJlcXVlbnRseSBtYXkgbm90IHByb3ZpZGUgZmFzdFxuICAgKiAgICAgYWRhcHRhdGlvbiB0byBjaGFuZ2VzIGluIHRoZSBpbnB1dCBkYXRhIHN0YXRpc3RpY3MuIChUYWtlIGZvclxuICAgKiAgICAgZXhhbXBsZSBhIGJpbmFyeSBmaWxlIHdpdGggcG9vcmx5IGNvbXByZXNzaWJsZSBjb2RlIGZvbGxvd2VkIGJ5XG4gICAqICAgICBhIGhpZ2hseSBjb21wcmVzc2libGUgc3RyaW5nIHRhYmxlLikgU21hbGxlciBidWZmZXIgc2l6ZXMgZ2l2ZVxuICAgKiAgICAgZmFzdCBhZGFwdGF0aW9uIGJ1dCBoYXZlIG9mIGNvdXJzZSB0aGUgb3ZlcmhlYWQgb2YgdHJhbnNtaXR0aW5nXG4gICAqICAgICB0cmVlcyBtb3JlIGZyZXF1ZW50bHkuXG4gICAqICAgLSBJIGNhbid0IGNvdW50IGFib3ZlIDRcbiAgICovXG5cbiAgdGhpcy5sYXN0X2xpdCA9IDA7ICAgICAgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuXG4gIHRoaXMuZF9idWYgPSAwO1xuICAvKiBCdWZmZXIgaW5kZXggZm9yIGRpc3RhbmNlcy4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsIGRfYnVmIGFuZCBsX2J1ZiBoYXZlXG4gICAqIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy4gVG8gdXNlIGRpZmZlcmVudCBsZW5ndGhzLCBhbiBleHRyYSBmbGFnXG4gICAqIGFycmF5IHdvdWxkIGJlIG5lY2Vzc2FyeS5cbiAgICovXG5cbiAgdGhpcy5vcHRfbGVuID0gMDsgICAgICAgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggb3B0aW1hbCB0cmVlcyAqL1xuICB0aGlzLnN0YXRpY19sZW4gPSAwOyAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBzdGF0aWMgdHJlZXMgKi9cbiAgdGhpcy5tYXRjaGVzID0gMDsgICAgICAgLyogbnVtYmVyIG9mIHN0cmluZyBtYXRjaGVzIGluIGN1cnJlbnQgYmxvY2sgKi9cbiAgdGhpcy5pbnNlcnQgPSAwOyAgICAgICAgLyogYnl0ZXMgYXQgZW5kIG9mIHdpbmRvdyBsZWZ0IHRvIGluc2VydCAqL1xuXG5cbiAgdGhpcy5iaV9idWYgPSAwO1xuICAvKiBPdXRwdXQgYnVmZmVyLiBiaXRzIGFyZSBpbnNlcnRlZCBzdGFydGluZyBhdCB0aGUgYm90dG9tIChsZWFzdFxuICAgKiBzaWduaWZpY2FudCBiaXRzKS5cbiAgICovXG4gIHRoaXMuYmlfdmFsaWQgPSAwO1xuICAvKiBOdW1iZXIgb2YgdmFsaWQgYml0cyBpbiBiaV9idWYuICBBbGwgYml0cyBhYm92ZSB0aGUgbGFzdCB2YWxpZCBiaXRcbiAgICogYXJlIGFsd2F5cyB6ZXJvLlxuICAgKi9cblxuICAvLyBVc2VkIGZvciB3aW5kb3cgbWVtb3J5IGluaXQuIFdlIHNhZmVseSBpZ25vcmUgaXQgZm9yIEpTLiBUaGF0IG1ha2VzXG4gIC8vIHNlbnNlIG9ubHkgZm9yIHBvaW50ZXJzIGFuZCBtZW1vcnkgY2hlY2sgdG9vbHMuXG4gIC8vdGhpcy5oaWdoX3dhdGVyID0gMDtcbiAgLyogSGlnaCB3YXRlciBtYXJrIG9mZnNldCBpbiB3aW5kb3cgZm9yIGluaXRpYWxpemVkIGJ5dGVzIC0tIGJ5dGVzIGFib3ZlXG4gICAqIHRoaXMgYXJlIHNldCB0byB6ZXJvIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayB3YXJuaW5ncyB3aGVuXG4gICAqIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMgYWNjZXNzIGJ5dGVzIHBhc3QgdGhlIGlucHV0LiAgVGhpcyBpcyB0aGVuXG4gICAqIHVwZGF0ZWQgdG8gdGhlIG5ldyBoaWdoIHdhdGVyIG1hcmsuXG4gICAqL1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVSZXNldEtlZXAoc3RybSkge1xuICB2YXIgcztcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IDA7XG4gIHN0cm0uZGF0YV90eXBlID0gWl9VTktOT1dOO1xuXG4gIHMgPSBzdHJtLnN0YXRlO1xuICBzLnBlbmRpbmcgPSAwO1xuICBzLnBlbmRpbmdfb3V0ID0gMDtcblxuICBpZiAocy53cmFwIDwgMCkge1xuICAgIHMud3JhcCA9IC1zLndyYXA7XG4gICAgLyogd2FzIG1hZGUgbmVnYXRpdmUgYnkgZGVmbGF0ZSguLi4sIFpfRklOSVNIKTsgKi9cbiAgfVxuICBzLnN0YXR1cyA9IChzLndyYXAgPyBJTklUX1NUQVRFIDogQlVTWV9TVEFURSk7XG4gIHN0cm0uYWRsZXIgPSAocy53cmFwID09PSAyKSA/XG4gICAgMCAgLy8gY3JjMzIoMCwgWl9OVUxMLCAwKVxuICA6XG4gICAgMTsgLy8gYWRsZXIzMigwLCBaX05VTEwsIDApXG4gIHMubGFzdF9mbHVzaCA9IFpfTk9fRkxVU0g7XG4gIHRyZWVzLl90cl9pbml0KHMpO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlUmVzZXQoc3RybSkge1xuICB2YXIgcmV0ID0gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKTtcbiAgaWYgKHJldCA9PT0gWl9PSykge1xuICAgIGxtX2luaXQoc3RybS5zdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlU2V0SGVhZGVyKHN0cm0sIGhlYWQpIHtcbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBpZiAoc3RybS5zdGF0ZS53cmFwICE9PSAyKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdHJtLnN0YXRlLmd6aGVhZCA9IGhlYWQ7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgbWV0aG9kLCB3aW5kb3dCaXRzLCBtZW1MZXZlbCwgc3RyYXRlZ3kpIHtcbiAgaWYgKCFzdHJtKSB7IC8vID09PSBaX05VTExcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cbiAgdmFyIHdyYXAgPSAxO1xuXG4gIGlmIChsZXZlbCA9PT0gWl9ERUZBVUxUX0NPTVBSRVNTSU9OKSB7XG4gICAgbGV2ZWwgPSA2O1xuICB9XG5cbiAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7IC8qIHN1cHByZXNzIHpsaWIgd3JhcHBlciAqL1xuICAgIHdyYXAgPSAwO1xuICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0cztcbiAgfVxuXG4gIGVsc2UgaWYgKHdpbmRvd0JpdHMgPiAxNSkge1xuICAgIHdyYXAgPSAyOyAgICAgICAgICAgLyogd3JpdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgKi9cbiAgICB3aW5kb3dCaXRzIC09IDE2O1xuICB9XG5cblxuICBpZiAobWVtTGV2ZWwgPCAxIHx8IG1lbUxldmVsID4gTUFYX01FTV9MRVZFTCB8fCBtZXRob2QgIT09IFpfREVGTEFURUQgfHxcbiAgICB3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUgfHwgbGV2ZWwgPCAwIHx8IGxldmVsID4gOSB8fFxuICAgIHN0cmF0ZWd5IDwgMCB8fCBzdHJhdGVneSA+IFpfRklYRUQpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG5cbiAgaWYgKHdpbmRvd0JpdHMgPT09IDgpIHtcbiAgICB3aW5kb3dCaXRzID0gOTtcbiAgfVxuICAvKiB1bnRpbCAyNTYtYnl0ZSB3aW5kb3cgYnVnIGZpeGVkICovXG5cbiAgdmFyIHMgPSBuZXcgRGVmbGF0ZVN0YXRlKCk7XG5cbiAgc3RybS5zdGF0ZSA9IHM7XG4gIHMuc3RybSA9IHN0cm07XG5cbiAgcy53cmFwID0gd3JhcDtcbiAgcy5nemhlYWQgPSBudWxsO1xuICBzLndfYml0cyA9IHdpbmRvd0JpdHM7XG4gIHMud19zaXplID0gMSA8PCBzLndfYml0cztcbiAgcy53X21hc2sgPSBzLndfc2l6ZSAtIDE7XG5cbiAgcy5oYXNoX2JpdHMgPSBtZW1MZXZlbCArIDc7XG4gIHMuaGFzaF9zaXplID0gMSA8PCBzLmhhc2hfYml0cztcbiAgcy5oYXNoX21hc2sgPSBzLmhhc2hfc2l6ZSAtIDE7XG4gIHMuaGFzaF9zaGlmdCA9IH5+KChzLmhhc2hfYml0cyArIE1JTl9NQVRDSCAtIDEpIC8gTUlOX01BVENIKTtcblxuICBzLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHMud19zaXplICogMik7XG4gIHMuaGVhZCA9IG5ldyB1dGlscy5CdWYxNihzLmhhc2hfc2l6ZSk7XG4gIHMucHJldiA9IG5ldyB1dGlscy5CdWYxNihzLndfc2l6ZSk7XG5cbiAgLy8gRG9uJ3QgbmVlZCBtZW0gaW5pdCBtYWdpYyBmb3IgSlMuXG4gIC8vcy5oaWdoX3dhdGVyID0gMDsgIC8qIG5vdGhpbmcgd3JpdHRlbiB0byBzLT53aW5kb3cgeWV0ICovXG5cbiAgcy5saXRfYnVmc2l6ZSA9IDEgPDwgKG1lbUxldmVsICsgNik7IC8qIDE2SyBlbGVtZW50cyBieSBkZWZhdWx0ICovXG5cbiAgcy5wZW5kaW5nX2J1Zl9zaXplID0gcy5saXRfYnVmc2l6ZSAqIDQ7XG5cbiAgLy9vdmVybGF5ID0gKHVzaGYgKikgWkFMTE9DKHN0cm0sIHMtPmxpdF9idWZzaXplLCBzaXplb2YodXNoKSsyKTtcbiAgLy9zLT5wZW5kaW5nX2J1ZiA9ICh1Y2hmICopIG92ZXJsYXk7XG4gIHMucGVuZGluZ19idWYgPSBuZXcgdXRpbHMuQnVmOChzLnBlbmRpbmdfYnVmX3NpemUpO1xuXG4gIC8vIEl0IGlzIG9mZnNldCBmcm9tIGBzLnBlbmRpbmdfYnVmYCAoc2l6ZSBpcyBgcy5saXRfYnVmc2l6ZSAqIDJgKVxuICAvL3MtPmRfYnVmID0gb3ZlcmxheSArIHMtPmxpdF9idWZzaXplL3NpemVvZih1c2gpO1xuICBzLmRfYnVmID0gMSAqIHMubGl0X2J1ZnNpemU7XG5cbiAgLy9zLT5sX2J1ZiA9IHMtPnBlbmRpbmdfYnVmICsgKDErc2l6ZW9mKHVzaCkpKnMtPmxpdF9idWZzaXplO1xuICBzLmxfYnVmID0gKDEgKyAyKSAqIHMubGl0X2J1ZnNpemU7XG5cbiAgcy5sZXZlbCA9IGxldmVsO1xuICBzLnN0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gIHMubWV0aG9kID0gbWV0aG9kO1xuXG4gIHJldHVybiBkZWZsYXRlUmVzZXQoc3RybSk7XG59XG5cbmZ1bmN0aW9uIGRlZmxhdGVJbml0KHN0cm0sIGxldmVsKSB7XG4gIHJldHVybiBkZWZsYXRlSW5pdDIoc3RybSwgbGV2ZWwsIFpfREVGTEFURUQsIE1BWF9XQklUUywgREVGX01FTV9MRVZFTCwgWl9ERUZBVUxUX1NUUkFURUdZKTtcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlKHN0cm0sIGZsdXNoKSB7XG4gIHZhciBvbGRfZmx1c2gsIHM7XG4gIHZhciBiZWcsIHZhbDsgLy8gZm9yIGd6aXAgaGVhZGVyIHdyaXRlIG9ubHlcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHxcbiAgICBmbHVzaCA+IFpfQkxPQ0sgfHwgZmx1c2ggPCAwKSB7XG4gICAgcmV0dXJuIHN0cm0gPyBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpIDogWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzID0gc3RybS5zdGF0ZTtcblxuICBpZiAoIXN0cm0ub3V0cHV0IHx8XG4gICAgICAoIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkgfHxcbiAgICAgIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIGZsdXNoICE9PSBaX0ZJTklTSCkpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIChzdHJtLmF2YWlsX291dCA9PT0gMCkgPyBaX0JVRl9FUlJPUiA6IFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHMuc3RybSA9IHN0cm07IC8qIGp1c3QgaW4gY2FzZSAqL1xuICBvbGRfZmx1c2ggPSBzLmxhc3RfZmx1c2g7XG4gIHMubGFzdF9mbHVzaCA9IGZsdXNoO1xuXG4gIC8qIFdyaXRlIHRoZSBoZWFkZXIgKi9cbiAgaWYgKHMuc3RhdHVzID09PSBJTklUX1NUQVRFKSB7XG5cbiAgICBpZiAocy53cmFwID09PSAyKSB7IC8vIEdaSVAgaGVhZGVyXG4gICAgICBzdHJtLmFkbGVyID0gMDsgIC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgICBwdXRfYnl0ZShzLCAzMSk7XG4gICAgICBwdXRfYnl0ZShzLCAxMzkpO1xuICAgICAgcHV0X2J5dGUocywgOCk7XG4gICAgICBpZiAoIXMuZ3poZWFkKSB7IC8vIHMtPmd6aGVhZCA9PSBaX05VTExcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgICAgICAgICAgIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICAgIHB1dF9ieXRlKHMsIE9TX0NPREUpO1xuICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRleHQgPyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAocy5nemhlYWQuaGNyYyA/IDIgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuZXh0cmEgPyAwIDogNCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLm5hbWUgPyAwIDogOCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLmNvbW1lbnQgPyAwIDogMTYpXG4gICAgICAgICk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLnRpbWUgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gMTYpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDI0KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgICAgICAgICAgIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLm9zICYgMHhmZik7XG4gICAgICAgIGlmIChzLmd6aGVhZC5leHRyYSAmJiBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHtcbiAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmKTtcbiAgICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQuZXh0cmEubGVuZ3RoID4+IDgpICYgMHhmZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IEVYVFJBX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIC8vIERFRkxBVEUgaGVhZGVyXG4gICAge1xuICAgICAgdmFyIGhlYWRlciA9IChaX0RFRkxBVEVEICsgKChzLndfYml0cyAtIDgpIDw8IDQpKSA8PCA4O1xuICAgICAgdmFyIGxldmVsX2ZsYWdzID0gLTE7XG5cbiAgICAgIGlmIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyKSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMDtcbiAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA8IDYpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzLmxldmVsID09PSA2KSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMztcbiAgICAgIH1cbiAgICAgIGhlYWRlciB8PSAobGV2ZWxfZmxhZ3MgPDwgNik7XG4gICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkgeyBoZWFkZXIgfD0gUFJFU0VUX0RJQ1Q7IH1cbiAgICAgIGhlYWRlciArPSAzMSAtIChoZWFkZXIgJSAzMSk7XG5cbiAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIHB1dFNob3J0TVNCKHMsIGhlYWRlcik7XG5cbiAgICAgIC8qIFNhdmUgdGhlIGFkbGVyMzIgb2YgdGhlIHByZXNldCBkaWN0aW9uYXJ5OiAqL1xuICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHtcbiAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpO1xuICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgICAgIH1cbiAgICAgIHN0cm0uYWRsZXIgPSAxOyAvLyBhZGxlcjMyKDBMLCBaX05VTEwsIDApO1xuICAgIH1cbiAgfVxuXG4vLyNpZmRlZiBHWklQXG4gIGlmIChzLnN0YXR1cyA9PT0gRVhUUkFfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuZXh0cmEvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuXG4gICAgICB3aGlsZSAocy5nemluZGV4IDwgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDB4ZmZmZikpIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYVtzLmd6aW5kZXhdICYgMHhmZik7XG4gICAgICAgIHMuZ3ppbmRleCsrO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAocy5nemluZGV4ID09PSBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHtcbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBOQU1FX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLm5hbWUvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgLy9pbnQgdmFsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5uYW1lLmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLm5hbWUuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG5cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PT0gMCkge1xuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IENPTU1FTlRfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuY29tbWVudC8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICAvL2ludCB2YWw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIHZhbCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlMgc3BlY2lmaWM6IGxpdHRsZSBtYWdpYyB0byBhZGQgemVybyB0ZXJtaW5hdG9yIHRvIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLmNvbW1lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsID0gcy5nemhlYWQuY29tbWVudC5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDB4ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCB2YWwpO1xuICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTtcblxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gSENSQ19TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7XG4gICAgICBpZiAocy5wZW5kaW5nICsgMiA+IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgfVxuICAgICAgaWYgKHMucGVuZGluZyArIDIgPD0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgc3RybS5hZGxlciA9IDA7IC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgfVxuICB9XG4vLyNlbmRpZlxuXG4gIC8qIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUgKi9cbiAgaWYgKHMucGVuZGluZyAhPT0gMCkge1xuICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAvKiBTaW5jZSBhdmFpbF9vdXQgaXMgMCwgZGVmbGF0ZSB3aWxsIGJlIGNhbGxlZCBhZ2FpbiB3aXRoXG4gICAgICAgKiBtb3JlIG91dHB1dCBzcGFjZSwgYnV0IHBvc3NpYmx5IHdpdGggYm90aCBwZW5kaW5nIGFuZFxuICAgICAgICogYXZhaWxfaW4gZXF1YWwgdG8gemVyby4gVGhlcmUgd29uJ3QgYmUgYW55dGhpbmcgdG8gZG8sXG4gICAgICAgKiBidXQgdGhpcyBpcyBub3QgYW4gZXJyb3Igc2l0dWF0aW9uIHNvIG1ha2Ugc3VyZSB3ZVxuICAgICAgICogcmV0dXJuIE9LIGluc3RlYWQgb2YgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCBvZiBkZWZsYXRlOlxuICAgICAgICovXG4gICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgIHJldHVybiBaX09LO1xuICAgIH1cblxuICAgIC8qIE1ha2Ugc3VyZSB0aGVyZSBpcyBzb21ldGhpbmcgdG8gZG8gYW5kIGF2b2lkIGR1cGxpY2F0ZSBjb25zZWN1dGl2ZVxuICAgICAqIGZsdXNoZXMuIEZvciByZXBlYXRlZCBhbmQgdXNlbGVzcyBjYWxscyB3aXRoIFpfRklOSVNILCB3ZSBrZWVwXG4gICAgICogcmV0dXJuaW5nIFpfU1RSRUFNX0VORCBpbnN0ZWFkIG9mIFpfQlVGX0VSUk9SLlxuICAgICAqL1xuICB9IGVsc2UgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgcmFuayhmbHVzaCkgPD0gcmFuayhvbGRfZmx1c2gpICYmXG4gICAgZmx1c2ggIT09IFpfRklOSVNIKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7XG4gIH1cblxuICAvKiBVc2VyIG11c3Qgbm90IHByb3ZpZGUgbW9yZSBpbnB1dCBhZnRlciB0aGUgZmlyc3QgRklOSVNIOiAqL1xuICBpZiAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7XG4gIH1cblxuICAvKiBTdGFydCBhIG5ldyBibG9jayBvciBjb250aW51ZSB0aGUgY3VycmVudCBvbmUuXG4gICAqL1xuICBpZiAoc3RybS5hdmFpbF9pbiAhPT0gMCB8fCBzLmxvb2thaGVhZCAhPT0gMCB8fFxuICAgIChmbHVzaCAhPT0gWl9OT19GTFVTSCAmJiBzLnN0YXR1cyAhPT0gRklOSVNIX1NUQVRFKSkge1xuICAgIHZhciBic3RhdGUgPSAocy5zdHJhdGVneSA9PT0gWl9IVUZGTUFOX09OTFkpID8gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSA6XG4gICAgICAocy5zdHJhdGVneSA9PT0gWl9STEUgPyBkZWZsYXRlX3JsZShzLCBmbHVzaCkgOlxuICAgICAgICBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmZ1bmMocywgZmx1c2gpKTtcblxuICAgIGlmIChic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX0RPTkUpIHtcbiAgICAgIHMuc3RhdHVzID0gRklOSVNIX1NUQVRFO1xuICAgIH1cbiAgICBpZiAoYnN0YXRlID09PSBCU19ORUVEX01PUkUgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCkge1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgICAvKiBhdm9pZCBCVUZfRVJST1IgbmV4dCBjYWxsLCBzZWUgYWJvdmUgKi9cbiAgICAgIH1cbiAgICAgIHJldHVybiBaX09LO1xuICAgICAgLyogSWYgZmx1c2ggIT0gWl9OT19GTFVTSCAmJiBhdmFpbF9vdXQgPT0gMCwgdGhlIG5leHQgY2FsbFxuICAgICAgICogb2YgZGVmbGF0ZSBzaG91bGQgdXNlIHRoZSBzYW1lIGZsdXNoIHBhcmFtZXRlciB0byBtYWtlIHN1cmVcbiAgICAgICAqIHRoYXQgdGhlIGZsdXNoIGlzIGNvbXBsZXRlLiBTbyB3ZSBkb24ndCBoYXZlIHRvIG91dHB1dCBhblxuICAgICAgICogZW1wdHkgYmxvY2sgaGVyZSwgdGhpcyB3aWxsIGJlIGRvbmUgYXQgbmV4dCBjYWxsLiBUaGlzIGFsc29cbiAgICAgICAqIGVuc3VyZXMgdGhhdCBmb3IgYSB2ZXJ5IHNtYWxsIG91dHB1dCBidWZmZXIsIHdlIGVtaXQgYXQgbW9zdFxuICAgICAgICogb25lIGVtcHR5IGJsb2NrLlxuICAgICAgICovXG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX0JMT0NLX0RPTkUpIHtcbiAgICAgIGlmIChmbHVzaCA9PT0gWl9QQVJUSUFMX0ZMVVNIKSB7XG4gICAgICAgIHRyZWVzLl90cl9hbGlnbihzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGZsdXNoICE9PSBaX0JMT0NLKSB7IC8qIEZVTExfRkxVU0ggb3IgU1lOQ19GTFVTSCAqL1xuXG4gICAgICAgIHRyZWVzLl90cl9zdG9yZWRfYmxvY2socywgMCwgMCwgZmFsc2UpO1xuICAgICAgICAvKiBGb3IgYSBmdWxsIGZsdXNoLCB0aGlzIGVtcHR5IGJsb2NrIHdpbGwgYmUgcmVjb2duaXplZFxuICAgICAgICAgKiBhcyBhIHNwZWNpYWwgbWFya2VyIGJ5IGluZmxhdGVfc3luYygpLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZVTExfRkxVU0gpIHtcbiAgICAgICAgICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi8gICAgICAgICAgICAgLyogZm9yZ2V0IGhpc3RvcnkgKi9cbiAgICAgICAgICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG5cbiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgICAgIHMuc3Ryc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5ibG9ja19zdGFydCA9IDA7XG4gICAgICAgICAgICBzLmluc2VydCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHMubGFzdF9mbHVzaCA9IC0xOyAvKiBhdm9pZCBCVUZfRVJST1IgYXQgbmV4dCBjYWxsLCBzZWUgYWJvdmUgKi9cbiAgICAgICAgcmV0dXJuIFpfT0s7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0KHN0cm0tPmF2YWlsX291dCA+IDAsIFwiYnVnMlwiKTtcbiAgLy9pZiAoc3RybS5hdmFpbF9vdXQgPD0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJidWcyXCIpO31cblxuICBpZiAoZmx1c2ggIT09IFpfRklOSVNIKSB7IHJldHVybiBaX09LOyB9XG4gIGlmIChzLndyYXAgPD0gMCkgeyByZXR1cm4gWl9TVFJFQU1fRU5EOyB9XG5cbiAgLyogV3JpdGUgdGhlIHRyYWlsZXIgKi9cbiAgaWYgKHMud3JhcCA9PT0gMikge1xuICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDE2KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDI0KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIHN0cm0udG90YWxfaW4gJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiA4KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDE2KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDI0KSAmIDB4ZmYpO1xuICB9XG4gIGVsc2VcbiAge1xuICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgfVxuXG4gIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gIC8qIElmIGF2YWlsX291dCBpcyB6ZXJvLCB0aGUgYXBwbGljYXRpb24gd2lsbCBjYWxsIGRlZmxhdGUgYWdhaW5cbiAgICogdG8gZmx1c2ggdGhlIHJlc3QuXG4gICAqL1xuICBpZiAocy53cmFwID4gMCkgeyBzLndyYXAgPSAtcy53cmFwOyB9XG4gIC8qIHdyaXRlIHRoZSB0cmFpbGVyIG9ubHkgb25jZSEgKi9cbiAgcmV0dXJuIHMucGVuZGluZyAhPT0gMCA/IFpfT0sgOiBaX1NUUkVBTV9FTkQ7XG59XG5cbmZ1bmN0aW9uIGRlZmxhdGVFbmQoc3RybSkge1xuICB2YXIgc3RhdHVzO1xuXG4gIGlmICghc3RybS8qPT0gWl9OVUxMKi8gfHwgIXN0cm0uc3RhdGUvKj09IFpfTlVMTCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgc3RhdHVzID0gc3RybS5zdGF0ZS5zdGF0dXM7XG4gIGlmIChzdGF0dXMgIT09IElOSVRfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEVYVFJBX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBOQU1FX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBDT01NRU5UX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBIQ1JDX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBCVVNZX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBGSU5JU0hfU1RBVEVcbiAgKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzdHJtLnN0YXRlID0gbnVsbDtcblxuICByZXR1cm4gc3RhdHVzID09PSBCVVNZX1NUQVRFID8gZXJyKHN0cm0sIFpfREFUQV9FUlJPUikgOiBaX09LO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemVzIHRoZSBjb21wcmVzc2lvbiBkaWN0aW9uYXJ5IGZyb20gdGhlIGdpdmVuIGJ5dGVcbiAqIHNlcXVlbmNlIHdpdGhvdXQgcHJvZHVjaW5nIGFueSBjb21wcmVzc2VkIG91dHB1dC5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZVNldERpY3Rpb25hcnkoc3RybSwgZGljdGlvbmFyeSkge1xuICB2YXIgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoO1xuXG4gIHZhciBzO1xuICB2YXIgc3RyLCBuO1xuICB2YXIgd3JhcDtcbiAgdmFyIGF2YWlsO1xuICB2YXIgbmV4dDtcbiAgdmFyIGlucHV0O1xuICB2YXIgdG1wRGljdDtcblxuICBpZiAoIXN0cm0vKj09IFpfTlVMTCovIHx8ICFzdHJtLnN0YXRlLyo9PSBaX05VTEwqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHMgPSBzdHJtLnN0YXRlO1xuICB3cmFwID0gcy53cmFwO1xuXG4gIGlmICh3cmFwID09PSAyIHx8ICh3cmFwID09PSAxICYmIHMuc3RhdHVzICE9PSBJTklUX1NUQVRFKSB8fCBzLmxvb2thaGVhZCkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIC8qIHdoZW4gdXNpbmcgemxpYiB3cmFwcGVycywgY29tcHV0ZSBBZGxlci0zMiBmb3IgcHJvdmlkZWQgZGljdGlvbmFyeSAqL1xuICBpZiAod3JhcCA9PT0gMSkge1xuICAgIC8qIGFkbGVyMzIoc3RybS0+YWRsZXIsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpOyAqL1xuICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyKHN0cm0uYWRsZXIsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApO1xuICB9XG5cbiAgcy53cmFwID0gMDsgICAvKiBhdm9pZCBjb21wdXRpbmcgQWRsZXItMzIgaW4gcmVhZF9idWYgKi9cblxuICAvKiBpZiBkaWN0aW9uYXJ5IHdvdWxkIGZpbGwgd2luZG93LCBqdXN0IHJlcGxhY2UgdGhlIGhpc3RvcnkgKi9cbiAgaWYgKGRpY3RMZW5ndGggPj0gcy53X3NpemUpIHtcbiAgICBpZiAod3JhcCA9PT0gMCkgeyAgICAgICAgICAgIC8qIGFscmVhZHkgZW1wdHkgb3RoZXJ3aXNlICovXG4gICAgICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi9cbiAgICAgIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcbiAgICAgIHMuc3Ryc3RhcnQgPSAwO1xuICAgICAgcy5ibG9ja19zdGFydCA9IDA7XG4gICAgICBzLmluc2VydCA9IDA7XG4gICAgfVxuICAgIC8qIHVzZSB0aGUgdGFpbCAqL1xuICAgIC8vIGRpY3Rpb25hcnkgPSBkaWN0aW9uYXJ5LnNsaWNlKGRpY3RMZW5ndGggLSBzLndfc2l6ZSk7XG4gICAgdG1wRGljdCA9IG5ldyB1dGlscy5CdWY4KHMud19zaXplKTtcbiAgICB1dGlscy5hcnJheVNldCh0bXBEaWN0LCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoIC0gcy53X3NpemUsIHMud19zaXplLCAwKTtcbiAgICBkaWN0aW9uYXJ5ID0gdG1wRGljdDtcbiAgICBkaWN0TGVuZ3RoID0gcy53X3NpemU7XG4gIH1cbiAgLyogaW5zZXJ0IGRpY3Rpb25hcnkgaW50byB3aW5kb3cgYW5kIGhhc2ggKi9cbiAgYXZhaWwgPSBzdHJtLmF2YWlsX2luO1xuICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBkaWN0TGVuZ3RoO1xuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmlucHV0ID0gZGljdGlvbmFyeTtcbiAgZmlsbF93aW5kb3cocyk7XG4gIHdoaWxlIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICBzdHIgPSBzLnN0cnN0YXJ0O1xuICAgIG4gPSBzLmxvb2thaGVhZCAtIChNSU5fTUFUQ0ggLSAxKTtcbiAgICBkbyB7XG4gICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcblxuICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcblxuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyO1xuICAgICAgc3RyKys7XG4gICAgfSB3aGlsZSAoLS1uKTtcbiAgICBzLnN0cnN0YXJ0ID0gc3RyO1xuICAgIHMubG9va2FoZWFkID0gTUlOX01BVENIIC0gMTtcbiAgICBmaWxsX3dpbmRvdyhzKTtcbiAgfVxuICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkO1xuICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDtcbiAgcy5pbnNlcnQgPSBzLmxvb2thaGVhZDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uaW5wdXQgPSBpbnB1dDtcbiAgc3RybS5hdmFpbF9pbiA9IGF2YWlsO1xuICBzLndyYXAgPSB3cmFwO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5leHBvcnRzLmRlZmxhdGVJbml0ID0gZGVmbGF0ZUluaXQ7XG5leHBvcnRzLmRlZmxhdGVJbml0MiA9IGRlZmxhdGVJbml0MjtcbmV4cG9ydHMuZGVmbGF0ZVJlc2V0ID0gZGVmbGF0ZVJlc2V0O1xuZXhwb3J0cy5kZWZsYXRlUmVzZXRLZWVwID0gZGVmbGF0ZVJlc2V0S2VlcDtcbmV4cG9ydHMuZGVmbGF0ZVNldEhlYWRlciA9IGRlZmxhdGVTZXRIZWFkZXI7XG5leHBvcnRzLmRlZmxhdGUgPSBkZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlRW5kID0gZGVmbGF0ZUVuZDtcbmV4cG9ydHMuZGVmbGF0ZVNldERpY3Rpb25hcnkgPSBkZWZsYXRlU2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuZGVmbGF0ZUluZm8gPSAncGFrbyBkZWZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSc7XG5cbi8qIE5vdCBpbXBsZW1lbnRlZFxuZXhwb3J0cy5kZWZsYXRlQm91bmQgPSBkZWZsYXRlQm91bmQ7XG5leHBvcnRzLmRlZmxhdGVDb3B5ID0gZGVmbGF0ZUNvcHk7XG5leHBvcnRzLmRlZmxhdGVQYXJhbXMgPSBkZWZsYXRlUGFyYW1zO1xuZXhwb3J0cy5kZWZsYXRlUGVuZGluZyA9IGRlZmxhdGVQZW5kaW5nO1xuZXhwb3J0cy5kZWZsYXRlUHJpbWUgPSBkZWZsYXRlUHJpbWU7XG5leHBvcnRzLmRlZmxhdGVUdW5lID0gZGVmbGF0ZVR1bmU7XG4qL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbi8vIFNlZSBzdGF0ZSBkZWZzIGZyb20gaW5mbGF0ZS5qc1xudmFyIEJBRCA9IDMwOyAgICAgICAvKiBnb3QgYSBkYXRhIGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgVFlQRSA9IDEyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIHR5cGUgYml0cywgaW5jbHVkaW5nIGxhc3QtZmxhZyBiaXQgKi9cblxuLypcbiAgIERlY29kZSBsaXRlcmFsLCBsZW5ndGgsIGFuZCBkaXN0YW5jZSBjb2RlcyBhbmQgd3JpdGUgb3V0IHRoZSByZXN1bHRpbmdcbiAgIGxpdGVyYWwgYW5kIG1hdGNoIGJ5dGVzIHVudGlsIGVpdGhlciBub3QgZW5vdWdoIGlucHV0IG9yIG91dHB1dCBpc1xuICAgYXZhaWxhYmxlLCBhbiBlbmQtb2YtYmxvY2sgaXMgZW5jb3VudGVyZWQsIG9yIGEgZGF0YSBlcnJvciBpcyBlbmNvdW50ZXJlZC5cbiAgIFdoZW4gbGFyZ2UgZW5vdWdoIGlucHV0IGFuZCBvdXRwdXQgYnVmZmVycyBhcmUgc3VwcGxpZWQgdG8gaW5mbGF0ZSgpLCBmb3JcbiAgIGV4YW1wbGUsIGEgMTZLIGlucHV0IGJ1ZmZlciBhbmQgYSA2NEsgb3V0cHV0IGJ1ZmZlciwgbW9yZSB0aGFuIDk1JSBvZiB0aGVcbiAgIGluZmxhdGUgZXhlY3V0aW9uIHRpbWUgaXMgc3BlbnQgaW4gdGhpcyByb3V0aW5lLlxuXG4gICBFbnRyeSBhc3N1bXB0aW9uczpcblxuICAgICAgICBzdGF0ZS5tb2RlID09PSBMRU5cbiAgICAgICAgc3RybS5hdmFpbF9pbiA+PSA2XG4gICAgICAgIHN0cm0uYXZhaWxfb3V0ID49IDI1OFxuICAgICAgICBzdGFydCA+PSBzdHJtLmF2YWlsX291dFxuICAgICAgICBzdGF0ZS5iaXRzIDwgOFxuXG4gICBPbiByZXR1cm4sIHN0YXRlLm1vZGUgaXMgb25lIG9mOlxuXG4gICAgICAgIExFTiAtLSByYW4gb3V0IG9mIGVub3VnaCBvdXRwdXQgc3BhY2Ugb3IgZW5vdWdoIGF2YWlsYWJsZSBpbnB1dFxuICAgICAgICBUWVBFIC0tIHJlYWNoZWQgZW5kIG9mIGJsb2NrIGNvZGUsIGluZmxhdGUoKSB0byBpbnRlcnByZXQgbmV4dCBibG9ja1xuICAgICAgICBCQUQgLS0gZXJyb3IgaW4gYmxvY2sgZGF0YVxuXG4gICBOb3RlczpcblxuICAgIC0gVGhlIG1heGltdW0gaW5wdXQgYml0cyB1c2VkIGJ5IGEgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgaXMgMTUgYml0cyBmb3IgdGhlXG4gICAgICBsZW5ndGggY29kZSwgNSBiaXRzIGZvciB0aGUgbGVuZ3RoIGV4dHJhLCAxNSBiaXRzIGZvciB0aGUgZGlzdGFuY2UgY29kZSxcbiAgICAgIGFuZCAxMyBiaXRzIGZvciB0aGUgZGlzdGFuY2UgZXh0cmEuICBUaGlzIHRvdGFscyA0OCBiaXRzLCBvciBzaXggYnl0ZXMuXG4gICAgICBUaGVyZWZvcmUgaWYgc3RybS5hdmFpbF9pbiA+PSA2LCB0aGVuIHRoZXJlIGlzIGVub3VnaCBpbnB1dCB0byBhdm9pZFxuICAgICAgY2hlY2tpbmcgZm9yIGF2YWlsYWJsZSBpbnB1dCB3aGlsZSBkZWNvZGluZy5cblxuICAgIC0gVGhlIG1heGltdW0gYnl0ZXMgdGhhdCBhIHNpbmdsZSBsZW5ndGgvZGlzdGFuY2UgcGFpciBjYW4gb3V0cHV0IGlzIDI1OFxuICAgICAgYnl0ZXMsIHdoaWNoIGlzIHRoZSBtYXhpbXVtIGxlbmd0aCB0aGF0IGNhbiBiZSBjb2RlZC4gIGluZmxhdGVfZmFzdCgpXG4gICAgICByZXF1aXJlcyBzdHJtLmF2YWlsX291dCA+PSAyNTggZm9yIGVhY2ggbG9vcCB0byBhdm9pZCBjaGVja2luZyBmb3JcbiAgICAgIG91dHB1dCBzcGFjZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmZsYXRlX2Zhc3Qoc3RybSwgc3RhcnQpIHtcbiAgdmFyIHN0YXRlO1xuICB2YXIgX2luOyAgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5pbnB1dCAqL1xuICB2YXIgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogaGF2ZSBlbm91Z2ggaW5wdXQgd2hpbGUgaW4gPCBsYXN0ICovXG4gIHZhciBfb3V0OyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLm91dHB1dCAqL1xuICB2YXIgYmVnOyAgICAgICAgICAgICAgICAgICAgLyogaW5mbGF0ZSgpJ3MgaW5pdGlhbCBzdHJtLm91dHB1dCAqL1xuICB2YXIgZW5kOyAgICAgICAgICAgICAgICAgICAgLyogd2hpbGUgb3V0IDwgZW5kLCBlbm91Z2ggc3BhY2UgYXZhaWxhYmxlICovXG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICB2YXIgZG1heDsgICAgICAgICAgICAgICAgICAgLyogbWF4aW11bSBkaXN0YW5jZSBmcm9tIHpsaWIgaGVhZGVyICovXG4vLyNlbmRpZlxuICB2YXIgd3NpemU7ICAgICAgICAgICAgICAgICAgLyogd2luZG93IHNpemUgb3IgemVybyBpZiBub3QgdXNpbmcgd2luZG93ICovXG4gIHZhciB3aGF2ZTsgICAgICAgICAgICAgICAgICAvKiB2YWxpZCBieXRlcyBpbiB0aGUgd2luZG93ICovXG4gIHZhciB3bmV4dDsgICAgICAgICAgICAgICAgICAvKiB3aW5kb3cgd3JpdGUgaW5kZXggKi9cbiAgLy8gVXNlIGBzX3dpbmRvd2AgaW5zdGVhZCBgd2luZG93YCwgYXZvaWQgY29uZmxpY3Qgd2l0aCBpbnN0cnVtZW50YXRpb24gdG9vbHNcbiAgdmFyIHNfd2luZG93OyAgICAgICAgICAgICAgIC8qIGFsbG9jYXRlZCBzbGlkaW5nIHdpbmRvdywgaWYgd3NpemUgIT0gMCAqL1xuICB2YXIgaG9sZDsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5ob2xkICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmJpdHMgKi9cbiAgdmFyIGxjb2RlOyAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0ubGVuY29kZSAqL1xuICB2YXIgZGNvZGU7ICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5kaXN0Y29kZSAqL1xuICB2YXIgbG1hc2s7ICAgICAgICAgICAgICAgICAgLyogbWFzayBmb3IgZmlyc3QgbGV2ZWwgb2YgbGVuZ3RoIGNvZGVzICovXG4gIHZhciBkbWFzazsgICAgICAgICAgICAgICAgICAvKiBtYXNrIGZvciBmaXJzdCBsZXZlbCBvZiBkaXN0YW5jZSBjb2RlcyAqL1xuICB2YXIgaGVyZTsgICAgICAgICAgICAgICAgICAgLyogcmV0cmlldmVkIHRhYmxlIGVudHJ5ICovXG4gIHZhciBvcDsgICAgICAgICAgICAgICAgICAgICAvKiBjb2RlIGJpdHMsIG9wZXJhdGlvbiwgZXh0cmEgYml0cywgb3IgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICB3aW5kb3cgcG9zaXRpb24sIHdpbmRvdyBieXRlcyB0byBjb3B5ICovXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAvKiBtYXRjaCBsZW5ndGgsIHVudXNlZCBieXRlcyAqL1xuICB2YXIgZGlzdDsgICAgICAgICAgICAgICAgICAgLyogbWF0Y2ggZGlzdGFuY2UgKi9cbiAgdmFyIGZyb207ICAgICAgICAgICAgICAgICAgIC8qIHdoZXJlIHRvIGNvcHkgbWF0Y2ggZnJvbSAqL1xuICB2YXIgZnJvbV9zb3VyY2U7XG5cblxuICB2YXIgaW5wdXQsIG91dHB1dDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuXG4gIC8qIGNvcHkgc3RhdGUgdG8gbG9jYWwgdmFyaWFibGVzICovXG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgLy9oZXJlID0gc3RhdGUuaGVyZTtcbiAgX2luID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIGxhc3QgPSBfaW4gKyAoc3RybS5hdmFpbF9pbiAtIDUpO1xuICBfb3V0ID0gc3RybS5uZXh0X291dDtcbiAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gIGJlZyA9IF9vdXQgLSAoc3RhcnQgLSBzdHJtLmF2YWlsX291dCk7XG4gIGVuZCA9IF9vdXQgKyAoc3RybS5hdmFpbF9vdXQgLSAyNTcpO1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgZG1heCA9IHN0YXRlLmRtYXg7XG4vLyNlbmRpZlxuICB3c2l6ZSA9IHN0YXRlLndzaXplO1xuICB3aGF2ZSA9IHN0YXRlLndoYXZlO1xuICB3bmV4dCA9IHN0YXRlLnduZXh0O1xuICBzX3dpbmRvdyA9IHN0YXRlLndpbmRvdztcbiAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICBsY29kZSA9IHN0YXRlLmxlbmNvZGU7XG4gIGRjb2RlID0gc3RhdGUuZGlzdGNvZGU7XG4gIGxtYXNrID0gKDEgPDwgc3RhdGUubGVuYml0cykgLSAxO1xuICBkbWFzayA9ICgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDE7XG5cblxuICAvKiBkZWNvZGUgbGl0ZXJhbHMgYW5kIGxlbmd0aC9kaXN0YW5jZXMgdW50aWwgZW5kLW9mLWJsb2NrIG9yIG5vdCBlbm91Z2hcbiAgICAgaW5wdXQgZGF0YSBvciBvdXRwdXQgc3BhY2UgKi9cblxuICB0b3A6XG4gIGRvIHtcbiAgICBpZiAoYml0cyA8IDE1KSB7XG4gICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgYml0cyArPSA4O1xuICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgIGJpdHMgKz0gODtcbiAgICB9XG5cbiAgICBoZXJlID0gbGNvZGVbaG9sZCAmIGxtYXNrXTtcblxuICAgIGRvbGVuOlxuICAgIGZvciAoOzspIHsgLy8gR290byBlbXVsYXRpb25cbiAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovO1xuICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgYml0cyAtPSBvcDtcbiAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLztcbiAgICAgIGlmIChvcCA9PT0gMCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGl0ZXJhbCAqL1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgaGVyZS52YWwgPj0gMHgyMCAmJiBoZXJlLnZhbCA8IDB4N2YgP1xuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgJyVjJ1xcblwiIDpcbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsIDB4JTAyeFxcblwiLCBoZXJlLnZhbCkpO1xuICAgICAgICBvdXRwdXRbX291dCsrXSA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcCAmIDE2KSB7ICAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIGJhc2UgKi9cbiAgICAgICAgbGVuID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgICAgb3AgJj0gMTU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgKi9cbiAgICAgICAgaWYgKG9wKSB7XG4gICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuICs9IGhvbGQgJiAoKDEgPDwgb3ApIC0gMSk7XG4gICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBsZW5ndGggJXVcXG5cIiwgbGVuKSk7XG4gICAgICAgIGlmIChiaXRzIDwgMTUpIHtcbiAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICBoZXJlID0gZGNvZGVbaG9sZCAmIGRtYXNrXTtcblxuICAgICAgICBkb2Rpc3Q6XG4gICAgICAgIGZvciAoOzspIHsgLy8gZ290byBlbXVsYXRpb25cbiAgICAgICAgICBvcCA9IGhlcmUgPj4+IDI0LypoZXJlLmJpdHMqLztcbiAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgICBvcCA9IChoZXJlID4+PiAxNikgJiAweGZmLypoZXJlLm9wKi87XG5cbiAgICAgICAgICBpZiAob3AgJiAxNikgeyAgICAgICAgICAgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYXNlICovXG4gICAgICAgICAgICBkaXN0ID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgICAgICAgIG9wICY9IDE1OyAgICAgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgKi9cbiAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3QgKz0gaG9sZCAmICgoMSA8PCBvcCkgLSAxKTtcbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gICAgICAgICAgICBpZiAoZGlzdCA+IGRtYXgpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZGlzdGFuY2UgJXVcXG5cIiwgZGlzdCkpO1xuICAgICAgICAgICAgb3AgPSBfb3V0IC0gYmVnOyAgICAgICAgICAgICAgICAvKiBtYXggZGlzdGFuY2UgaW4gb3V0cHV0ICovXG4gICAgICAgICAgICBpZiAoZGlzdCA+IG9wKSB7ICAgICAgICAgICAgICAgIC8qIHNlZSBpZiBjb3B5IGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgIG9wID0gZGlzdCAtIG9wOyAgICAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhY2sgaW4gd2luZG93ICovXG4gICAgICAgICAgICAgIGlmIChvcCA+IHdoYXZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHtcbiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgICAgICAgfVxuXG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmF1bHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuLy8jaWZkZWYgSU5GTEFURV9BTExPV19JTlZBTElEX0RJU1RBTkNFX1RPT0ZBUl9BUlJSXG4vLyAgICAgICAgICAgICAgICBpZiAobGVuIDw9IG9wIC0gd2hhdmUpIHtcbi8vICAgICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gMDtcbi8vICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1sZW4pO1xuLy8gICAgICAgICAgICAgICAgICBjb250aW51ZSB0b3A7XG4vLyAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICBsZW4gLT0gb3AgLSB3aGF2ZTtcbi8vICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwO1xuLy8gICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCA+IHdoYXZlKTtcbi8vICAgICAgICAgICAgICAgIGlmIChvcCA9PT0gMCkge1xuLy8gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7XG4vLyAgICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuLy8gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWxlbik7XG4vLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZnJvbSA9IDA7IC8vIHdpbmRvdyBpbmRleFxuICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IHNfd2luZG93O1xuICAgICAgICAgICAgICBpZiAod25leHQgPT09IDApIHsgICAgICAgICAgIC8qIHZlcnkgY29tbW9uIGNhc2UgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplIC0gb3A7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmICh3bmV4dCA8IG9wKSB7ICAgICAgLyogd3JhcCBhcm91bmQgd2luZG93ICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSArIHduZXh0IC0gb3A7XG4gICAgICAgICAgICAgICAgb3AgLT0gd25leHQ7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIGVuZCBvZiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gMDtcbiAgICAgICAgICAgICAgICAgIGlmICh3bmV4dCA8IGxlbikgeyAgLyogc29tZSBmcm9tIHN0YXJ0IG9mIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgICBvcCA9IHduZXh0O1xuICAgICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgIC8qIGNvbnRpZ3VvdXMgaW4gd2luZG93ICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3bmV4dCAtIG9wO1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd2hpbGUgKGxlbiA+IDIpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gMztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgICAgICAgICAvKiBjb3B5IGRpcmVjdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICBkbyB7ICAgICAgICAgICAgICAgICAgICAgICAgLyogbWluaW11bSBsZW5ndGggaXMgdGhyZWUgKi9cbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gMztcbiAgICAgICAgICAgICAgfSB3aGlsZSAobGVuID4gMik7XG4gICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsgICAgICAgICAgLyogMm5kIGxldmVsIGRpc3RhbmNlIGNvZGUgKi9cbiAgICAgICAgICAgIGhlcmUgPSBkY29kZVsoaGVyZSAmIDB4ZmZmZikvKmhlcmUudmFsKi8gKyAoaG9sZCAmICgoMSA8PCBvcCkgLSAxKSldO1xuICAgICAgICAgICAgY29udGludWUgZG9kaXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgY29kZSc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrOyAvLyBuZWVkIHRvIGVtdWxhdGUgZ290byB2aWEgXCJjb250aW51ZVwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAgICAgLyogMm5kIGxldmVsIGxlbmd0aCBjb2RlICovXG4gICAgICAgIGhlcmUgPSBsY29kZVsoaGVyZSAmIDB4ZmZmZikvKmhlcmUudmFsKi8gKyAoaG9sZCAmICgoMSA8PCBvcCkgLSAxKSldO1xuICAgICAgICBjb250aW51ZSBkb2xlbjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wICYgMzIpIHsgICAgICAgICAgICAgICAgICAgICAvKiBlbmQtb2YtYmxvY2sgKi9cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBlbmQgb2YgYmxvY2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrIHRvcDtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7IC8vIG5lZWQgdG8gZW11bGF0ZSBnb3RvIHZpYSBcImNvbnRpbnVlXCJcbiAgICB9XG4gIH0gd2hpbGUgKF9pbiA8IGxhc3QgJiYgX291dCA8IGVuZCk7XG5cbiAgLyogcmV0dXJuIHVudXNlZCBieXRlcyAob24gZW50cnksIGJpdHMgPCA4LCBzbyBpbiB3b24ndCBnbyB0b28gZmFyIGJhY2spICovXG4gIGxlbiA9IGJpdHMgPj4gMztcbiAgX2luIC09IGxlbjtcbiAgYml0cyAtPSBsZW4gPDwgMztcbiAgaG9sZCAmPSAoMSA8PCBiaXRzKSAtIDE7XG5cbiAgLyogdXBkYXRlIHN0YXRlIGFuZCByZXR1cm4gKi9cbiAgc3RybS5uZXh0X2luID0gX2luO1xuICBzdHJtLm5leHRfb3V0ID0gX291dDtcbiAgc3RybS5hdmFpbF9pbiA9IChfaW4gPCBsYXN0ID8gNSArIChsYXN0IC0gX2luKSA6IDUgLSAoX2luIC0gbGFzdCkpO1xuICBzdHJtLmF2YWlsX291dCA9IChfb3V0IDwgZW5kID8gMjU3ICsgKGVuZCAtIF9vdXQpIDogMjU3IC0gKF9vdXQgLSBlbmQpKTtcbiAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gIHN0YXRlLmJpdHMgPSBiaXRzO1xuICByZXR1cm47XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbnZhciB1dGlscyAgICAgICAgID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG52YXIgYWRsZXIzMiAgICAgICA9IHJlcXVpcmUoJy4vYWRsZXIzMicpO1xudmFyIGNyYzMyICAgICAgICAgPSByZXF1aXJlKCcuL2NyYzMyJyk7XG52YXIgaW5mbGF0ZV9mYXN0ICA9IHJlcXVpcmUoJy4vaW5mZmFzdCcpO1xudmFyIGluZmxhdGVfdGFibGUgPSByZXF1aXJlKCcuL2luZnRyZWVzJyk7XG5cbnZhciBDT0RFUyA9IDA7XG52YXIgTEVOUyA9IDE7XG52YXIgRElTVFMgPSAyO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG4vL3ZhciBaX05PX0ZMVVNIICAgICAgPSAwO1xuLy92YXIgWl9QQVJUSUFMX0ZMVVNIID0gMTtcbi8vdmFyIFpfU1lOQ19GTFVTSCAgICA9IDI7XG4vL3ZhciBaX0ZVTExfRkxVU0ggICAgPSAzO1xudmFyIFpfRklOSVNIICAgICAgICA9IDQ7XG52YXIgWl9CTE9DSyAgICAgICAgID0gNTtcbnZhciBaX1RSRUVTICAgICAgICAgPSA2O1xuXG5cbi8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAqL1xudmFyIFpfT0sgICAgICAgICAgICA9IDA7XG52YXIgWl9TVFJFQU1fRU5EICAgID0gMTtcbnZhciBaX05FRURfRElDVCAgICAgPSAyO1xuLy92YXIgWl9FUlJOTyAgICAgICAgID0gLTE7XG52YXIgWl9TVFJFQU1fRVJST1IgID0gLTI7XG52YXIgWl9EQVRBX0VSUk9SICAgID0gLTM7XG52YXIgWl9NRU1fRVJST1IgICAgID0gLTQ7XG52YXIgWl9CVUZfRVJST1IgICAgID0gLTU7XG4vL3ZhciBaX1ZFUlNJT05fRVJST1IgPSAtNjtcblxuLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG52YXIgWl9ERUZMQVRFRCAgPSA4O1xuXG5cbi8qIFNUQVRFUyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbnZhciAgICBIRUFEID0gMTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbWFnaWMgaGVhZGVyICovXG52YXIgICAgRkxBR1MgPSAyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1ldGhvZCBhbmQgZmxhZ3MgKGd6aXApICovXG52YXIgICAgVElNRSA9IDM7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1vZGlmaWNhdGlvbiB0aW1lIChnemlwKSAqL1xudmFyICAgIE9TID0gNDsgICAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBmbGFncyBhbmQgb3BlcmF0aW5nIHN5c3RlbSAoZ3ppcCkgKi9cbnZhciAgICBFWExFTiA9IDU7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgbGVuZ3RoIChnemlwKSAqL1xudmFyICAgIEVYVFJBID0gNjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBieXRlcyAoZ3ppcCkgKi9cbnZhciAgICBOQU1FID0gNzsgICAgICAgLyogaTogd2FpdGluZyBmb3IgZW5kIG9mIGZpbGUgbmFtZSAoZ3ppcCkgKi9cbnZhciAgICBDT01NRU5UID0gODsgICAgLyogaTogd2FpdGluZyBmb3IgZW5kIG9mIGNvbW1lbnQgKGd6aXApICovXG52YXIgICAgSENSQyA9IDk7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGhlYWRlciBjcmMgKGd6aXApICovXG52YXIgICAgRElDVElEID0gMTA7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpY3Rpb25hcnkgY2hlY2sgdmFsdWUgKi9cbnZhciAgICBESUNUID0gMTE7ICAgICAgLyogd2FpdGluZyBmb3IgaW5mbGF0ZVNldERpY3Rpb25hcnkoKSBjYWxsICovXG52YXIgICAgICAgIFRZUEUgPSAxMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciB0eXBlIGJpdHMsIGluY2x1ZGluZyBsYXN0LWZsYWcgYml0ICovXG52YXIgICAgICAgIFRZUEVETyA9IDEzOyAgICAvKiBpOiBzYW1lLCBidXQgc2tpcCBjaGVjayB0byBleGl0IGluZmxhdGUgb24gbmV3IGJsb2NrICovXG52YXIgICAgICAgIFNUT1JFRCA9IDE0OyAgICAvKiBpOiB3YWl0aW5nIGZvciBzdG9yZWQgc2l6ZSAobGVuZ3RoIGFuZCBjb21wbGVtZW50KSAqL1xudmFyICAgICAgICBDT1BZXyA9IDE1OyAgICAgLyogaS9vOiBzYW1lIGFzIENPUFkgYmVsb3csIGJ1dCBvbmx5IGZpcnN0IHRpbWUgaW4gKi9cbnZhciAgICAgICAgQ09QWSA9IDE2OyAgICAgIC8qIGkvbzogd2FpdGluZyBmb3IgaW5wdXQgb3Igb3V0cHV0IHRvIGNvcHkgc3RvcmVkIGJsb2NrICovXG52YXIgICAgICAgIFRBQkxFID0gMTc7ICAgICAvKiBpOiB3YWl0aW5nIGZvciBkeW5hbWljIGJsb2NrIHRhYmxlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgTEVOTEVOUyA9IDE4OyAgIC8qIGk6IHdhaXRpbmcgZm9yIGNvZGUgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xudmFyICAgICAgICBDT0RFTEVOUyA9IDE5OyAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdCBhbmQgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG52YXIgICAgICAgICAgICBMRU5fID0gMjA7ICAgICAgLyogaTogc2FtZSBhcyBMRU4gYmVsb3csIGJ1dCBvbmx5IGZpcnN0IHRpbWUgaW4gKi9cbnZhciAgICAgICAgICAgIExFTiA9IDIxOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGgvbGl0L2VvYiBjb2RlICovXG52YXIgICAgICAgICAgICBMRU5FWFQgPSAyMjsgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoIGV4dHJhIGJpdHMgKi9cbnZhciAgICAgICAgICAgIERJU1QgPSAyMzsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBkaXN0YW5jZSBjb2RlICovXG52YXIgICAgICAgICAgICBESVNURVhUID0gMjQ7ICAgLyogaTogd2FpdGluZyBmb3IgZGlzdGFuY2UgZXh0cmEgYml0cyAqL1xudmFyICAgICAgICAgICAgTUFUQ0ggPSAyNTsgICAgIC8qIG86IHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZSB0byBjb3B5IHN0cmluZyAqL1xudmFyICAgICAgICAgICAgTElUID0gMjY7ICAgICAgIC8qIG86IHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZSB0byB3cml0ZSBsaXRlcmFsICovXG52YXIgICAgQ0hFQ0sgPSAyNzsgICAgIC8qIGk6IHdhaXRpbmcgZm9yIDMyLWJpdCBjaGVjayB2YWx1ZSAqL1xudmFyICAgIExFTkdUSCA9IDI4OyAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgbGVuZ3RoIChnemlwKSAqL1xudmFyICAgIERPTkUgPSAyOTsgICAgICAvKiBmaW5pc2hlZCBjaGVjaywgZG9uZSAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIEJBRCA9IDMwOyAgICAgICAvKiBnb3QgYSBkYXRhIGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgICAgTUVNID0gMzE7ICAgICAgIC8qIGdvdCBhbiBpbmZsYXRlKCkgbWVtb3J5IGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgICAgU1lOQyA9IDMyOyAgICAgIC8qIGxvb2tpbmcgZm9yIHN5bmNocm9uaXphdGlvbiBieXRlcyB0byByZXN0YXJ0IGluZmxhdGUoKSAqL1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cblxudmFyIEVOT1VHSF9MRU5TID0gODUyO1xudmFyIEVOT1VHSF9ESVNUUyA9IDU5Mjtcbi8vdmFyIEVOT1VHSCA9ICAoRU5PVUdIX0xFTlMrRU5PVUdIX0RJU1RTKTtcblxudmFyIE1BWF9XQklUUyA9IDE1O1xuLyogMzJLIExaNzcgd2luZG93ICovXG52YXIgREVGX1dCSVRTID0gTUFYX1dCSVRTO1xuXG5cbmZ1bmN0aW9uIHpzd2FwMzIocSkge1xuICByZXR1cm4gICgoKHEgPj4+IDI0KSAmIDB4ZmYpICtcbiAgICAgICAgICAoKHEgPj4+IDgpICYgMHhmZjAwKSArXG4gICAgICAgICAgKChxICYgMHhmZjAwKSA8PCA4KSArXG4gICAgICAgICAgKChxICYgMHhmZikgPDwgMjQpKTtcbn1cblxuXG5mdW5jdGlvbiBJbmZsYXRlU3RhdGUoKSB7XG4gIHRoaXMubW9kZSA9IDA7ICAgICAgICAgICAgIC8qIGN1cnJlbnQgaW5mbGF0ZSBtb2RlICovXG4gIHRoaXMubGFzdCA9IGZhbHNlOyAgICAgICAgICAvKiB0cnVlIGlmIHByb2Nlc3NpbmcgbGFzdCBibG9jayAqL1xuICB0aGlzLndyYXAgPSAwOyAgICAgICAgICAgICAgLyogYml0IDAgdHJ1ZSBmb3IgemxpYiwgYml0IDEgdHJ1ZSBmb3IgZ3ppcCAqL1xuICB0aGlzLmhhdmVkaWN0ID0gZmFsc2U7ICAgICAgLyogdHJ1ZSBpZiBkaWN0aW9uYXJ5IHByb3ZpZGVkICovXG4gIHRoaXMuZmxhZ3MgPSAwOyAgICAgICAgICAgICAvKiBnemlwIGhlYWRlciBtZXRob2QgYW5kIGZsYWdzICgwIGlmIHpsaWIpICovXG4gIHRoaXMuZG1heCA9IDA7ICAgICAgICAgICAgICAvKiB6bGliIGhlYWRlciBtYXggZGlzdGFuY2UgKElORkxBVEVfU1RSSUNUKSAqL1xuICB0aGlzLmNoZWNrID0gMDsgICAgICAgICAgICAgLyogcHJvdGVjdGVkIGNvcHkgb2YgY2hlY2sgdmFsdWUgKi9cbiAgdGhpcy50b3RhbCA9IDA7ICAgICAgICAgICAgIC8qIHByb3RlY3RlZCBjb3B5IG9mIG91dHB1dCBjb3VudCAqL1xuICAvLyBUT0RPOiBtYXkgYmUge31cbiAgdGhpcy5oZWFkID0gbnVsbDsgICAgICAgICAgIC8qIHdoZXJlIHRvIHNhdmUgZ3ppcCBoZWFkZXIgaW5mb3JtYXRpb24gKi9cblxuICAvKiBzbGlkaW5nIHdpbmRvdyAqL1xuICB0aGlzLndiaXRzID0gMDsgICAgICAgICAgICAgLyogbG9nIGJhc2UgMiBvZiByZXF1ZXN0ZWQgd2luZG93IHNpemUgKi9cbiAgdGhpcy53c2l6ZSA9IDA7ICAgICAgICAgICAgIC8qIHdpbmRvdyBzaXplIG9yIHplcm8gaWYgbm90IHVzaW5nIHdpbmRvdyAqL1xuICB0aGlzLndoYXZlID0gMDsgICAgICAgICAgICAgLyogdmFsaWQgYnl0ZXMgaW4gdGhlIHdpbmRvdyAqL1xuICB0aGlzLnduZXh0ID0gMDsgICAgICAgICAgICAgLyogd2luZG93IHdyaXRlIGluZGV4ICovXG4gIHRoaXMud2luZG93ID0gbnVsbDsgICAgICAgICAvKiBhbGxvY2F0ZWQgc2xpZGluZyB3aW5kb3csIGlmIG5lZWRlZCAqL1xuXG4gIC8qIGJpdCBhY2N1bXVsYXRvciAqL1xuICB0aGlzLmhvbGQgPSAwOyAgICAgICAgICAgICAgLyogaW5wdXQgYml0IGFjY3VtdWxhdG9yICovXG4gIHRoaXMuYml0cyA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgYml0cyBpbiBcImluXCIgKi9cblxuICAvKiBmb3Igc3RyaW5nIGFuZCBzdG9yZWQgYmxvY2sgY29weWluZyAqL1xuICB0aGlzLmxlbmd0aCA9IDA7ICAgICAgICAgICAgLyogbGl0ZXJhbCBvciBsZW5ndGggb2YgZGF0YSB0byBjb3B5ICovXG4gIHRoaXMub2Zmc2V0ID0gMDsgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYWNrIHRvIGNvcHkgc3RyaW5nIGZyb20gKi9cblxuICAvKiBmb3IgdGFibGUgYW5kIGNvZGUgZGVjb2RpbmcgKi9cbiAgdGhpcy5leHRyYSA9IDA7ICAgICAgICAgICAgIC8qIGV4dHJhIGJpdHMgbmVlZGVkICovXG5cbiAgLyogZml4ZWQgYW5kIGR5bmFtaWMgY29kZSB0YWJsZXMgKi9cbiAgdGhpcy5sZW5jb2RlID0gbnVsbDsgICAgICAgICAgLyogc3RhcnRpbmcgdGFibGUgZm9yIGxlbmd0aC9saXRlcmFsIGNvZGVzICovXG4gIHRoaXMuZGlzdGNvZGUgPSBudWxsOyAgICAgICAgIC8qIHN0YXJ0aW5nIHRhYmxlIGZvciBkaXN0YW5jZSBjb2RlcyAqL1xuICB0aGlzLmxlbmJpdHMgPSAwOyAgICAgICAgICAgLyogaW5kZXggYml0cyBmb3IgbGVuY29kZSAqL1xuICB0aGlzLmRpc3RiaXRzID0gMDsgICAgICAgICAgLyogaW5kZXggYml0cyBmb3IgZGlzdGNvZGUgKi9cblxuICAvKiBkeW5hbWljIHRhYmxlIGJ1aWxkaW5nICovXG4gIHRoaXMubmNvZGUgPSAwOyAgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZSBsZW5ndGggY29kZSBsZW5ndGhzICovXG4gIHRoaXMubmxlbiA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLm5kaXN0ID0gMDsgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLmhhdmUgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGUgbGVuZ3RocyBpbiBsZW5zW10gKi9cbiAgdGhpcy5uZXh0ID0gbnVsbDsgICAgICAgICAgICAgIC8qIG5leHQgYXZhaWxhYmxlIHNwYWNlIGluIGNvZGVzW10gKi9cblxuICB0aGlzLmxlbnMgPSBuZXcgdXRpbHMuQnVmMTYoMzIwKTsgLyogdGVtcG9yYXJ5IHN0b3JhZ2UgZm9yIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLndvcmsgPSBuZXcgdXRpbHMuQnVmMTYoMjg4KTsgLyogd29yayBhcmVhIGZvciBjb2RlIHRhYmxlIGJ1aWxkaW5nICovXG5cbiAgLypcbiAgIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBwb2ludGVycyBpbiBqcywgd2UgdXNlIGxlbmNvZGUgYW5kIGRpc3Rjb2RlIGRpcmVjdGx5XG4gICBhcyBidWZmZXJzIHNvIHdlIGRvbid0IG5lZWQgY29kZXNcbiAgKi9cbiAgLy90aGlzLmNvZGVzID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSCk7ICAgICAgIC8qIHNwYWNlIGZvciBjb2RlIHRhYmxlcyAqL1xuICB0aGlzLmxlbmR5biA9IG51bGw7ICAgICAgICAgICAgICAvKiBkeW5hbWljIHRhYmxlIGZvciBsZW5ndGgvbGl0ZXJhbCBjb2RlcyAoSlMgc3BlY2lmaWMpICovXG4gIHRoaXMuZGlzdGR5biA9IG51bGw7ICAgICAgICAgICAgIC8qIGR5bmFtaWMgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzIChKUyBzcGVjaWZpYykgKi9cbiAgdGhpcy5zYW5lID0gMDsgICAgICAgICAgICAgICAgICAgLyogaWYgZmFsc2UsIGFsbG93IGludmFsaWQgZGlzdGFuY2UgdG9vIGZhciAqL1xuICB0aGlzLmJhY2sgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBiaXRzIGJhY2sgb2YgbGFzdCB1bnByb2Nlc3NlZCBsZW5ndGgvbGl0ICovXG4gIHRoaXMud2FzID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIGluaXRpYWwgbGVuZ3RoIG9mIG1hdGNoICovXG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldEtlZXAoc3RybSkge1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IHN0YXRlLnRvdGFsID0gMDtcbiAgc3RybS5tc2cgPSAnJzsgLypaX05VTEwqL1xuICBpZiAoc3RhdGUud3JhcCkgeyAgICAgICAvKiB0byBzdXBwb3J0IGlsbC1jb25jZWl2ZWQgSmF2YSB0ZXN0IHN1aXRlICovXG4gICAgc3RybS5hZGxlciA9IHN0YXRlLndyYXAgJiAxO1xuICB9XG4gIHN0YXRlLm1vZGUgPSBIRUFEO1xuICBzdGF0ZS5sYXN0ID0gMDtcbiAgc3RhdGUuaGF2ZWRpY3QgPSAwO1xuICBzdGF0ZS5kbWF4ID0gMzI3Njg7XG4gIHN0YXRlLmhlYWQgPSBudWxsLypaX05VTEwqLztcbiAgc3RhdGUuaG9sZCA9IDA7XG4gIHN0YXRlLmJpdHMgPSAwO1xuICAvL3N0YXRlLmxlbmNvZGUgPSBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQgPSBzdGF0ZS5jb2RlcztcbiAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5biA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0hfTEVOUyk7XG4gIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5biA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0hfRElTVFMpO1xuXG4gIHN0YXRlLnNhbmUgPSAxO1xuICBzdGF0ZS5iYWNrID0gLTE7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogcmVzZXRcXG5cIikpO1xuICByZXR1cm4gWl9PSztcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0KHN0cm0pIHtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBzdGF0ZS53c2l6ZSA9IDA7XG4gIHN0YXRlLndoYXZlID0gMDtcbiAgc3RhdGUud25leHQgPSAwO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKTtcblxufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXQyKHN0cm0sIHdpbmRvd0JpdHMpIHtcbiAgdmFyIHdyYXA7XG4gIHZhciBzdGF0ZTtcblxuICAvKiBnZXQgdGhlIHN0YXRlICovXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIC8qIGV4dHJhY3Qgd3JhcCByZXF1ZXN0IGZyb20gd2luZG93Qml0cyBwYXJhbWV0ZXIgKi9cbiAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7XG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG4gIGVsc2Uge1xuICAgIHdyYXAgPSAod2luZG93Qml0cyA+PiA0KSArIDE7XG4gICAgaWYgKHdpbmRvd0JpdHMgPCA0OCkge1xuICAgICAgd2luZG93Qml0cyAmPSAxNTtcbiAgICB9XG4gIH1cblxuICAvKiBzZXQgbnVtYmVyIG9mIHdpbmRvdyBiaXRzLCBmcmVlIHdpbmRvdyBpZiBkaWZmZXJlbnQgKi9cbiAgaWYgKHdpbmRvd0JpdHMgJiYgKHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSkpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cbiAgaWYgKHN0YXRlLndpbmRvdyAhPT0gbnVsbCAmJiBzdGF0ZS53Yml0cyAhPT0gd2luZG93Qml0cykge1xuICAgIHN0YXRlLndpbmRvdyA9IG51bGw7XG4gIH1cblxuICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJlc2V0IHRoZSByZXN0IG9mIGl0ICovXG4gIHN0YXRlLndyYXAgPSB3cmFwO1xuICBzdGF0ZS53Yml0cyA9IHdpbmRvd0JpdHM7XG4gIHJldHVybiBpbmZsYXRlUmVzZXQoc3RybSk7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVJbml0MihzdHJtLCB3aW5kb3dCaXRzKSB7XG4gIHZhciByZXQ7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0pIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIC8vc3RybS5tc2cgPSBaX05VTEw7ICAgICAgICAgICAgICAgICAvKiBpbiBjYXNlIHdlIHJldHVybiBhbiBlcnJvciAqL1xuXG4gIHN0YXRlID0gbmV3IEluZmxhdGVTdGF0ZSgpO1xuXG4gIC8vaWYgKHN0YXRlID09PSBaX05VTEwpIHJldHVybiBaX01FTV9FUlJPUjtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiBhbGxvY2F0ZWRcXG5cIikpO1xuICBzdHJtLnN0YXRlID0gc3RhdGU7XG4gIHN0YXRlLndpbmRvdyA9IG51bGwvKlpfTlVMTCovO1xuICByZXQgPSBpbmZsYXRlUmVzZXQyKHN0cm0sIHdpbmRvd0JpdHMpO1xuICBpZiAocmV0ICE9PSBaX09LKSB7XG4gICAgc3RybS5zdGF0ZSA9IG51bGwvKlpfTlVMTCovO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVJbml0KHN0cm0pIHtcbiAgcmV0dXJuIGluZmxhdGVJbml0MihzdHJtLCBERUZfV0JJVFMpO1xufVxuXG5cbi8qXG4gUmV0dXJuIHN0YXRlIHdpdGggbGVuZ3RoIGFuZCBkaXN0YW5jZSBkZWNvZGluZyB0YWJsZXMgYW5kIGluZGV4IHNpemVzIHNldCB0b1xuIGZpeGVkIGNvZGUgZGVjb2RpbmcuICBOb3JtYWxseSB0aGlzIHJldHVybnMgZml4ZWQgdGFibGVzIGZyb20gaW5mZml4ZWQuaC5cbiBJZiBCVUlMREZJWEVEIGlzIGRlZmluZWQsIHRoZW4gaW5zdGVhZCB0aGlzIHJvdXRpbmUgYnVpbGRzIHRoZSB0YWJsZXMgdGhlXG4gZmlyc3QgdGltZSBpdCdzIGNhbGxlZCwgYW5kIHJldHVybnMgdGhvc2UgdGFibGVzIHRoZSBmaXJzdCB0aW1lIGFuZFxuIHRoZXJlYWZ0ZXIuICBUaGlzIHJlZHVjZXMgdGhlIHNpemUgb2YgdGhlIGNvZGUgYnkgYWJvdXQgMksgYnl0ZXMsIGluXG4gZXhjaGFuZ2UgZm9yIGEgbGl0dGxlIGV4ZWN1dGlvbiB0aW1lLiAgSG93ZXZlciwgQlVJTERGSVhFRCBzaG91bGQgbm90IGJlXG4gdXNlZCBmb3IgdGhyZWFkZWQgYXBwbGljYXRpb25zLCBzaW5jZSB0aGUgcmV3cml0aW5nIG9mIHRoZSB0YWJsZXMgYW5kIHZpcmdpblxuIG1heSBub3QgYmUgdGhyZWFkLXNhZmUuXG4gKi9cbnZhciB2aXJnaW4gPSB0cnVlO1xuXG52YXIgbGVuZml4LCBkaXN0Zml4OyAvLyBXZSBoYXZlIG5vIHBvaW50ZXJzIGluIEpTLCBzbyBrZWVwIHRhYmxlcyBzZXBhcmF0ZVxuXG5mdW5jdGlvbiBmaXhlZHRhYmxlcyhzdGF0ZSkge1xuICAvKiBidWlsZCBmaXhlZCBodWZmbWFuIHRhYmxlcyBpZiBmaXJzdCBjYWxsIChtYXkgbm90IGJlIHRocmVhZCBzYWZlKSAqL1xuICBpZiAodmlyZ2luKSB7XG4gICAgdmFyIHN5bTtcblxuICAgIGxlbmZpeCA9IG5ldyB1dGlscy5CdWYzMig1MTIpO1xuICAgIGRpc3RmaXggPSBuZXcgdXRpbHMuQnVmMzIoMzIpO1xuXG4gICAgLyogbGl0ZXJhbC9sZW5ndGggdGFibGUgKi9cbiAgICBzeW0gPSAwO1xuICAgIHdoaWxlIChzeW0gPCAxNDQpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA4OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI1NikgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDk7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjgwKSB7IHN0YXRlLmxlbnNbc3ltKytdID0gNzsgfVxuICAgIHdoaWxlIChzeW0gPCAyODgpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA4OyB9XG5cbiAgICBpbmZsYXRlX3RhYmxlKExFTlMsICBzdGF0ZS5sZW5zLCAwLCAyODgsIGxlbmZpeCwgICAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDkgfSk7XG5cbiAgICAvKiBkaXN0YW5jZSB0YWJsZSAqL1xuICAgIHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDMyKSB7IHN0YXRlLmxlbnNbc3ltKytdID0gNTsgfVxuXG4gICAgaW5mbGF0ZV90YWJsZShESVNUUywgc3RhdGUubGVucywgMCwgMzIsICAgZGlzdGZpeCwgMCwgc3RhdGUud29yaywgeyBiaXRzOiA1IH0pO1xuXG4gICAgLyogZG8gdGhpcyBqdXN0IG9uY2UgKi9cbiAgICB2aXJnaW4gPSBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmxlbmNvZGUgPSBsZW5maXg7XG4gIHN0YXRlLmxlbmJpdHMgPSA5O1xuICBzdGF0ZS5kaXN0Y29kZSA9IGRpc3RmaXg7XG4gIHN0YXRlLmRpc3RiaXRzID0gNTtcbn1cblxuXG4vKlxuIFVwZGF0ZSB0aGUgd2luZG93IHdpdGggdGhlIGxhc3Qgd3NpemUgKG5vcm1hbGx5IDMySykgYnl0ZXMgd3JpdHRlbiBiZWZvcmVcbiByZXR1cm5pbmcuICBJZiB3aW5kb3cgZG9lcyBub3QgZXhpc3QgeWV0LCBjcmVhdGUgaXQuICBUaGlzIGlzIG9ubHkgY2FsbGVkXG4gd2hlbiBhIHdpbmRvdyBpcyBhbHJlYWR5IGluIHVzZSwgb3Igd2hlbiBvdXRwdXQgaGFzIGJlZW4gd3JpdHRlbiBkdXJpbmcgdGhpc1xuIGluZmxhdGUgY2FsbCwgYnV0IHRoZSBlbmQgb2YgdGhlIGRlZmxhdGUgc3RyZWFtIGhhcyBub3QgYmVlbiByZWFjaGVkIHlldC5cbiBJdCBpcyBhbHNvIGNhbGxlZCB0byBjcmVhdGUgYSB3aW5kb3cgZm9yIGRpY3Rpb25hcnkgZGF0YSB3aGVuIGEgZGljdGlvbmFyeVxuIGlzIGxvYWRlZC5cblxuIFByb3ZpZGluZyBvdXRwdXQgYnVmZmVycyBsYXJnZXIgdGhhbiAzMksgdG8gaW5mbGF0ZSgpIHNob3VsZCBwcm92aWRlIGEgc3BlZWRcbiBhZHZhbnRhZ2UsIHNpbmNlIG9ubHkgdGhlIGxhc3QgMzJLIG9mIG91dHB1dCBpcyBjb3BpZWQgdG8gdGhlIHNsaWRpbmcgd2luZG93XG4gdXBvbiByZXR1cm4gZnJvbSBpbmZsYXRlKCksIGFuZCBzaW5jZSBhbGwgZGlzdGFuY2VzIGFmdGVyIHRoZSBmaXJzdCAzMksgb2ZcbiBvdXRwdXQgd2lsbCBmYWxsIGluIHRoZSBvdXRwdXQgZGF0YSwgbWFraW5nIG1hdGNoIGNvcGllcyBzaW1wbGVyIGFuZCBmYXN0ZXIuXG4gVGhlIGFkdmFudGFnZSBtYXkgYmUgZGVwZW5kZW50IG9uIHRoZSBzaXplIG9mIHRoZSBwcm9jZXNzb3IncyBkYXRhIGNhY2hlcy5cbiAqL1xuZnVuY3Rpb24gdXBkYXRld2luZG93KHN0cm0sIHNyYywgZW5kLCBjb3B5KSB7XG4gIHZhciBkaXN0O1xuICB2YXIgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIC8qIGlmIGl0IGhhc24ndCBiZWVuIGRvbmUgYWxyZWFkeSwgYWxsb2NhdGUgc3BhY2UgZm9yIHRoZSB3aW5kb3cgKi9cbiAgaWYgKHN0YXRlLndpbmRvdyA9PT0gbnVsbCkge1xuICAgIHN0YXRlLndzaXplID0gMSA8PCBzdGF0ZS53Yml0cztcbiAgICBzdGF0ZS53bmV4dCA9IDA7XG4gICAgc3RhdGUud2hhdmUgPSAwO1xuXG4gICAgc3RhdGUud2luZG93ID0gbmV3IHV0aWxzLkJ1Zjgoc3RhdGUud3NpemUpO1xuICB9XG5cbiAgLyogY29weSBzdGF0ZS0+d3NpemUgb3IgbGVzcyBvdXRwdXQgYnl0ZXMgaW50byB0aGUgY2lyY3VsYXIgd2luZG93ICovXG4gIGlmIChjb3B5ID49IHN0YXRlLndzaXplKSB7XG4gICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIHN0YXRlLndzaXplLCBzdGF0ZS53c2l6ZSwgMCk7XG4gICAgc3RhdGUud25leHQgPSAwO1xuICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7XG4gIH1cbiAgZWxzZSB7XG4gICAgZGlzdCA9IHN0YXRlLndzaXplIC0gc3RhdGUud25leHQ7XG4gICAgaWYgKGRpc3QgPiBjb3B5KSB7XG4gICAgICBkaXN0ID0gY29weTtcbiAgICB9XG4gICAgLy96bWVtY3B5KHN0YXRlLT53aW5kb3cgKyBzdGF0ZS0+d25leHQsIGVuZCAtIGNvcHksIGRpc3QpO1xuICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBjb3B5LCBkaXN0LCBzdGF0ZS53bmV4dCk7XG4gICAgY29weSAtPSBkaXN0O1xuICAgIGlmIChjb3B5KSB7XG4gICAgICAvL3ptZW1jcHkoc3RhdGUtPndpbmRvdywgZW5kIC0gY29weSwgY29weSk7XG4gICAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gY29weSwgY29weSwgMCk7XG4gICAgICBzdGF0ZS53bmV4dCA9IGNvcHk7XG4gICAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHN0YXRlLnduZXh0ICs9IGRpc3Q7XG4gICAgICBpZiAoc3RhdGUud25leHQgPT09IHN0YXRlLndzaXplKSB7IHN0YXRlLnduZXh0ID0gMDsgfVxuICAgICAgaWYgKHN0YXRlLndoYXZlIDwgc3RhdGUud3NpemUpIHsgc3RhdGUud2hhdmUgKz0gZGlzdDsgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZShzdHJtLCBmbHVzaCkge1xuICB2YXIgc3RhdGU7XG4gIHZhciBpbnB1dCwgb3V0cHV0OyAgICAgICAgICAvLyBpbnB1dC9vdXRwdXQgYnVmZmVyc1xuICB2YXIgbmV4dDsgICAgICAgICAgICAgICAgICAgLyogbmV4dCBpbnB1dCBJTkRFWCAqL1xuICB2YXIgcHV0OyAgICAgICAgICAgICAgICAgICAgLyogbmV4dCBvdXRwdXQgSU5ERVggKi9cbiAgdmFyIGhhdmUsIGxlZnQ7ICAgICAgICAgICAgIC8qIGF2YWlsYWJsZSBpbnB1dCBhbmQgb3V0cHV0ICovXG4gIHZhciBob2xkOyAgICAgICAgICAgICAgICAgICAvKiBiaXQgYnVmZmVyICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgICAgICAgICAvKiBiaXRzIGluIGJpdCBidWZmZXIgKi9cbiAgdmFyIF9pbiwgX291dDsgICAgICAgICAgICAgIC8qIHNhdmUgc3RhcnRpbmcgYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgKi9cbiAgdmFyIGNvcHk7ICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBzdG9yZWQgb3IgbWF0Y2ggYnl0ZXMgdG8gY29weSAqL1xuICB2YXIgZnJvbTsgICAgICAgICAgICAgICAgICAgLyogd2hlcmUgdG8gY29weSBtYXRjaCBieXRlcyBmcm9tICovXG4gIHZhciBmcm9tX3NvdXJjZTtcbiAgdmFyIGhlcmUgPSAwOyAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgZGVjb2RpbmcgdGFibGUgZW50cnkgKi9cbiAgdmFyIGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7IC8vIHBha2VkIFwiaGVyZVwiIGRlbm9ybWFsaXplZCAoSlMgc3BlY2lmaWMpXG4gIC8vdmFyIGxhc3Q7ICAgICAgICAgICAgICAgICAgIC8qIHBhcmVudCB0YWJsZSBlbnRyeSAqL1xuICB2YXIgbGFzdF9iaXRzLCBsYXN0X29wLCBsYXN0X3ZhbDsgLy8gcGFrZWQgXCJsYXN0XCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgdmFyIGxlbjsgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCB0byBjb3B5IGZvciByZXBlYXRzLCBiaXRzIHRvIGRyb3AgKi9cbiAgdmFyIHJldDsgICAgICAgICAgICAgICAgICAgIC8qIHJldHVybiBjb2RlICovXG4gIHZhciBoYnVmID0gbmV3IHV0aWxzLkJ1ZjgoNCk7ICAgIC8qIGJ1ZmZlciBmb3IgZ3ppcCBoZWFkZXIgY3JjIGNhbGN1bGF0aW9uICovXG4gIHZhciBvcHRzO1xuXG4gIHZhciBuOyAvLyB0ZW1wb3JhcnkgdmFyIGZvciBORUVEX0JJVFNcblxuICB2YXIgb3JkZXIgPSAvKiBwZXJtdXRhdGlvbiBvZiBjb2RlIGxlbmd0aHMgKi9cbiAgICBbIDE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTUgXTtcblxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fCAhc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHsgc3RhdGUubW9kZSA9IFRZUEVETzsgfSAgICAvKiBza2lwIGNoZWNrICovXG5cblxuICAvLy0tLSBMT0FEKCkgLS0tXG4gIHB1dCA9IHN0cm0ubmV4dF9vdXQ7XG4gIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7XG4gIG5leHQgPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47XG4gIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICBiaXRzID0gc3RhdGUuYml0cztcbiAgLy8tLS1cblxuICBfaW4gPSBoYXZlO1xuICBfb3V0ID0gbGVmdDtcbiAgcmV0ID0gWl9PSztcblxuICBpbmZfbGVhdmU6IC8vIGdvdG8gZW11bGF0aW9uXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKHN0YXRlLm1vZGUpIHtcbiAgICAgIGNhc2UgSEVBRDpcbiAgICAgICAgaWYgKHN0YXRlLndyYXAgPT09IDApIHtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRURPO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTtcbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoKHN0YXRlLndyYXAgJiAyKSAmJiBob2xkID09PSAweDhiMWYpIHsgIC8qIGd6aXAgaGVhZGVyICovXG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSAwLypjcmMzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG5cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5tb2RlID0gRkxBR1M7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZmxhZ3MgPSAwOyAgICAgICAgICAgLyogZXhwZWN0IHpsaWIgaGVhZGVyICovXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5kb25lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoc3RhdGUud3JhcCAmIDEpIHx8ICAgLyogY2hlY2sgaWYgemxpYiBoZWFkZXIgYWxsb3dlZCAqL1xuICAgICAgICAgICgoKGhvbGQgJiAweGZmKS8qQklUUyg4KSovIDw8IDgpICsgKGhvbGQgPj4gOCkpICUgMzEpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgaGVhZGVyIGNoZWNrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gIT09IFpfREVGTEFURUQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyg0KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNDtcbiAgICAgICAgYml0cyAtPSA0O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIGxlbiA9IChob2xkICYgMHgwZikvKkJJVFMoNCkqLyArIDg7XG4gICAgICAgIGlmIChzdGF0ZS53Yml0cyA9PT0gMCkge1xuICAgICAgICAgIHN0YXRlLndiaXRzID0gbGVuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlbiA+IHN0YXRlLndiaXRzKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCB3aW5kb3cgc2l6ZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5kbWF4ID0gMSA8PCBsZW47XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICB6bGliIGhlYWRlciBva1xcblwiKSk7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDEvKmFkbGVyMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgc3RhdGUubW9kZSA9IGhvbGQgJiAweDIwMCA/IERJQ1RJRCA6IFRZUEU7XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRkxBR1M6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5mbGFncyA9IGhvbGQ7XG4gICAgICAgIGlmICgoc3RhdGUuZmxhZ3MgJiAweGZmKSAhPT0gWl9ERUZMQVRFRCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gY29tcHJlc3Npb24gbWV0aG9kJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4ZTAwMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gaGVhZGVyIGZsYWdzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQudGV4dCA9ICgoaG9sZCA+PiA4KSAmIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBUSU1FO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRJTUU6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQudGltZSA9IGhvbGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDNChzdGF0ZS5jaGVjaywgaG9sZClcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsyXSA9IChob2xkID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhidWZbM10gPSAoaG9sZCA+Pj4gMjQpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCA0LCAwKTtcbiAgICAgICAgICAvLz09PVxuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gT1M7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgT1M6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQueGZsYWdzID0gKGhvbGQgJiAweGZmKTtcbiAgICAgICAgICBzdGF0ZS5oZWFkLm9zID0gKGhvbGQgPj4gOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IEVYTEVOO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIEVYTEVOOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA0MDApIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLmxlbmd0aCA9IGhvbGQ7XG4gICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmFfbGVuID0gaG9sZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbnVsbC8qWl9OVUxMKi87XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IEVYVFJBO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIEVYVFJBOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA0MDApIHtcbiAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgeyBjb3B5ID0gaGF2ZTsgfVxuICAgICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgICAgICBsZW4gPSBzdGF0ZS5oZWFkLmV4dHJhX2xlbiAtIHN0YXRlLmxlbmd0aDtcbiAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5oZWFkLmV4dHJhKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIHVudHlwZWQgYXJyYXkgZm9yIG1vcmUgY29udmVuaWVudCBwcm9jZXNzaW5nIGxhdGVyXG4gICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG5ldyBBcnJheShzdGF0ZS5oZWFkLmV4dHJhX2xlbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdXRpbHMuYXJyYXlTZXQoXG4gICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSxcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgICAgIC8vIGV4dHJhIGZpZWxkIGlzIGxpbWl0ZWQgdG8gNjU1MzYgYnl0ZXNcbiAgICAgICAgICAgICAgICAvLyAtIG5vIG5lZWQgZm9yIGFkZGl0aW9uYWwgc2l6ZSBjaGVja1xuICAgICAgICAgICAgICAgIGNvcHksXG4gICAgICAgICAgICAgICAgLypsZW4gKyBjb3B5ID4gc3RhdGUuaGVhZC5leHRyYV9tYXggLSBsZW4gPyBzdGF0ZS5oZWFkLmV4dHJhX21heCA6IGNvcHksKi9cbiAgICAgICAgICAgICAgICBsZW5cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgLy96bWVtY3B5KHN0YXRlLmhlYWQuZXh0cmEgKyBsZW4sIG5leHQsXG4gICAgICAgICAgICAgIC8vICAgICAgICBsZW4gKyBjb3B5ID4gc3RhdGUuaGVhZC5leHRyYV9tYXggP1xuICAgICAgICAgICAgICAvLyAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9tYXggLSBsZW4gOiBjb3B5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTkFNRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBOQU1FOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA4MDApIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBjb3B5ID0gMDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAvLyBUT0RPOiAyIG9yIDEgYnl0ZXM/XG4gICAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTtcbiAgICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovXG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiZcbiAgICAgICAgICAgICAgICAoc3RhdGUubGVuZ3RoIDwgNjU1MzYgLypzdGF0ZS5oZWFkLm5hbWVfbWF4Ki8pKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTtcblxuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IENPTU1FTlQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09NTUVOVDpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgxMDAwKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgY29weSA9IDA7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5jb21tX21heCovKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgaWYgKGxlbikgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gSENSQztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBIQ1JDOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUuY2hlY2sgJiAweGZmZmYpKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdoZWFkZXIgY3JjIG1pc21hdGNoJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmhjcmMgPSAoKHN0YXRlLmZsYWdzID4+IDkpICYgMSk7XG4gICAgICAgICAgc3RhdGUuaGVhZC5kb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJQ1RJRDpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IHpzd2FwMzIoaG9sZCk7XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElDVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESUNUOlxuICAgICAgICBpZiAoc3RhdGUuaGF2ZWRpY3QgPT09IDApIHtcbiAgICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgICAvLy0tLVxuICAgICAgICAgIHJldHVybiBaX05FRURfRElDVDtcbiAgICAgICAgfVxuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxLyphZGxlcjMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRZUEU6XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9CTE9DSyB8fCBmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUWVBFRE86XG4gICAgICAgIGlmIChzdGF0ZS5sYXN0KSB7XG4gICAgICAgICAgLy8tLS0gQllURUJJVFMoKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBiaXRzICYgNztcbiAgICAgICAgICBiaXRzIC09IGJpdHMgJiA3O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQ0hFQ0s7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMyk7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMykge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5sYXN0ID0gKGhvbGQgJiAweDAxKS8qQklUUygxKSovO1xuICAgICAgICAvLy0tLSBEUk9QQklUUygxKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gMTtcbiAgICAgICAgYml0cyAtPSAxO1xuICAgICAgICAvLy0tLS8vXG5cbiAgICAgICAgc3dpdGNoICgoaG9sZCAmIDB4MDMpLypCSVRTKDIpKi8pIHtcbiAgICAgICAgICBjYXNlIDA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBzdG9yZWQgYmxvY2sgKi9cbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIHN0b3JlZCBibG9jayVzXFxuXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IFNUT1JFRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGZpeGVkIGJsb2NrICovXG4gICAgICAgICAgICBmaXhlZHRhYmxlcyhzdGF0ZSk7XG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBmaXhlZCBjb2RlcyBibG9jayVzXFxuXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTl87ICAgICAgICAgICAgIC8qIGRlY29kZSBjb2RlcyAqL1xuICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZHluYW1pYyBibG9jayAqL1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZHluYW1pYyBjb2RlcyBibG9jayVzXFxuXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRBQkxFO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBibG9jayB0eXBlJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU1RPUkVEOlxuICAgICAgICAvLy0tLSBCWVRFQklUUygpIC0tLS8vIC8qIGdvIHRvIGJ5dGUgYm91bmRhcnkgKi9cbiAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3O1xuICAgICAgICBiaXRzIC09IGJpdHMgJiA3O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoKGhvbGQgJiAweGZmZmYpICE9PSAoKGhvbGQgPj4+IDE2KSBeIDB4ZmZmZikpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHN0b3JlZCBibG9jayBsZW5ndGhzJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IGhvbGQgJiAweGZmZmY7XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgc3RvcmVkIGxlbmd0aCAldVxcblwiLFxuICAgICAgICAvLyAgICAgICAgc3RhdGUubGVuZ3RoKSk7XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ09QWV87XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT1BZXzpcbiAgICAgICAgc3RhdGUubW9kZSA9IENPUFk7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09QWTpcbiAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgaWYgKGNvcHkpIHtcbiAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH1cbiAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbiAgICAgICAgICBpZiAoY29weSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAvLy0tLSB6bWVtY3B5KHB1dCwgbmV4dCwgY29weSk7IC0tLVxuICAgICAgICAgIHV0aWxzLmFycmF5U2V0KG91dHB1dCwgaW5wdXQsIG5leHQsIGNvcHksIHB1dCk7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgbGVmdCAtPSBjb3B5O1xuICAgICAgICAgIHB1dCArPSBjb3B5O1xuICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgc3RvcmVkIGVuZFxcblwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVEFCTEU6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE0KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNCkge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5ubGVuID0gKGhvbGQgJiAweDFmKS8qQklUUyg1KSovICsgMjU3O1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg1KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNTtcbiAgICAgICAgYml0cyAtPSA1O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLm5kaXN0ID0gKGhvbGQgJiAweDFmKS8qQklUUyg1KSovICsgMTtcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDU7XG4gICAgICAgIGJpdHMgLT0gNTtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5uY29kZSA9IChob2xkICYgMHgwZikvKkJJVFMoNCkqLyArIDQ7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDQpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA0O1xuICAgICAgICBiaXRzIC09IDQ7XG4gICAgICAgIC8vLS0tLy9cbi8vI2lmbmRlZiBQS1pJUF9CVUdfV09SS0FST1VORFxuICAgICAgICBpZiAoc3RhdGUubmxlbiA+IDI4NiB8fCBzdGF0ZS5uZGlzdCA+IDMwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndG9vIG1hbnkgbGVuZ3RoIG9yIGRpc3RhbmNlIHN5bWJvbHMnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgdGFibGUgc2l6ZXMgb2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5oYXZlID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkxFTlM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOTEVOUzpcbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCBzdGF0ZS5uY29kZSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMykge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLmxlbnNbb3JkZXJbc3RhdGUuaGF2ZSsrXV0gPSAoaG9sZCAmIDB4MDcpOy8vQklUUygzKTtcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUygzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSAzO1xuICAgICAgICAgIGJpdHMgLT0gMztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCAxOSkge1xuICAgICAgICAgIHN0YXRlLmxlbnNbb3JkZXJbc3RhdGUuaGF2ZSsrXV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICAgICAgICAvL3N0YXRlLmxlbmNvZGUgPSBzdGF0ZS5uZXh0O1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdXNlIGR5bmFtaWMgdGFibGVcbiAgICAgICAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5bjtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IDc7XG5cbiAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUubGVuYml0cyB9O1xuICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKENPREVTLCBzdGF0ZS5sZW5zLCAwLCAxOSwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSBsZW5ndGhzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIGNvZGUgbGVuZ3RocyBva1xcblwiKSk7XG4gICAgICAgIHN0YXRlLmhhdmUgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ09ERUxFTlM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09ERUxFTlM6XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDEpXTsvKkJJVFMoc3RhdGUubGVuYml0cykqL1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGVyZV92YWwgPCAxNikge1xuICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gaGVyZV92YWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGhlcmVfdmFsID09PSAxNikge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAyKTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDI7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZW4gPSBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUgLSAxXTtcbiAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDMpOy8vQklUUygyKTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGVyZV92YWwgPT09IDE3KSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDMpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMztcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDcpOy8vQklUUygzKTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDcpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgNztcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgICAgY29weSA9IDExICsgKGhvbGQgJiAweDdmKTsvL0JJVFMoNyk7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDcpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSA3O1xuICAgICAgICAgICAgICBiaXRzIC09IDc7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlICsgY29weSA+IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0JztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY29weS0tKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiBoYW5kbGUgZXJyb3IgYnJlYWtzIGluIHdoaWxlICovXG4gICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBCQUQpIHsgYnJlYWs7IH1cblxuICAgICAgICAvKiBjaGVjayBmb3IgZW5kLW9mLWJsb2NrIGNvZGUgKGJldHRlciBoYXZlIG9uZSkgKi9cbiAgICAgICAgaWYgKHN0YXRlLmxlbnNbMjU2XSA9PT0gMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSAtLSBtaXNzaW5nIGVuZC1vZi1ibG9jayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGJ1aWxkIGNvZGUgdGFibGVzIC0tIG5vdGU6IGRvIG5vdCBjaGFuZ2UgdGhlIGxlbmJpdHMgb3IgZGlzdGJpdHNcbiAgICAgICAgICAgdmFsdWVzIGhlcmUgKDkgYW5kIDYpIHdpdGhvdXQgcmVhZGluZyB0aGUgY29tbWVudHMgaW4gaW5mdHJlZXMuaFxuICAgICAgICAgICBjb25jZXJuaW5nIHRoZSBFTk9VR0ggY29uc3RhbnRzLCB3aGljaCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzICovXG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSA5O1xuXG4gICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShMRU5TLCBzdGF0ZS5sZW5zLCAwLCBzdGF0ZS5ubGVuLCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy8gc3RhdGUubmV4dF9pbmRleCA9IG9wdHMudGFibGVfaW5kZXg7XG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAgIC8vIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5uZXh0O1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RocyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5kaXN0Yml0cyA9IDY7XG4gICAgICAgIC8vc3RhdGUuZGlzdGNvZGUuY29weShzdGF0ZS5jb2Rlcyk7XG4gICAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZVxuICAgICAgICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW47XG4gICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmRpc3RiaXRzIH07XG4gICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoRElTVFMsIHN0YXRlLmxlbnMsIHN0YXRlLm5sZW4sIHN0YXRlLm5kaXN0LCBzdGF0ZS5kaXN0Y29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgICBzdGF0ZS5kaXN0Yml0cyA9IG9wdHMuYml0cztcbiAgICAgICAgLy8gc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5uZXh0O1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlcyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgJ2luZmxhdGU6ICAgICAgIGNvZGVzIG9rXFxuJykpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOXztcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTl86XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU47XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOOlxuICAgICAgICBpZiAoaGF2ZSA+PSA2ICYmIGxlZnQgPj0gMjU4KSB7XG4gICAgICAgICAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICAgICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gICAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gICAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7XG4gICAgICAgICAgLy8tLS1cbiAgICAgICAgICBpbmZsYXRlX2Zhc3Qoc3RybSwgX291dCk7XG4gICAgICAgICAgLy8tLS0gTE9BRCgpIC0tLVxuICAgICAgICAgIHB1dCA9IHN0cm0ubmV4dF9vdXQ7XG4gICAgICAgICAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gICAgICAgICAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICAgICAgICAgIG5leHQgPSBzdHJtLm5leHRfaW47XG4gICAgICAgICAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICAgICAgICAgIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICAgICAgICAgIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICAgICAgICAgIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICAgICAgICAgIC8vLS0tXG5cbiAgICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkge1xuICAgICAgICAgICAgc3RhdGUuYmFjayA9IC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5iYWNrID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUubGVuYml0cykgLSAxKV07ICAvKkJJVFMoc3RhdGUubGVuYml0cykqL1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoaGVyZV9iaXRzIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiYgKGhlcmVfb3AgJiAweGYwKSA9PT0gMCkge1xuICAgICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0cztcbiAgICAgICAgICBsYXN0X29wID0gaGVyZV9vcDtcbiAgICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsO1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2xhc3RfdmFsICtcbiAgICAgICAgICAgICAgICAgICAgKChob2xkICYgKCgxIDw8IChsYXN0X2JpdHMgKyBsYXN0X29wKSkgLSAxKSkvKkJJVFMobGFzdC5iaXRzICsgbGFzdC5vcCkqLyA+PiBsYXN0X2JpdHMpXTtcbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGxhc3RfYml0cyArIGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMobGFzdC5iaXRzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7XG4gICAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IGhlcmVfdmFsO1xuICAgICAgICBpZiAoaGVyZV9vcCA9PT0gMCkge1xuICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsICclYydcXG5cIiA6XG4gICAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsIDB4JTAyeFxcblwiLCBoZXJlLnZhbCkpO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBMSVQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiAzMikge1xuICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZW5kIG9mIGJsb2NrXFxuXCIpKTtcbiAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5leHRyYSA9IGhlcmVfb3AgJiAxNTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkVYVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5FWFQ6XG4gICAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKHN0YXRlLmV4dHJhKTtcbiAgICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuZ3RoICs9IGhvbGQgJiAoKDEgPDwgc3RhdGUuZXh0cmEpIC0gMSkvKkJJVFMoc3RhdGUuZXh0cmEpKi87XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBsZW5ndGggJXVcXG5cIiwgc3RhdGUubGVuZ3RoKSk7XG4gICAgICAgIHN0YXRlLndhcyA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgc3RhdGUubW9kZSA9IERJU1Q7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElTVDpcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDEpXTsvKkJJVFMoc3RhdGUuZGlzdGJpdHMpKi9cbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKChoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKChoZXJlX29wICYgMHhmMCkgPT09IDApIHtcbiAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbbGFzdF92YWwgK1xuICAgICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtIDEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgICBiaXRzIC09IGxhc3RfYml0cztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgY29kZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5vZmZzZXQgPSBoZXJlX3ZhbDtcbiAgICAgICAgc3RhdGUuZXh0cmEgPSAoaGVyZV9vcCkgJiAxNTtcbiAgICAgICAgc3RhdGUubW9kZSA9IERJU1RFWFQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElTVEVYVDpcbiAgICAgICAgaWYgKHN0YXRlLmV4dHJhKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoc3RhdGUuZXh0cmEpO1xuICAgICAgICAgIG4gPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5vZmZzZXQgKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLSAxKS8qQklUUyhzdGF0ZS5leHRyYSkqLztcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgfVxuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IHN0YXRlLmRtYXgpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBzdGF0ZS5vZmZzZXQpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IE1BVENIO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE1BVENIOlxuICAgICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgY29weSA9IF9vdXQgLSBsZWZ0O1xuICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gY29weSkgeyAgICAgICAgIC8qIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICBjb3B5ID0gc3RhdGUub2Zmc2V0IC0gY29weTtcbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLndoYXZlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuLy8gICAgICAgICAgVHJhY2UoKHN0ZGVyciwgXCJpbmZsYXRlLmMgdG9vIGZhclxcblwiKSk7XG4vLyAgICAgICAgICBjb3B5IC09IHN0YXRlLndoYXZlO1xuLy8gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsgY29weSA9IHN0YXRlLmxlbmd0aDsgfVxuLy8gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4vLyAgICAgICAgICBsZWZ0IC09IGNvcHk7XG4vLyAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbi8vICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IDA7XG4vLyAgICAgICAgICB9IHdoaWxlICgtLWNvcHkpO1xuLy8gICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4vLyAgICAgICAgICBicmVhaztcbi8vI2VuZGlmXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUud25leHQpIHtcbiAgICAgICAgICAgIGNvcHkgLT0gc3RhdGUud25leHQ7XG4gICAgICAgICAgICBmcm9tID0gc3RhdGUud3NpemUgLSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53bmV4dCAtIGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbiAgICAgICAgICBmcm9tX3NvdXJjZSA9IHN0YXRlLndpbmRvdztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBjb3B5IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgZnJvbSA9IHB1dCAtIHN0YXRlLm9mZnNldDtcbiAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgIH0gd2hpbGUgKC0tY29weSk7XG4gICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTElUOlxuICAgICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgb3V0cHV0W3B1dCsrXSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgbGVmdC0tO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ0hFQ0s6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgLy8gVXNlICd8JyBpbnN0ZWFkIG9mICcrJyB0byBtYWtlIHN1cmUgdGhhdCByZXN1bHQgaXMgc2lnbmVkXG4gICAgICAgICAgICBob2xkIHw9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIF9vdXQgLT0gbGVmdDtcbiAgICAgICAgICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICAgICAgICAgIHN0YXRlLnRvdGFsICs9IF9vdXQ7XG4gICAgICAgICAgaWYgKF9vdXQpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9XG4gICAgICAgICAgICAgICAgLypVUERBVEUoc3RhdGUuY2hlY2ssIHB1dCAtIF9vdXQsIF9vdXQpOyovXG4gICAgICAgICAgICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCkgOiBhZGxlcjMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpKTtcblxuICAgICAgICAgIH1cbiAgICAgICAgICBfb3V0ID0gbGVmdDtcbiAgICAgICAgICAvLyBOQjogY3JjMzIgc3RvcmVkIGFzIHNpZ25lZCAzMi1iaXQgaW50LCB6c3dhcDMyIHJldHVybnMgc2lnbmVkIHRvb1xuICAgICAgICAgIGlmICgoc3RhdGUuZmxhZ3MgPyBob2xkIDogenN3YXAzMihob2xkKSkgIT09IHN0YXRlLmNoZWNrKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgZGF0YSBjaGVjayc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBjaGVjayBtYXRjaGVzIHRyYWlsZXJcXG5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5HVEg7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOR1RIOlxuICAgICAgICBpZiAoc3RhdGUud3JhcCAmJiBzdGF0ZS5mbGFncykge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS50b3RhbCAmIDB4ZmZmZmZmZmYpKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgbGVuZ3RoIGNoZWNrJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGxlbmd0aCBtYXRjaGVzIHRyYWlsZXJcXG5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBET05FO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERPTkU6XG4gICAgICAgIHJldCA9IFpfU1RSRUFNX0VORDtcbiAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgY2FzZSBCQUQ6XG4gICAgICAgIHJldCA9IFpfREFUQV9FUlJPUjtcbiAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgY2FzZSBNRU06XG4gICAgICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgICAgIGNhc2UgU1lOQzpcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIH1cbiAgfVxuXG4gIC8vIGluZl9sZWF2ZSA8LSBoZXJlIGlzIHJlYWwgcGxhY2UgZm9yIFwiZ290byBpbmZfbGVhdmVcIiwgZW11bGF0ZWQgdmlhIFwiYnJlYWsgaW5mX2xlYXZlXCJcblxuICAvKlxuICAgICBSZXR1cm4gZnJvbSBpbmZsYXRlKCksIHVwZGF0aW5nIHRoZSB0b3RhbCBjb3VudHMgYW5kIHRoZSBjaGVjayB2YWx1ZS5cbiAgICAgSWYgdGhlcmUgd2FzIG5vIHByb2dyZXNzIGR1cmluZyB0aGUgaW5mbGF0ZSgpIGNhbGwsIHJldHVybiBhIGJ1ZmZlclxuICAgICBlcnJvci4gIENhbGwgdXBkYXRld2luZG93KCkgdG8gY3JlYXRlIGFuZC9vciB1cGRhdGUgdGhlIHdpbmRvdyBzdGF0ZS5cbiAgICAgTm90ZTogYSBtZW1vcnkgZXJyb3IgZnJvbSBpbmZsYXRlKCkgaXMgbm9uLXJlY292ZXJhYmxlLlxuICAgKi9cblxuICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gIHN0YXRlLmhvbGQgPSBob2xkO1xuICBzdGF0ZS5iaXRzID0gYml0cztcbiAgLy8tLS1cblxuICBpZiAoc3RhdGUud3NpemUgfHwgKF9vdXQgIT09IHN0cm0uYXZhaWxfb3V0ICYmIHN0YXRlLm1vZGUgPCBCQUQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA8IENIRUNLIHx8IGZsdXNoICE9PSBaX0ZJTklTSCkpKSB7XG4gICAgaWYgKHVwZGF0ZXdpbmRvdyhzdHJtLCBzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCwgX291dCAtIHN0cm0uYXZhaWxfb3V0KSkge1xuICAgICAgc3RhdGUubW9kZSA9IE1FTTtcbiAgICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgICB9XG4gIH1cbiAgX2luIC09IHN0cm0uYXZhaWxfaW47XG4gIF9vdXQgLT0gc3RybS5hdmFpbF9vdXQ7XG4gIHN0cm0udG90YWxfaW4gKz0gX2luO1xuICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICBzdGF0ZS50b3RhbCArPSBfb3V0O1xuICBpZiAoc3RhdGUud3JhcCAmJiBfb3V0KSB7XG4gICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gLypVUERBVEUoc3RhdGUuY2hlY2ssIHN0cm0ubmV4dF9vdXQgLSBfb3V0LCBfb3V0KTsqL1xuICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCkpO1xuICB9XG4gIHN0cm0uZGF0YV90eXBlID0gc3RhdGUuYml0cyArIChzdGF0ZS5sYXN0ID8gNjQgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlID09PSBUWVBFID8gMTI4IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gTEVOXyB8fCBzdGF0ZS5tb2RlID09PSBDT1BZXyA/IDI1NiA6IDApO1xuICBpZiAoKChfaW4gPT09IDAgJiYgX291dCA9PT0gMCkgfHwgZmx1c2ggPT09IFpfRklOSVNIKSAmJiByZXQgPT09IFpfT0spIHtcbiAgICByZXQgPSBaX0JVRl9FUlJPUjtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlRW5kKHN0cm0pIHtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgLyp8fCBzdHJtLT56ZnJlZSA9PSAoZnJlZV9mdW5jKTAqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHZhciBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmIChzdGF0ZS53aW5kb3cpIHtcbiAgICBzdGF0ZS53aW5kb3cgPSBudWxsO1xuICB9XG4gIHN0cm0uc3RhdGUgPSBudWxsO1xuICByZXR1cm4gWl9PSztcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUdldEhlYWRlcihzdHJtLCBoZWFkKSB7XG4gIHZhciBzdGF0ZTtcblxuICAvKiBjaGVjayBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKChzdGF0ZS53cmFwICYgMikgPT09IDApIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG5cbiAgLyogc2F2ZSBoZWFkZXIgc3RydWN0dXJlICovXG4gIHN0YXRlLmhlYWQgPSBoZWFkO1xuICBoZWFkLmRvbmUgPSBmYWxzZTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVTZXREaWN0aW9uYXJ5KHN0cm0sIGRpY3Rpb25hcnkpIHtcbiAgdmFyIGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDtcblxuICB2YXIgc3RhdGU7XG4gIHZhciBkaWN0aWQ7XG4gIHZhciByZXQ7XG5cbiAgLyogY2hlY2sgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIC8qID09IFpfTlVMTCAqLyB8fCAhc3RybS5zdGF0ZSAvKiA9PSBaX05VTEwgKi8pIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICBpZiAoc3RhdGUud3JhcCAhPT0gMCAmJiBzdGF0ZS5tb2RlICE9PSBESUNUKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgLyogY2hlY2sgZm9yIGNvcnJlY3QgZGljdGlvbmFyeSBpZGVudGlmaWVyICovXG4gIGlmIChzdGF0ZS5tb2RlID09PSBESUNUKSB7XG4gICAgZGljdGlkID0gMTsgLyogYWRsZXIzMigwLCBudWxsLCAwKSovXG4gICAgLyogZGljdGlkID0gYWRsZXIzMihkaWN0aWQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpOyAqL1xuICAgIGRpY3RpZCA9IGFkbGVyMzIoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTtcbiAgICBpZiAoZGljdGlkICE9PSBzdGF0ZS5jaGVjaykge1xuICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjtcbiAgICB9XG4gIH1cbiAgLyogY29weSBkaWN0aW9uYXJ5IHRvIHdpbmRvdyB1c2luZyB1cGRhdGV3aW5kb3coKSwgd2hpY2ggd2lsbCBhbWVuZCB0aGVcbiAgIGV4aXN0aW5nIGRpY3Rpb25hcnkgaWYgYXBwcm9wcmlhdGUgKi9cbiAgcmV0ID0gdXBkYXRld2luZG93KHN0cm0sIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIGRpY3RMZW5ndGgpO1xuICBpZiAocmV0KSB7XG4gICAgc3RhdGUubW9kZSA9IE1FTTtcbiAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gIH1cbiAgc3RhdGUuaGF2ZWRpY3QgPSAxO1xuICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGRpY3Rpb25hcnkgc2V0XFxuXCIpKTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmV4cG9ydHMuaW5mbGF0ZVJlc2V0ID0gaW5mbGF0ZVJlc2V0O1xuZXhwb3J0cy5pbmZsYXRlUmVzZXQyID0gaW5mbGF0ZVJlc2V0MjtcbmV4cG9ydHMuaW5mbGF0ZVJlc2V0S2VlcCA9IGluZmxhdGVSZXNldEtlZXA7XG5leHBvcnRzLmluZmxhdGVJbml0ID0gaW5mbGF0ZUluaXQ7XG5leHBvcnRzLmluZmxhdGVJbml0MiA9IGluZmxhdGVJbml0MjtcbmV4cG9ydHMuaW5mbGF0ZSA9IGluZmxhdGU7XG5leHBvcnRzLmluZmxhdGVFbmQgPSBpbmZsYXRlRW5kO1xuZXhwb3J0cy5pbmZsYXRlR2V0SGVhZGVyID0gaW5mbGF0ZUdldEhlYWRlcjtcbmV4cG9ydHMuaW5mbGF0ZVNldERpY3Rpb25hcnkgPSBpbmZsYXRlU2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuaW5mbGF0ZUluZm8gPSAncGFrbyBpbmZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSc7XG5cbi8qIE5vdCBpbXBsZW1lbnRlZFxuZXhwb3J0cy5pbmZsYXRlQ29weSA9IGluZmxhdGVDb3B5O1xuZXhwb3J0cy5pbmZsYXRlR2V0RGljdGlvbmFyeSA9IGluZmxhdGVHZXREaWN0aW9uYXJ5O1xuZXhwb3J0cy5pbmZsYXRlTWFyayA9IGluZmxhdGVNYXJrO1xuZXhwb3J0cy5pbmZsYXRlUHJpbWUgPSBpbmZsYXRlUHJpbWU7XG5leHBvcnRzLmluZmxhdGVTeW5jID0gaW5mbGF0ZVN5bmM7XG5leHBvcnRzLmluZmxhdGVTeW5jUG9pbnQgPSBpbmZsYXRlU3luY1BvaW50O1xuZXhwb3J0cy5pbmZsYXRlVW5kZXJtaW5lID0gaW5mbGF0ZVVuZGVybWluZTtcbiovXG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cbnZhciBNQVhCSVRTID0gMTU7XG52YXIgRU5PVUdIX0xFTlMgPSA4NTI7XG52YXIgRU5PVUdIX0RJU1RTID0gNTkyO1xuLy92YXIgRU5PVUdIID0gKEVOT1VHSF9MRU5TK0VOT1VHSF9ESVNUUyk7XG5cbnZhciBDT0RFUyA9IDA7XG52YXIgTEVOUyA9IDE7XG52YXIgRElTVFMgPSAyO1xuXG52YXIgbGJhc2UgPSBbIC8qIExlbmd0aCBjb2RlcyAyNTcuLjI4NSBiYXNlICovXG4gIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTMsIDE1LCAxNywgMTksIDIzLCAyNywgMzEsXG4gIDM1LCA0MywgNTEsIDU5LCA2NywgODMsIDk5LCAxMTUsIDEzMSwgMTYzLCAxOTUsIDIyNywgMjU4LCAwLCAwXG5dO1xuXG52YXIgbGV4dCA9IFsgLyogTGVuZ3RoIGNvZGVzIDI1Ny4uMjg1IGV4dHJhICovXG4gIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxNywgMTcsIDE4LCAxOCwgMTgsIDE4LFxuICAxOSwgMTksIDE5LCAxOSwgMjAsIDIwLCAyMCwgMjAsIDIxLCAyMSwgMjEsIDIxLCAxNiwgNzIsIDc4XG5dO1xuXG52YXIgZGJhc2UgPSBbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGJhc2UgKi9cbiAgMSwgMiwgMywgNCwgNSwgNywgOSwgMTMsIDE3LCAyNSwgMzMsIDQ5LCA2NSwgOTcsIDEyOSwgMTkzLFxuICAyNTcsIDM4NSwgNTEzLCA3NjksIDEwMjUsIDE1MzcsIDIwNDksIDMwNzMsIDQwOTcsIDYxNDUsXG4gIDgxOTMsIDEyMjg5LCAxNjM4NSwgMjQ1NzcsIDAsIDBcbl07XG5cbnZhciBkZXh0ID0gWyAvKiBEaXN0YW5jZSBjb2RlcyAwLi4yOSBleHRyYSAqL1xuICAxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxOCwgMTgsIDE5LCAxOSwgMjAsIDIwLCAyMSwgMjEsIDIyLCAyMixcbiAgMjMsIDIzLCAyNCwgMjQsIDI1LCAyNSwgMjYsIDI2LCAyNywgMjcsXG4gIDI4LCAyOCwgMjksIDI5LCA2NCwgNjRcbl07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5mbGF0ZV90YWJsZSh0eXBlLCBsZW5zLCBsZW5zX2luZGV4LCBjb2RlcywgdGFibGUsIHRhYmxlX2luZGV4LCB3b3JrLCBvcHRzKVxue1xuICB2YXIgYml0cyA9IG9wdHMuYml0cztcbiAgICAgIC8vaGVyZSA9IG9wdHMuaGVyZTsgLyogdGFibGUgZW50cnkgZm9yIGR1cGxpY2F0aW9uICovXG5cbiAgdmFyIGxlbiA9IDA7ICAgICAgICAgICAgICAgLyogYSBjb2RlJ3MgbGVuZ3RoIGluIGJpdHMgKi9cbiAgdmFyIHN5bSA9IDA7ICAgICAgICAgICAgICAgLyogaW5kZXggb2YgY29kZSBzeW1ib2xzICovXG4gIHZhciBtaW4gPSAwLCBtYXggPSAwOyAgICAgICAgICAvKiBtaW5pbXVtIGFuZCBtYXhpbXVtIGNvZGUgbGVuZ3RocyAqL1xuICB2YXIgcm9vdCA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3Igcm9vdCB0YWJsZSAqL1xuICB2YXIgY3VyciA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3IgY3VycmVudCB0YWJsZSAqL1xuICB2YXIgZHJvcCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGJpdHMgdG8gZHJvcCBmb3Igc3ViLXRhYmxlICovXG4gIHZhciBsZWZ0ID0gMDsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHByZWZpeCBjb2RlcyBhdmFpbGFibGUgKi9cbiAgdmFyIHVzZWQgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBlbnRyaWVzIGluIHRhYmxlIHVzZWQgKi9cbiAgdmFyIGh1ZmYgPSAwOyAgICAgICAgICAgICAgLyogSHVmZm1hbiBjb2RlICovXG4gIHZhciBpbmNyOyAgICAgICAgICAgICAgLyogZm9yIGluY3JlbWVudGluZyBjb2RlLCBpbmRleCAqL1xuICB2YXIgZmlsbDsgICAgICAgICAgICAgIC8qIGluZGV4IGZvciByZXBsaWNhdGluZyBlbnRyaWVzICovXG4gIHZhciBsb3c7ICAgICAgICAgICAgICAgLyogbG93IGJpdHMgZm9yIGN1cnJlbnQgcm9vdCBlbnRyeSAqL1xuICB2YXIgbWFzazsgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGxvdyByb290IGJpdHMgKi9cbiAgdmFyIG5leHQ7ICAgICAgICAgICAgIC8qIG5leHQgYXZhaWxhYmxlIHNwYWNlIGluIHRhYmxlICovXG4gIHZhciBiYXNlID0gbnVsbDsgICAgIC8qIGJhc2UgdmFsdWUgdGFibGUgdG8gdXNlICovXG4gIHZhciBiYXNlX2luZGV4ID0gMDtcbi8vICB2YXIgc2hvZXh0cmE7ICAgIC8qIGV4dHJhIGJpdHMgdGFibGUgdG8gdXNlICovXG4gIHZhciBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB1c2UgYmFzZSBhbmQgZXh0cmEgZm9yIHN5bWJvbCA+IGVuZCAqL1xuICB2YXIgY291bnQgPSBuZXcgdXRpbHMuQnVmMTYoTUFYQklUUyArIDEpOyAvL1tNQVhCSVRTKzFdOyAgICAvKiBudW1iZXIgb2YgY29kZXMgb2YgZWFjaCBsZW5ndGggKi9cbiAgdmFyIG9mZnMgPSBuZXcgdXRpbHMuQnVmMTYoTUFYQklUUyArIDEpOyAvL1tNQVhCSVRTKzFdOyAgICAgLyogb2Zmc2V0cyBpbiB0YWJsZSBmb3IgZWFjaCBsZW5ndGggKi9cbiAgdmFyIGV4dHJhID0gbnVsbDtcbiAgdmFyIGV4dHJhX2luZGV4ID0gMDtcblxuICB2YXIgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDtcblxuICAvKlxuICAgUHJvY2VzcyBhIHNldCBvZiBjb2RlIGxlbmd0aHMgdG8gY3JlYXRlIGEgY2Fub25pY2FsIEh1ZmZtYW4gY29kZS4gIFRoZVxuICAgY29kZSBsZW5ndGhzIGFyZSBsZW5zWzAuLmNvZGVzLTFdLiAgRWFjaCBsZW5ndGggY29ycmVzcG9uZHMgdG8gdGhlXG4gICBzeW1ib2xzIDAuLmNvZGVzLTEuICBUaGUgSHVmZm1hbiBjb2RlIGlzIGdlbmVyYXRlZCBieSBmaXJzdCBzb3J0aW5nIHRoZVxuICAgc3ltYm9scyBieSBsZW5ndGggZnJvbSBzaG9ydCB0byBsb25nLCBhbmQgcmV0YWluaW5nIHRoZSBzeW1ib2wgb3JkZXJcbiAgIGZvciBjb2RlcyB3aXRoIGVxdWFsIGxlbmd0aHMuICBUaGVuIHRoZSBjb2RlIHN0YXJ0cyB3aXRoIGFsbCB6ZXJvIGJpdHNcbiAgIGZvciB0aGUgZmlyc3QgY29kZSBvZiB0aGUgc2hvcnRlc3QgbGVuZ3RoLCBhbmQgdGhlIGNvZGVzIGFyZSBpbnRlZ2VyXG4gICBpbmNyZW1lbnRzIGZvciB0aGUgc2FtZSBsZW5ndGgsIGFuZCB6ZXJvcyBhcmUgYXBwZW5kZWQgYXMgdGhlIGxlbmd0aFxuICAgaW5jcmVhc2VzLiAgRm9yIHRoZSBkZWZsYXRlIGZvcm1hdCwgdGhlc2UgYml0cyBhcmUgc3RvcmVkIGJhY2t3YXJkc1xuICAgZnJvbSB0aGVpciBtb3JlIG5hdHVyYWwgaW50ZWdlciBpbmNyZW1lbnQgb3JkZXJpbmcsIGFuZCBzbyB3aGVuIHRoZVxuICAgZGVjb2RpbmcgdGFibGVzIGFyZSBidWlsdCBpbiB0aGUgbGFyZ2UgbG9vcCBiZWxvdywgdGhlIGludGVnZXIgY29kZXNcbiAgIGFyZSBpbmNyZW1lbnRlZCBiYWNrd2FyZHMuXG5cbiAgIFRoaXMgcm91dGluZSBhc3N1bWVzLCBidXQgZG9lcyBub3QgY2hlY2ssIHRoYXQgYWxsIG9mIHRoZSBlbnRyaWVzIGluXG4gICBsZW5zW10gYXJlIGluIHRoZSByYW5nZSAwLi5NQVhCSVRTLiAgVGhlIGNhbGxlciBtdXN0IGFzc3VyZSB0aGlzLlxuICAgMS4uTUFYQklUUyBpcyBpbnRlcnByZXRlZCBhcyB0aGF0IGNvZGUgbGVuZ3RoLiAgemVybyBtZWFucyB0aGF0IHRoYXRcbiAgIHN5bWJvbCBkb2VzIG5vdCBvY2N1ciBpbiB0aGlzIGNvZGUuXG5cbiAgIFRoZSBjb2RlcyBhcmUgc29ydGVkIGJ5IGNvbXB1dGluZyBhIGNvdW50IG9mIGNvZGVzIGZvciBlYWNoIGxlbmd0aCxcbiAgIGNyZWF0aW5nIGZyb20gdGhhdCBhIHRhYmxlIG9mIHN0YXJ0aW5nIGluZGljZXMgZm9yIGVhY2ggbGVuZ3RoIGluIHRoZVxuICAgc29ydGVkIHRhYmxlLCBhbmQgdGhlbiBlbnRlcmluZyB0aGUgc3ltYm9scyBpbiBvcmRlciBpbiB0aGUgc29ydGVkXG4gICB0YWJsZS4gIFRoZSBzb3J0ZWQgdGFibGUgaXMgd29ya1tdLCB3aXRoIHRoYXQgc3BhY2UgYmVpbmcgcHJvdmlkZWQgYnlcbiAgIHRoZSBjYWxsZXIuXG5cbiAgIFRoZSBsZW5ndGggY291bnRzIGFyZSB1c2VkIGZvciBvdGhlciBwdXJwb3NlcyBhcyB3ZWxsLCBpLmUuIGZpbmRpbmdcbiAgIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGxlbmd0aCBjb2RlcywgZGV0ZXJtaW5pbmcgaWYgdGhlcmUgYXJlIGFueVxuICAgY29kZXMgYXQgYWxsLCBjaGVja2luZyBmb3IgYSB2YWxpZCBzZXQgb2YgbGVuZ3RocywgYW5kIGxvb2tpbmcgYWhlYWRcbiAgIGF0IGxlbmd0aCBjb3VudHMgdG8gZGV0ZXJtaW5lIHN1Yi10YWJsZSBzaXplcyB3aGVuIGJ1aWxkaW5nIHRoZVxuICAgZGVjb2RpbmcgdGFibGVzLlxuICAgKi9cblxuICAvKiBhY2N1bXVsYXRlIGxlbmd0aHMgZm9yIGNvZGVzIChhc3N1bWVzIGxlbnNbXSBhbGwgaW4gMC4uTUFYQklUUykgKi9cbiAgZm9yIChsZW4gPSAwOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHtcbiAgICBjb3VudFtsZW5dID0gMDtcbiAgfVxuICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykge1xuICAgIGNvdW50W2xlbnNbbGVuc19pbmRleCArIHN5bV1dKys7XG4gIH1cblxuICAvKiBib3VuZCBjb2RlIGxlbmd0aHMsIGZvcmNlIHJvb3QgdG8gYmUgd2l0aGluIGNvZGUgbGVuZ3RocyAqL1xuICByb290ID0gYml0cztcbiAgZm9yIChtYXggPSBNQVhCSVRTOyBtYXggPj0gMTsgbWF4LS0pIHtcbiAgICBpZiAoY291bnRbbWF4XSAhPT0gMCkgeyBicmVhazsgfVxuICB9XG4gIGlmIChyb290ID4gbWF4KSB7XG4gICAgcm9vdCA9IG1heDtcbiAgfVxuICBpZiAobWF4ID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgLyogbm8gc3ltYm9scyB0byBjb2RlIGF0IGFsbCAqL1xuICAgIC8vdGFibGUub3Bbb3B0cy50YWJsZV9pbmRleF0gPSA2NDsgIC8vaGVyZS5vcCA9ICh2YXIgY2hhcik2NDsgICAgLyogaW52YWxpZCBjb2RlIG1hcmtlciAqL1xuICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7ICAgLy9oZXJlLmJpdHMgPSAodmFyIGNoYXIpMTtcbiAgICAvL3RhYmxlLnZhbFtvcHRzLnRhYmxlX2luZGV4KytdID0gMDsgICAvL2hlcmUudmFsID0gKHZhciBzaG9ydCkwO1xuICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gKDEgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG5cblxuICAgIC8vdGFibGUub3Bbb3B0cy50YWJsZV9pbmRleF0gPSA2NDtcbiAgICAvL3RhYmxlLmJpdHNbb3B0cy50YWJsZV9pbmRleF0gPSAxO1xuICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwO1xuICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gKDEgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG5cbiAgICBvcHRzLmJpdHMgPSAxO1xuICAgIHJldHVybiAwOyAgICAgLyogbm8gc3ltYm9scywgYnV0IHdhaXQgZm9yIGRlY29kaW5nIHRvIHJlcG9ydCBlcnJvciAqL1xuICB9XG4gIGZvciAobWluID0gMTsgbWluIDwgbWF4OyBtaW4rKykge1xuICAgIGlmIChjb3VudFttaW5dICE9PSAwKSB7IGJyZWFrOyB9XG4gIH1cbiAgaWYgKHJvb3QgPCBtaW4pIHtcbiAgICByb290ID0gbWluO1xuICB9XG5cbiAgLyogY2hlY2sgZm9yIGFuIG92ZXItc3Vic2NyaWJlZCBvciBpbmNvbXBsZXRlIHNldCBvZiBsZW5ndGhzICovXG4gIGxlZnQgPSAxO1xuICBmb3IgKGxlbiA9IDE7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykge1xuICAgIGxlZnQgPDw9IDE7XG4gICAgbGVmdCAtPSBjb3VudFtsZW5dO1xuICAgIGlmIChsZWZ0IDwgMCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gICAgICAgIC8qIG92ZXItc3Vic2NyaWJlZCAqL1xuICB9XG4gIGlmIChsZWZ0ID4gMCAmJiAodHlwZSA9PT0gQ09ERVMgfHwgbWF4ICE9PSAxKSkge1xuICAgIHJldHVybiAtMTsgICAgICAgICAgICAgICAgICAgICAgLyogaW5jb21wbGV0ZSBzZXQgKi9cbiAgfVxuXG4gIC8qIGdlbmVyYXRlIG9mZnNldHMgaW50byBzeW1ib2wgdGFibGUgZm9yIGVhY2ggbGVuZ3RoIGZvciBzb3J0aW5nICovXG4gIG9mZnNbMV0gPSAwO1xuICBmb3IgKGxlbiA9IDE7IGxlbiA8IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgb2Zmc1tsZW4gKyAxXSA9IG9mZnNbbGVuXSArIGNvdW50W2xlbl07XG4gIH1cblxuICAvKiBzb3J0IHN5bWJvbHMgYnkgbGVuZ3RoLCBieSBzeW1ib2wgb3JkZXIgd2l0aGluIGVhY2ggbGVuZ3RoICovXG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgaWYgKGxlbnNbbGVuc19pbmRleCArIHN5bV0gIT09IDApIHtcbiAgICAgIHdvcmtbb2Zmc1tsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrXSA9IHN5bTtcbiAgICB9XG4gIH1cblxuICAvKlxuICAgQ3JlYXRlIGFuZCBmaWxsIGluIGRlY29kaW5nIHRhYmxlcy4gIEluIHRoaXMgbG9vcCwgdGhlIHRhYmxlIGJlaW5nXG4gICBmaWxsZWQgaXMgYXQgbmV4dCBhbmQgaGFzIGN1cnIgaW5kZXggYml0cy4gIFRoZSBjb2RlIGJlaW5nIHVzZWQgaXMgaHVmZlxuICAgd2l0aCBsZW5ndGggbGVuLiAgVGhhdCBjb2RlIGlzIGNvbnZlcnRlZCB0byBhbiBpbmRleCBieSBkcm9wcGluZyBkcm9wXG4gICBiaXRzIG9mZiBvZiB0aGUgYm90dG9tLiAgRm9yIGNvZGVzIHdoZXJlIGxlbiBpcyBsZXNzIHRoYW4gZHJvcCArIGN1cnIsXG4gICB0aG9zZSB0b3AgZHJvcCArIGN1cnIgLSBsZW4gYml0cyBhcmUgaW5jcmVtZW50ZWQgdGhyb3VnaCBhbGwgdmFsdWVzIHRvXG4gICBmaWxsIHRoZSB0YWJsZSB3aXRoIHJlcGxpY2F0ZWQgZW50cmllcy5cblxuICAgcm9vdCBpcyB0aGUgbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIHRoZSByb290IHRhYmxlLiAgV2hlbiBsZW4gZXhjZWVkc1xuICAgcm9vdCwgc3ViLXRhYmxlcyBhcmUgY3JlYXRlZCBwb2ludGVkIHRvIGJ5IHRoZSByb290IGVudHJ5IHdpdGggYW4gaW5kZXhcbiAgIG9mIHRoZSBsb3cgcm9vdCBiaXRzIG9mIGh1ZmYuICBUaGlzIGlzIHNhdmVkIGluIGxvdyB0byBjaGVjayBmb3Igd2hlbiBhXG4gICBuZXcgc3ViLXRhYmxlIHNob3VsZCBiZSBzdGFydGVkLiAgZHJvcCBpcyB6ZXJvIHdoZW4gdGhlIHJvb3QgdGFibGUgaXNcbiAgIGJlaW5nIGZpbGxlZCwgYW5kIGRyb3AgaXMgcm9vdCB3aGVuIHN1Yi10YWJsZXMgYXJlIGJlaW5nIGZpbGxlZC5cblxuICAgV2hlbiBhIG5ldyBzdWItdGFibGUgaXMgbmVlZGVkLCBpdCBpcyBuZWNlc3NhcnkgdG8gbG9vayBhaGVhZCBpbiB0aGVcbiAgIGNvZGUgbGVuZ3RocyB0byBkZXRlcm1pbmUgd2hhdCBzaXplIHN1Yi10YWJsZSBpcyBuZWVkZWQuICBUaGUgbGVuZ3RoXG4gICBjb3VudHMgYXJlIHVzZWQgZm9yIHRoaXMsIGFuZCBzbyBjb3VudFtdIGlzIGRlY3JlbWVudGVkIGFzIGNvZGVzIGFyZVxuICAgZW50ZXJlZCBpbiB0aGUgdGFibGVzLlxuXG4gICB1c2VkIGtlZXBzIHRyYWNrIG9mIGhvdyBtYW55IHRhYmxlIGVudHJpZXMgaGF2ZSBiZWVuIGFsbG9jYXRlZCBmcm9tIHRoZVxuICAgcHJvdmlkZWQgKnRhYmxlIHNwYWNlLiAgSXQgaXMgY2hlY2tlZCBmb3IgTEVOUyBhbmQgRElTVCB0YWJsZXMgYWdhaW5zdFxuICAgdGhlIGNvbnN0YW50cyBFTk9VR0hfTEVOUyBhbmQgRU5PVUdIX0RJU1RTIHRvIGd1YXJkIGFnYWluc3QgY2hhbmdlcyBpblxuICAgdGhlIGluaXRpYWwgcm9vdCB0YWJsZSBzaXplIGNvbnN0YW50cy4gIFNlZSB0aGUgY29tbWVudHMgaW4gaW5mdHJlZXMuaFxuICAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cbiAgIHN5bSBpbmNyZW1lbnRzIHRocm91Z2ggYWxsIHN5bWJvbHMsIGFuZCB0aGUgbG9vcCB0ZXJtaW5hdGVzIHdoZW5cbiAgIGFsbCBjb2RlcyBvZiBsZW5ndGggbWF4LCBpLmUuIGFsbCBjb2RlcywgaGF2ZSBiZWVuIHByb2Nlc3NlZC4gIFRoaXNcbiAgIHJvdXRpbmUgcGVybWl0cyBpbmNvbXBsZXRlIGNvZGVzLCBzbyBhbm90aGVyIGxvb3AgYWZ0ZXIgdGhpcyBvbmUgZmlsbHNcbiAgIGluIHRoZSByZXN0IG9mIHRoZSBkZWNvZGluZyB0YWJsZXMgd2l0aCBpbnZhbGlkIGNvZGUgbWFya2Vycy5cbiAgICovXG5cbiAgLyogc2V0IHVwIGZvciBjb2RlIHR5cGUgKi9cbiAgLy8gcG9vciBtYW4gb3B0aW1pemF0aW9uIC0gdXNlIGlmLWVsc2UgaW5zdGVhZCBvZiBzd2l0Y2gsXG4gIC8vIHRvIGF2b2lkIGRlb3B0cyBpbiBvbGQgdjhcbiAgaWYgKHR5cGUgPT09IENPREVTKSB7XG4gICAgYmFzZSA9IGV4dHJhID0gd29yazsgICAgLyogZHVtbXkgdmFsdWUtLW5vdCB1c2VkICovXG4gICAgZW5kID0gMTk7XG5cbiAgfSBlbHNlIGlmICh0eXBlID09PSBMRU5TKSB7XG4gICAgYmFzZSA9IGxiYXNlO1xuICAgIGJhc2VfaW5kZXggLT0gMjU3O1xuICAgIGV4dHJhID0gbGV4dDtcbiAgICBleHRyYV9pbmRleCAtPSAyNTc7XG4gICAgZW5kID0gMjU2O1xuXG4gIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAvKiBESVNUUyAqL1xuICAgIGJhc2UgPSBkYmFzZTtcbiAgICBleHRyYSA9IGRleHQ7XG4gICAgZW5kID0gLTE7XG4gIH1cblxuICAvKiBpbml0aWFsaXplIG9wdHMgZm9yIGxvb3AgKi9cbiAgaHVmZiA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgKi9cbiAgc3ltID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgc3ltYm9sICovXG4gIGxlbiA9IG1pbjsgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlIGxlbmd0aCAqL1xuICBuZXh0ID0gdGFibGVfaW5kZXg7ICAgICAgICAgICAgICAvKiBjdXJyZW50IHRhYmxlIHRvIGZpbGwgaW4gKi9cbiAgY3VyciA9IHJvb3Q7ICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgaW5kZXggYml0cyAqL1xuICBkcm9wID0gMDsgICAgICAgICAgICAgICAgICAgLyogY3VycmVudCBiaXRzIHRvIGRyb3AgZnJvbSBjb2RlIGZvciBpbmRleCAqL1xuICBsb3cgPSAtMTsgICAgICAgICAgICAgICAgICAgLyogdHJpZ2dlciBuZXcgc3ViLXRhYmxlIHdoZW4gbGVuID4gcm9vdCAqL1xuICB1c2VkID0gMSA8PCByb290OyAgICAgICAgICAvKiB1c2Ugcm9vdCB0YWJsZSBlbnRyaWVzICovXG4gIG1hc2sgPSB1c2VkIC0gMTsgICAgICAgICAgICAvKiBtYXNrIGZvciBjb21wYXJpbmcgbG93ICovXG5cbiAgLyogY2hlY2sgYXZhaWxhYmxlIHRhYmxlIHNwYWNlICovXG4gIGlmICgodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMpIHx8XG4gICAgKHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICAvKiBwcm9jZXNzIGFsbCBjb2RlcyBhbmQgbWFrZSB0YWJsZSBlbnRyaWVzICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBjcmVhdGUgdGFibGUgZW50cnkgKi9cbiAgICBoZXJlX2JpdHMgPSBsZW4gLSBkcm9wO1xuICAgIGlmICh3b3JrW3N5bV0gPCBlbmQpIHtcbiAgICAgIGhlcmVfb3AgPSAwO1xuICAgICAgaGVyZV92YWwgPSB3b3JrW3N5bV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHdvcmtbc3ltXSA+IGVuZCkge1xuICAgICAgaGVyZV9vcCA9IGV4dHJhW2V4dHJhX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICAgIGhlcmVfdmFsID0gYmFzZVtiYXNlX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBoZXJlX29wID0gMzIgKyA2NDsgICAgICAgICAvKiBlbmQgb2YgYmxvY2sgKi9cbiAgICAgIGhlcmVfdmFsID0gMDtcbiAgICB9XG5cbiAgICAvKiByZXBsaWNhdGUgZm9yIHRob3NlIGluZGljZXMgd2l0aCBsb3cgbGVuIGJpdHMgZXF1YWwgdG8gaHVmZiAqL1xuICAgIGluY3IgPSAxIDw8IChsZW4gLSBkcm9wKTtcbiAgICBmaWxsID0gMSA8PCBjdXJyO1xuICAgIG1pbiA9IGZpbGw7ICAgICAgICAgICAgICAgICAvKiBzYXZlIG9mZnNldCB0byBuZXh0IHRhYmxlICovXG4gICAgZG8ge1xuICAgICAgZmlsbCAtPSBpbmNyO1xuICAgICAgdGFibGVbbmV4dCArIChodWZmID4+IGRyb3ApICsgZmlsbF0gPSAoaGVyZV9iaXRzIDw8IDI0KSB8IChoZXJlX29wIDw8IDE2KSB8IGhlcmVfdmFsIHwwO1xuICAgIH0gd2hpbGUgKGZpbGwgIT09IDApO1xuXG4gICAgLyogYmFja3dhcmRzIGluY3JlbWVudCB0aGUgbGVuLWJpdCBjb2RlIGh1ZmYgKi9cbiAgICBpbmNyID0gMSA8PCAobGVuIC0gMSk7XG4gICAgd2hpbGUgKGh1ZmYgJiBpbmNyKSB7XG4gICAgICBpbmNyID4+PSAxO1xuICAgIH1cbiAgICBpZiAoaW5jciAhPT0gMCkge1xuICAgICAgaHVmZiAmPSBpbmNyIC0gMTtcbiAgICAgIGh1ZmYgKz0gaW5jcjtcbiAgICB9IGVsc2Uge1xuICAgICAgaHVmZiA9IDA7XG4gICAgfVxuXG4gICAgLyogZ28gdG8gbmV4dCBzeW1ib2wsIHVwZGF0ZSBjb3VudCwgbGVuICovXG4gICAgc3ltKys7XG4gICAgaWYgKC0tY291bnRbbGVuXSA9PT0gMCkge1xuICAgICAgaWYgKGxlbiA9PT0gbWF4KSB7IGJyZWFrOyB9XG4gICAgICBsZW4gPSBsZW5zW2xlbnNfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgIH1cblxuICAgIC8qIGNyZWF0ZSBuZXcgc3ViLXRhYmxlIGlmIG5lZWRlZCAqL1xuICAgIGlmIChsZW4gPiByb290ICYmIChodWZmICYgbWFzaykgIT09IGxvdykge1xuICAgICAgLyogaWYgZmlyc3QgdGltZSwgdHJhbnNpdGlvbiB0byBzdWItdGFibGVzICovXG4gICAgICBpZiAoZHJvcCA9PT0gMCkge1xuICAgICAgICBkcm9wID0gcm9vdDtcbiAgICAgIH1cblxuICAgICAgLyogaW5jcmVtZW50IHBhc3QgbGFzdCB0YWJsZSAqL1xuICAgICAgbmV4dCArPSBtaW47ICAgICAgICAgICAgLyogaGVyZSBtaW4gaXMgMSA8PCBjdXJyICovXG5cbiAgICAgIC8qIGRldGVybWluZSBsZW5ndGggb2YgbmV4dCB0YWJsZSAqL1xuICAgICAgY3VyciA9IGxlbiAtIGRyb3A7XG4gICAgICBsZWZ0ID0gMSA8PCBjdXJyO1xuICAgICAgd2hpbGUgKGN1cnIgKyBkcm9wIDwgbWF4KSB7XG4gICAgICAgIGxlZnQgLT0gY291bnRbY3VyciArIGRyb3BdO1xuICAgICAgICBpZiAobGVmdCA8PSAwKSB7IGJyZWFrOyB9XG4gICAgICAgIGN1cnIrKztcbiAgICAgICAgbGVmdCA8PD0gMTtcbiAgICAgIH1cblxuICAgICAgLyogY2hlY2sgZm9yIGVub3VnaCBzcGFjZSAqL1xuICAgICAgdXNlZCArPSAxIDw8IGN1cnI7XG4gICAgICBpZiAoKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TKSB8fFxuICAgICAgICAodHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIC8qIHBvaW50IGVudHJ5IGluIHJvb3QgdGFibGUgdG8gc3ViLXRhYmxlICovXG4gICAgICBsb3cgPSBodWZmICYgbWFzaztcbiAgICAgIC8qdGFibGUub3BbbG93XSA9IGN1cnI7XG4gICAgICB0YWJsZS5iaXRzW2xvd10gPSByb290O1xuICAgICAgdGFibGUudmFsW2xvd10gPSBuZXh0IC0gb3B0cy50YWJsZV9pbmRleDsqL1xuICAgICAgdGFibGVbbG93XSA9IChyb290IDw8IDI0KSB8IChjdXJyIDw8IDE2KSB8IChuZXh0IC0gdGFibGVfaW5kZXgpIHwwO1xuICAgIH1cbiAgfVxuXG4gIC8qIGZpbGwgaW4gcmVtYWluaW5nIHRhYmxlIGVudHJ5IGlmIGNvZGUgaXMgaW5jb21wbGV0ZSAoZ3VhcmFudGVlZCB0byBoYXZlXG4gICBhdCBtb3N0IG9uZSByZW1haW5pbmcgZW50cnksIHNpbmNlIGlmIHRoZSBjb2RlIGlzIGluY29tcGxldGUsIHRoZVxuICAgbWF4aW11bSBjb2RlIGxlbmd0aCB0aGF0IHdhcyBhbGxvd2VkIHRvIGdldCB0aGlzIGZhciBpcyBvbmUgYml0KSAqL1xuICBpZiAoaHVmZiAhPT0gMCkge1xuICAgIC8vdGFibGUub3BbbmV4dCArIGh1ZmZdID0gNjQ7ICAgICAgICAgICAgLyogaW52YWxpZCBjb2RlIG1hcmtlciAqL1xuICAgIC8vdGFibGUuYml0c1tuZXh0ICsgaHVmZl0gPSBsZW4gLSBkcm9wO1xuICAgIC8vdGFibGUudmFsW25leHQgKyBodWZmXSA9IDA7XG4gICAgdGFibGVbbmV4dCArIGh1ZmZdID0gKChsZW4gLSBkcm9wKSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwwO1xuICB9XG5cbiAgLyogc2V0IHJldHVybiBwYXJhbWV0ZXJzICovXG4gIC8vb3B0cy50YWJsZV9pbmRleCArPSB1c2VkO1xuICBvcHRzLmJpdHMgPSByb290O1xuICByZXR1cm4gMDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIDI6ICAgICAgJ25lZWQgZGljdGlvbmFyeScsICAgICAvKiBaX05FRURfRElDVCAgICAgICAyICAqL1xuICAxOiAgICAgICdzdHJlYW0gZW5kJywgICAgICAgICAgLyogWl9TVFJFQU1fRU5EICAgICAgMSAgKi9cbiAgMDogICAgICAnJywgICAgICAgICAgICAgICAgICAgIC8qIFpfT0sgICAgICAgICAgICAgIDAgICovXG4gICctMSc6ICAgJ2ZpbGUgZXJyb3InLCAgICAgICAgICAvKiBaX0VSUk5PICAgICAgICAgKC0xKSAqL1xuICAnLTInOiAgICdzdHJlYW0gZXJyb3InLCAgICAgICAgLyogWl9TVFJFQU1fRVJST1IgICgtMikgKi9cbiAgJy0zJzogICAnZGF0YSBlcnJvcicsICAgICAgICAgIC8qIFpfREFUQV9FUlJPUiAgICAoLTMpICovXG4gICctNCc6ICAgJ2luc3VmZmljaWVudCBtZW1vcnknLCAvKiBaX01FTV9FUlJPUiAgICAgKC00KSAqL1xuICAnLTUnOiAgICdidWZmZXIgZXJyb3InLCAgICAgICAgLyogWl9CVUZfRVJST1IgICAgICgtNSkgKi9cbiAgJy02JzogICAnaW5jb21wYXRpYmxlIHZlcnNpb24nIC8qIFpfVkVSU0lPTl9FUlJPUiAoLTYpICovXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbi8qIGVzbGludC1kaXNhYmxlIHNwYWNlLXVuYXJ5LW9wcyAqL1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLy92YXIgWl9GSUxURVJFRCAgICAgICAgICA9IDE7XG4vL3ZhciBaX0hVRkZNQU5fT05MWSAgICAgID0gMjtcbi8vdmFyIFpfUkxFICAgICAgICAgICAgICAgPSAzO1xudmFyIFpfRklYRUQgICAgICAgICAgICAgICA9IDQ7XG4vL3ZhciBaX0RFRkFVTFRfU1RSQVRFR1kgID0gMDtcblxuLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xudmFyIFpfQklOQVJZICAgICAgICAgICAgICA9IDA7XG52YXIgWl9URVhUICAgICAgICAgICAgICAgID0gMTtcbi8vdmFyIFpfQVNDSUkgICAgICAgICAgICAgPSAxOyAvLyA9IFpfVEVYVFxudmFyIFpfVU5LTk9XTiAgICAgICAgICAgICA9IDI7XG5cbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuZnVuY3Rpb24gemVybyhidWYpIHsgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7IHdoaWxlICgtLWxlbiA+PSAwKSB7IGJ1ZltsZW5dID0gMDsgfSB9XG5cbi8vIEZyb20genV0aWwuaFxuXG52YXIgU1RPUkVEX0JMT0NLID0gMDtcbnZhciBTVEFUSUNfVFJFRVMgPSAxO1xudmFyIERZTl9UUkVFUyAgICA9IDI7XG4vKiBUaGUgdGhyZWUga2luZHMgb2YgYmxvY2sgdHlwZSAqL1xuXG52YXIgTUlOX01BVENIICAgID0gMztcbnZhciBNQVhfTUFUQ0ggICAgPSAyNTg7XG4vKiBUaGUgbWluaW11bSBhbmQgbWF4aW11bSBtYXRjaCBsZW5ndGhzICovXG5cbi8vIEZyb20gZGVmbGF0ZS5oXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEludGVybmFsIGNvbXByZXNzaW9uIHN0YXRlLlxuICovXG5cbnZhciBMRU5HVEhfQ09ERVMgID0gMjk7XG4vKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGVzLCBub3QgY291bnRpbmcgdGhlIHNwZWNpYWwgRU5EX0JMT0NLIGNvZGUgKi9cblxudmFyIExJVEVSQUxTICAgICAgPSAyNTY7XG4vKiBudW1iZXIgb2YgbGl0ZXJhbCBieXRlcyAwLi4yNTUgKi9cblxudmFyIExfQ09ERVMgICAgICAgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7XG4vKiBudW1iZXIgb2YgTGl0ZXJhbCBvciBMZW5ndGggY29kZXMsIGluY2x1ZGluZyB0aGUgRU5EX0JMT0NLIGNvZGUgKi9cblxudmFyIERfQ09ERVMgICAgICAgPSAzMDtcbi8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlcyAqL1xuXG52YXIgQkxfQ09ERVMgICAgICA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG5cbnZhciBIRUFQX1NJWkUgICAgID0gMiAqIExfQ09ERVMgKyAxO1xuLyogbWF4aW11bSBoZWFwIHNpemUgKi9cblxudmFyIE1BWF9CSVRTICAgICAgPSAxNTtcbi8qIEFsbCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JJVFMgYml0cyAqL1xuXG52YXIgQnVmX3NpemUgICAgICA9IDE2O1xuLyogc2l6ZSBvZiBiaXQgYnVmZmVyIGluIGJpX2J1ZiAqL1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RhbnRzXG4gKi9cblxudmFyIE1BWF9CTF9CSVRTID0gNztcbi8qIEJpdCBsZW5ndGggY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CTF9CSVRTIGJpdHMgKi9cblxudmFyIEVORF9CTE9DSyAgID0gMjU2O1xuLyogZW5kIG9mIGJsb2NrIGxpdGVyYWwgY29kZSAqL1xuXG52YXIgUkVQXzNfNiAgICAgPSAxNjtcbi8qIHJlcGVhdCBwcmV2aW91cyBiaXQgbGVuZ3RoIDMtNiB0aW1lcyAoMiBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxudmFyIFJFUFpfM18xMCAgID0gMTc7XG4vKiByZXBlYXQgYSB6ZXJvIGxlbmd0aCAzLTEwIHRpbWVzICAoMyBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxudmFyIFJFUFpfMTFfMTM4ID0gMTg7XG4vKiByZXBlYXQgYSB6ZXJvIGxlbmd0aCAxMS0xMzggdGltZXMgICg3IGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBjb21tYS1zcGFjaW5nLGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xudmFyIGV4dHJhX2xiaXRzID0gICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGxlbmd0aCBjb2RlICovXG4gIFswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDBdO1xuXG52YXIgZXh0cmFfZGJpdHMgPSAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggZGlzdGFuY2UgY29kZSAqL1xuICBbMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCwxMCwxMSwxMSwxMiwxMiwxMywxM107XG5cbnZhciBleHRyYV9ibGJpdHMgPSAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBiaXQgbGVuZ3RoIGNvZGUgKi9cbiAgWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMiwzLDddO1xuXG52YXIgYmxfb3JkZXIgPVxuICBbMTYsMTcsMTgsMCw4LDcsOSw2LDEwLDUsMTEsNCwxMiwzLDEzLDIsMTQsMSwxNV07XG4vKiBlc2xpbnQtZW5hYmxlIGNvbW1hLXNwYWNpbmcsYXJyYXktYnJhY2tldC1zcGFjaW5nICovXG5cbi8qIFRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RoIGNvZGVzIGFyZSBzZW50IGluIG9yZGVyIG9mIGRlY3JlYXNpbmdcbiAqIHByb2JhYmlsaXR5LCB0byBhdm9pZCB0cmFuc21pdHRpbmcgdGhlIGxlbmd0aHMgZm9yIHVudXNlZCBiaXQgbGVuZ3RoIGNvZGVzLlxuICovXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogTG9jYWwgZGF0YS4gVGhlc2UgYXJlIGluaXRpYWxpemVkIG9ubHkgb25jZS5cbiAqL1xuXG4vLyBXZSBwcmUtZmlsbCBhcnJheXMgd2l0aCAwIHRvIGF2b2lkIHVuaW5pdGlhbGl6ZWQgZ2Fwc1xuXG52YXIgRElTVF9DT0RFX0xFTiA9IDUxMjsgLyogc2VlIGRlZmluaXRpb24gb2YgYXJyYXkgZGlzdF9jb2RlIGJlbG93ICovXG5cbi8vICEhISEgVXNlIGZsYXQgYXJyYXkgaW5zdGVhZCBvZiBzdHJ1Y3R1cmUsIEZyZXEgPSBpKjIsIExlbiA9IGkqMisxXG52YXIgc3RhdGljX2x0cmVlICA9IG5ldyBBcnJheSgoTF9DT0RFUyArIDIpICogMik7XG56ZXJvKHN0YXRpY19sdHJlZSk7XG4vKiBUaGUgc3RhdGljIGxpdGVyYWwgdHJlZS4gU2luY2UgdGhlIGJpdCBsZW5ndGhzIGFyZSBpbXBvc2VkLCB0aGVyZSBpcyBub1xuICogbmVlZCBmb3IgdGhlIExfQ09ERVMgZXh0cmEgY29kZXMgdXNlZCBkdXJpbmcgaGVhcCBjb25zdHJ1Y3Rpb24uIEhvd2V2ZXJcbiAqIFRoZSBjb2RlcyAyODYgYW5kIDI4NyBhcmUgbmVlZGVkIHRvIGJ1aWxkIGEgY2Fub25pY2FsIHRyZWUgKHNlZSBfdHJfaW5pdFxuICogYmVsb3cpLlxuICovXG5cbnZhciBzdGF0aWNfZHRyZWUgID0gbmV3IEFycmF5KERfQ09ERVMgKiAyKTtcbnplcm8oc3RhdGljX2R0cmVlKTtcbi8qIFRoZSBzdGF0aWMgZGlzdGFuY2UgdHJlZS4gKEFjdHVhbGx5IGEgdHJpdmlhbCB0cmVlIHNpbmNlIGFsbCBjb2RlcyB1c2VcbiAqIDUgYml0cy4pXG4gKi9cblxudmFyIF9kaXN0X2NvZGUgICAgPSBuZXcgQXJyYXkoRElTVF9DT0RFX0xFTik7XG56ZXJvKF9kaXN0X2NvZGUpO1xuLyogRGlzdGFuY2UgY29kZXMuIFRoZSBmaXJzdCAyNTYgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIGRpc3RhbmNlc1xuICogMyAuLiAyNTgsIHRoZSBsYXN0IDI1NiB2YWx1ZXMgY29ycmVzcG9uZCB0byB0aGUgdG9wIDggYml0cyBvZlxuICogdGhlIDE1IGJpdCBkaXN0YW5jZXMuXG4gKi9cblxudmFyIF9sZW5ndGhfY29kZSAgPSBuZXcgQXJyYXkoTUFYX01BVENIIC0gTUlOX01BVENIICsgMSk7XG56ZXJvKF9sZW5ndGhfY29kZSk7XG4vKiBsZW5ndGggY29kZSBmb3IgZWFjaCBub3JtYWxpemVkIG1hdGNoIGxlbmd0aCAoMCA9PSBNSU5fTUFUQ0gpICovXG5cbnZhciBiYXNlX2xlbmd0aCAgID0gbmV3IEFycmF5KExFTkdUSF9DT0RFUyk7XG56ZXJvKGJhc2VfbGVuZ3RoKTtcbi8qIEZpcnN0IG5vcm1hbGl6ZWQgbGVuZ3RoIGZvciBlYWNoIGNvZGUgKDAgPSBNSU5fTUFUQ0gpICovXG5cbnZhciBiYXNlX2Rpc3QgICAgID0gbmV3IEFycmF5KERfQ09ERVMpO1xuemVybyhiYXNlX2Rpc3QpO1xuLyogRmlyc3Qgbm9ybWFsaXplZCBkaXN0YW5jZSBmb3IgZWFjaCBjb2RlICgwID0gZGlzdGFuY2Ugb2YgMSkgKi9cblxuXG5mdW5jdGlvbiBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfdHJlZSwgZXh0cmFfYml0cywgZXh0cmFfYmFzZSwgZWxlbXMsIG1heF9sZW5ndGgpIHtcblxuICB0aGlzLnN0YXRpY190cmVlICA9IHN0YXRpY190cmVlOyAgLyogc3RhdGljIHRyZWUgb3IgTlVMTCAqL1xuICB0aGlzLmV4dHJhX2JpdHMgICA9IGV4dHJhX2JpdHM7ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBjb2RlIG9yIE5VTEwgKi9cbiAgdGhpcy5leHRyYV9iYXNlICAgPSBleHRyYV9iYXNlOyAgIC8qIGJhc2UgaW5kZXggZm9yIGV4dHJhX2JpdHMgKi9cbiAgdGhpcy5lbGVtcyAgICAgICAgPSBlbGVtczsgICAgICAgIC8qIG1heCBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHRyZWUgKi9cbiAgdGhpcy5tYXhfbGVuZ3RoICAgPSBtYXhfbGVuZ3RoOyAgIC8qIG1heCBiaXQgbGVuZ3RoIGZvciB0aGUgY29kZXMgKi9cblxuICAvLyBzaG93IGlmIGBzdGF0aWNfdHJlZWAgaGFzIGRhdGEgb3IgZHVtbXkgLSBuZWVkZWQgZm9yIG1vbm9tb3JwaGljIG9iamVjdHNcbiAgdGhpcy5oYXNfc3RyZWUgICAgPSBzdGF0aWNfdHJlZSAmJiBzdGF0aWNfdHJlZS5sZW5ndGg7XG59XG5cblxudmFyIHN0YXRpY19sX2Rlc2M7XG52YXIgc3RhdGljX2RfZGVzYztcbnZhciBzdGF0aWNfYmxfZGVzYztcblxuXG5mdW5jdGlvbiBUcmVlRGVzYyhkeW5fdHJlZSwgc3RhdF9kZXNjKSB7XG4gIHRoaXMuZHluX3RyZWUgPSBkeW5fdHJlZTsgICAgIC8qIHRoZSBkeW5hbWljIHRyZWUgKi9cbiAgdGhpcy5tYXhfY29kZSA9IDA7ICAgICAgICAgICAgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIHRoaXMuc3RhdF9kZXNjID0gc3RhdF9kZXNjOyAgIC8qIHRoZSBjb3JyZXNwb25kaW5nIHN0YXRpYyB0cmVlICovXG59XG5cblxuXG5mdW5jdGlvbiBkX2NvZGUoZGlzdCkge1xuICByZXR1cm4gZGlzdCA8IDI1NiA/IF9kaXN0X2NvZGVbZGlzdF0gOiBfZGlzdF9jb2RlWzI1NiArIChkaXN0ID4+PiA3KV07XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBPdXRwdXQgYSBzaG9ydCBMU0IgZmlyc3Qgb24gdGhlIHN0cmVhbS5cbiAqIElOIGFzc2VydGlvbjogdGhlcmUgaXMgZW5vdWdoIHJvb20gaW4gcGVuZGluZ0J1Zi5cbiAqL1xuZnVuY3Rpb24gcHV0X3Nob3J0KHMsIHcpIHtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh3KSAmIDB4ZmYpKTtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh1c2gpKHcpID4+IDgpKTtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAodykgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3ID4+PiA4KSAmIDB4ZmY7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgdmFsdWUgb24gYSBnaXZlbiBudW1iZXIgb2YgYml0cy5cbiAqIElOIGFzc2VydGlvbjogbGVuZ3RoIDw9IDE2IGFuZCB2YWx1ZSBmaXRzIGluIGxlbmd0aCBiaXRzLlxuICovXG5mdW5jdGlvbiBzZW5kX2JpdHMocywgdmFsdWUsIGxlbmd0aCkge1xuICBpZiAocy5iaV92YWxpZCA+IChCdWZfc2l6ZSAtIGxlbmd0aCkpIHtcbiAgICBzLmJpX2J1ZiB8PSAodmFsdWUgPDwgcy5iaV92YWxpZCkgJiAweGZmZmY7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgICBzLmJpX2J1ZiA9IHZhbHVlID4+IChCdWZfc2l6ZSAtIHMuYmlfdmFsaWQpO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoIC0gQnVmX3NpemU7XG4gIH0gZWxzZSB7XG4gICAgcy5iaV9idWYgfD0gKHZhbHVlIDw8IHMuYmlfdmFsaWQpICYgMHhmZmZmO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc2VuZF9jb2RlKHMsIGMsIHRyZWUpIHtcbiAgc2VuZF9iaXRzKHMsIHRyZWVbYyAqIDJdLyouQ29kZSovLCB0cmVlW2MgKiAyICsgMV0vKi5MZW4qLyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZXZlcnNlIHRoZSBmaXJzdCBsZW4gYml0cyBvZiBhIGNvZGUsIHVzaW5nIHN0cmFpZ2h0Zm9yd2FyZCBjb2RlIChhIGZhc3RlclxuICogbWV0aG9kIHdvdWxkIHVzZSBhIHRhYmxlKVxuICogSU4gYXNzZXJ0aW9uOiAxIDw9IGxlbiA8PSAxNVxuICovXG5mdW5jdGlvbiBiaV9yZXZlcnNlKGNvZGUsIGxlbikge1xuICB2YXIgcmVzID0gMDtcbiAgZG8ge1xuICAgIHJlcyB8PSBjb2RlICYgMTtcbiAgICBjb2RlID4+Pj0gMTtcbiAgICByZXMgPDw9IDE7XG4gIH0gd2hpbGUgKC0tbGVuID4gMCk7XG4gIHJldHVybiByZXMgPj4+IDE7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCB0aGUgYml0IGJ1ZmZlciwga2VlcGluZyBhdCBtb3N0IDcgYml0cyBpbiBpdC5cbiAqL1xuZnVuY3Rpb24gYmlfZmx1c2gocykge1xuICBpZiAocy5iaV92YWxpZCA9PT0gMTYpIHtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICAgIHMuYmlfYnVmID0gMDtcbiAgICBzLmJpX3ZhbGlkID0gMDtcblxuICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPj0gOCkge1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWYgJiAweGZmO1xuICAgIHMuYmlfYnVmID4+PSA4O1xuICAgIHMuYmlfdmFsaWQgLT0gODtcbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHV0ZSB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RocyBmb3IgYSB0cmVlIGFuZCB1cGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGhcbiAqIGZvciB0aGUgY3VycmVudCBibG9jay5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkcyBmcmVxIGFuZCBkYWQgYXJlIHNldCwgaGVhcFtoZWFwX21heF0gYW5kXG4gKiAgICBhYm92ZSBhcmUgdGhlIHRyZWUgbm9kZXMgc29ydGVkIGJ5IGluY3JlYXNpbmcgZnJlcXVlbmN5LlxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZCBsZW4gaXMgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGgsIHRoZVxuICogICAgIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBmcmVxdWVuY2llcyBmb3IgZWFjaCBiaXQgbGVuZ3RoLlxuICogICAgIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpc1xuICogICAgIG5vdCBudWxsLlxuICovXG5mdW5jdGlvbiBnZW5fYml0bGVuKHMsIGRlc2MpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdHJlZV9kZXNjICpkZXNjOyAgICAvKiB0aGUgdHJlZSBkZXNjcmlwdG9yICovXG57XG4gIHZhciB0cmVlICAgICAgICAgICAgPSBkZXNjLmR5bl90cmVlO1xuICB2YXIgbWF4X2NvZGUgICAgICAgID0gZGVzYy5tYXhfY29kZTtcbiAgdmFyIHN0cmVlICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlO1xuICB2YXIgaGFzX3N0cmVlICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlO1xuICB2YXIgZXh0cmEgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYml0cztcbiAgdmFyIGJhc2UgICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2Jhc2U7XG4gIHZhciBtYXhfbGVuZ3RoICAgICAgPSBkZXNjLnN0YXRfZGVzYy5tYXhfbGVuZ3RoO1xuICB2YXIgaDsgICAgICAgICAgICAgIC8qIGhlYXAgaW5kZXggKi9cbiAgdmFyIG4sIG07ICAgICAgICAgICAvKiBpdGVyYXRlIG92ZXIgdGhlIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAvKiBiaXQgbGVuZ3RoICovXG4gIHZhciB4Yml0czsgICAgICAgICAgLyogZXh0cmEgYml0cyAqL1xuICB2YXIgZjsgICAgICAgICAgICAgIC8qIGZyZXF1ZW5jeSAqL1xuICB2YXIgb3ZlcmZsb3cgPSAwOyAgIC8qIG51bWJlciBvZiBlbGVtZW50cyB3aXRoIGJpdCBsZW5ndGggdG9vIGxhcmdlICovXG5cbiAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgcy5ibF9jb3VudFtiaXRzXSA9IDA7XG4gIH1cblxuICAvKiBJbiBhIGZpcnN0IHBhc3MsIGNvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgKHdoaWNoIG1heVxuICAgKiBvdmVyZmxvdyBpbiB0aGUgY2FzZSBvZiB0aGUgYml0IGxlbmd0aCB0cmVlKS5cbiAgICovXG4gIHRyZWVbcy5oZWFwW3MuaGVhcF9tYXhdICogMiArIDFdLyouTGVuKi8gPSAwOyAvKiByb290IG9mIHRoZSBoZWFwICovXG5cbiAgZm9yIChoID0gcy5oZWFwX21heCArIDE7IGggPCBIRUFQX1NJWkU7IGgrKykge1xuICAgIG4gPSBzLmhlYXBbaF07XG4gICAgYml0cyA9IHRyZWVbdHJlZVtuICogMiArIDFdLyouRGFkKi8gKiAyICsgMV0vKi5MZW4qLyArIDE7XG4gICAgaWYgKGJpdHMgPiBtYXhfbGVuZ3RoKSB7XG4gICAgICBiaXRzID0gbWF4X2xlbmd0aDtcbiAgICAgIG92ZXJmbG93Kys7XG4gICAgfVxuICAgIHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gYml0cztcbiAgICAvKiBXZSBvdmVyd3JpdGUgdHJlZVtuXS5EYWQgd2hpY2ggaXMgbm8gbG9uZ2VyIG5lZWRlZCAqL1xuXG4gICAgaWYgKG4gPiBtYXhfY29kZSkgeyBjb250aW51ZTsgfSAvKiBub3QgYSBsZWFmIG5vZGUgKi9cblxuICAgIHMuYmxfY291bnRbYml0c10rKztcbiAgICB4Yml0cyA9IDA7XG4gICAgaWYgKG4gPj0gYmFzZSkge1xuICAgICAgeGJpdHMgPSBleHRyYVtuIC0gYmFzZV07XG4gICAgfVxuICAgIGYgPSB0cmVlW24gKiAyXS8qLkZyZXEqLztcbiAgICBzLm9wdF9sZW4gKz0gZiAqIChiaXRzICsgeGJpdHMpO1xuICAgIGlmIChoYXNfc3RyZWUpIHtcbiAgICAgIHMuc3RhdGljX2xlbiArPSBmICogKHN0cmVlW24gKiAyICsgMV0vKi5MZW4qLyArIHhiaXRzKTtcbiAgICB9XG4gIH1cbiAgaWYgKG92ZXJmbG93ID09PSAwKSB7IHJldHVybjsgfVxuXG4gIC8vIFRyYWNlKChzdGRlcnIsXCJcXG5iaXQgbGVuZ3RoIG92ZXJmbG93XFxuXCIpKTtcbiAgLyogVGhpcyBoYXBwZW5zIGZvciBleGFtcGxlIG9uIG9iajIgYW5kIHBpYyBvZiB0aGUgQ2FsZ2FyeSBjb3JwdXMgKi9cblxuICAvKiBGaW5kIHRoZSBmaXJzdCBiaXQgbGVuZ3RoIHdoaWNoIGNvdWxkIGluY3JlYXNlOiAqL1xuICBkbyB7XG4gICAgYml0cyA9IG1heF9sZW5ndGggLSAxO1xuICAgIHdoaWxlIChzLmJsX2NvdW50W2JpdHNdID09PSAwKSB7IGJpdHMtLTsgfVxuICAgIHMuYmxfY291bnRbYml0c10tLTsgICAgICAvKiBtb3ZlIG9uZSBsZWFmIGRvd24gdGhlIHRyZWUgKi9cbiAgICBzLmJsX2NvdW50W2JpdHMgKyAxXSArPSAyOyAvKiBtb3ZlIG9uZSBvdmVyZmxvdyBpdGVtIGFzIGl0cyBicm90aGVyICovXG4gICAgcy5ibF9jb3VudFttYXhfbGVuZ3RoXS0tO1xuICAgIC8qIFRoZSBicm90aGVyIG9mIHRoZSBvdmVyZmxvdyBpdGVtIGFsc28gbW92ZXMgb25lIHN0ZXAgdXAsXG4gICAgICogYnV0IHRoaXMgZG9lcyBub3QgYWZmZWN0IGJsX2NvdW50W21heF9sZW5ndGhdXG4gICAgICovXG4gICAgb3ZlcmZsb3cgLT0gMjtcbiAgfSB3aGlsZSAob3ZlcmZsb3cgPiAwKTtcblxuICAvKiBOb3cgcmVjb21wdXRlIGFsbCBiaXQgbGVuZ3Rocywgc2Nhbm5pbmcgaW4gaW5jcmVhc2luZyBmcmVxdWVuY3kuXG4gICAqIGggaXMgc3RpbGwgZXF1YWwgdG8gSEVBUF9TSVpFLiAoSXQgaXMgc2ltcGxlciB0byByZWNvbnN0cnVjdCBhbGxcbiAgICogbGVuZ3RocyBpbnN0ZWFkIG9mIGZpeGluZyBvbmx5IHRoZSB3cm9uZyBvbmVzLiBUaGlzIGlkZWEgaXMgdGFrZW5cbiAgICogZnJvbSAnYXInIHdyaXR0ZW4gYnkgSGFydWhpa28gT2t1bXVyYS4pXG4gICAqL1xuICBmb3IgKGJpdHMgPSBtYXhfbGVuZ3RoOyBiaXRzICE9PSAwOyBiaXRzLS0pIHtcbiAgICBuID0gcy5ibF9jb3VudFtiaXRzXTtcbiAgICB3aGlsZSAobiAhPT0gMCkge1xuICAgICAgbSA9IHMuaGVhcFstLWhdO1xuICAgICAgaWYgKG0gPiBtYXhfY29kZSkgeyBjb250aW51ZTsgfVxuICAgICAgaWYgKHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovICE9PSBiaXRzKSB7XG4gICAgICAgIC8vIFRyYWNlKChzdGRlcnIsXCJjb2RlICVkIGJpdHMgJWQtPiVkXFxuXCIsIG0sIHRyZWVbbV0uTGVuLCBiaXRzKSk7XG4gICAgICAgIHMub3B0X2xlbiArPSAoYml0cyAtIHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovKSAqIHRyZWVbbSAqIDJdLyouRnJlcSovO1xuICAgICAgICB0cmVlW20gKiAyICsgMV0vKi5MZW4qLyA9IGJpdHM7XG4gICAgICB9XG4gICAgICBuLS07XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBHZW5lcmF0ZSB0aGUgY29kZXMgZm9yIGEgZ2l2ZW4gdHJlZSBhbmQgYml0IGNvdW50cyAod2hpY2ggbmVlZCBub3QgYmVcbiAqIG9wdGltYWwpLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgYXJyYXkgYmxfY291bnQgY29udGFpbnMgdGhlIGJpdCBsZW5ndGggc3RhdGlzdGljcyBmb3JcbiAqIHRoZSBnaXZlbiB0cmVlIGFuZCB0aGUgZmllbGQgbGVuIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuXG4gKiBPVVQgYXNzZXJ0aW9uOiB0aGUgZmllbGQgY29kZSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzIG9mIG5vblxuICogICAgIHplcm8gY29kZSBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIGdlbl9jb2Rlcyh0cmVlLCBtYXhfY29kZSwgYmxfY291bnQpXG4vLyAgICBjdF9kYXRhICp0cmVlOyAgICAgICAgICAgICAvKiB0aGUgdHJlZSB0byBkZWNvcmF0ZSAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAgICAgICAgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4vLyAgICB1c2hmICpibF9jb3VudDsgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoICovXG57XG4gIHZhciBuZXh0X2NvZGUgPSBuZXcgQXJyYXkoTUFYX0JJVFMgKyAxKTsgLyogbmV4dCBjb2RlIHZhbHVlIGZvciBlYWNoIGJpdCBsZW5ndGggKi9cbiAgdmFyIGNvZGUgPSAwOyAgICAgICAgICAgICAgLyogcnVubmluZyBjb2RlIHZhbHVlICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgICAgICAgIC8qIGJpdCBpbmRleCAqL1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBjb2RlIGluZGV4ICovXG5cbiAgLyogVGhlIGRpc3RyaWJ1dGlvbiBjb3VudHMgYXJlIGZpcnN0IHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGNvZGUgdmFsdWVzXG4gICAqIHdpdGhvdXQgYml0IHJldmVyc2FsLlxuICAgKi9cbiAgZm9yIChiaXRzID0gMTsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgbmV4dF9jb2RlW2JpdHNdID0gY29kZSA9IChjb2RlICsgYmxfY291bnRbYml0cyAtIDFdKSA8PCAxO1xuICB9XG4gIC8qIENoZWNrIHRoYXQgdGhlIGJpdCBjb3VudHMgaW4gYmxfY291bnQgYXJlIGNvbnNpc3RlbnQuIFRoZSBsYXN0IGNvZGVcbiAgICogbXVzdCBiZSBhbGwgb25lcy5cbiAgICovXG4gIC8vQXNzZXJ0IChjb2RlICsgYmxfY291bnRbTUFYX0JJVFNdLTEgPT0gKDE8PE1BWF9CSVRTKS0xLFxuICAvLyAgICAgICAgXCJpbmNvbnNpc3RlbnQgYml0IGNvdW50c1wiKTtcbiAgLy9UcmFjZXYoKHN0ZGVycixcIlxcbmdlbl9jb2RlczogbWF4X2NvZGUgJWQgXCIsIG1heF9jb2RlKSk7XG5cbiAgZm9yIChuID0gMDsgIG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIHZhciBsZW4gPSB0cmVlW24gKiAyICsgMV0vKi5MZW4qLztcbiAgICBpZiAobGVuID09PSAwKSB7IGNvbnRpbnVlOyB9XG4gICAgLyogTm93IHJldmVyc2UgdGhlIGJpdHMgKi9cbiAgICB0cmVlW24gKiAyXS8qLkNvZGUqLyA9IGJpX3JldmVyc2UobmV4dF9jb2RlW2xlbl0rKywgbGVuKTtcblxuICAgIC8vVHJhY2Vjdih0cmVlICE9IHN0YXRpY19sdHJlZSwgKHN0ZGVycixcIlxcbm4gJTNkICVjIGwgJTJkIGMgJTR4ICgleCkgXCIsXG4gICAgLy8gICAgIG4sIChpc2dyYXBoKG4pID8gbiA6ICcgJyksIGxlbiwgdHJlZVtuXS5Db2RlLCBuZXh0X2NvZGVbbGVuXS0xKSk7XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIHZhcmlvdXMgJ2NvbnN0YW50JyB0YWJsZXMuXG4gKi9cbmZ1bmN0aW9uIHRyX3N0YXRpY19pbml0KCkge1xuICB2YXIgbjsgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgYml0czsgICAgIC8qIGJpdCBjb3VudGVyICovXG4gIHZhciBsZW5ndGg7ICAgLyogbGVuZ3RoIHZhbHVlICovXG4gIHZhciBjb2RlOyAgICAgLyogY29kZSB2YWx1ZSAqL1xuICB2YXIgZGlzdDsgICAgIC8qIGRpc3RhbmNlIGluZGV4ICovXG4gIHZhciBibF9jb3VudCA9IG5ldyBBcnJheShNQVhfQklUUyArIDEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvLyBkbyBjaGVjayBpbiBfdHJfaW5pdCgpXG4gIC8vaWYgKHN0YXRpY19pbml0X2RvbmUpIHJldHVybjtcblxuICAvKiBGb3Igc29tZSBlbWJlZGRlZCB0YXJnZXRzLCBnbG9iYWwgdmFyaWFibGVzIGFyZSBub3QgaW5pdGlhbGl6ZWQ6ICovXG4vKiNpZmRlZiBOT19JTklUX0dMT0JBTF9QT0lOVEVSU1xuICBzdGF0aWNfbF9kZXNjLnN0YXRpY190cmVlID0gc3RhdGljX2x0cmVlO1xuICBzdGF0aWNfbF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9sYml0cztcbiAgc3RhdGljX2RfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19kdHJlZTtcbiAgc3RhdGljX2RfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfZGJpdHM7XG4gIHN0YXRpY19ibF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9ibGJpdHM7XG4jZW5kaWYqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIG1hcHBpbmcgbGVuZ3RoICgwLi4yNTUpIC0+IGxlbmd0aCBjb2RlICgwLi4yOCkgKi9cbiAgbGVuZ3RoID0gMDtcbiAgZm9yIChjb2RlID0gMDsgY29kZSA8IExFTkdUSF9DT0RFUyAtIDE7IGNvZGUrKykge1xuICAgIGJhc2VfbGVuZ3RoW2NvZGVdID0gbGVuZ3RoO1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCBleHRyYV9sYml0c1tjb2RlXSk7IG4rKykge1xuICAgICAgX2xlbmd0aF9jb2RlW2xlbmd0aCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChsZW5ndGggPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiBsZW5ndGggIT0gMjU2XCIpO1xuICAvKiBOb3RlIHRoYXQgdGhlIGxlbmd0aCAyNTUgKG1hdGNoIGxlbmd0aCAyNTgpIGNhbiBiZSByZXByZXNlbnRlZFxuICAgKiBpbiB0d28gZGlmZmVyZW50IHdheXM6IGNvZGUgMjg0ICsgNSBiaXRzIG9yIGNvZGUgMjg1LCBzbyB3ZVxuICAgKiBvdmVyd3JpdGUgbGVuZ3RoX2NvZGVbMjU1XSB0byB1c2UgdGhlIGJlc3QgZW5jb2Rpbmc6XG4gICAqL1xuICBfbGVuZ3RoX2NvZGVbbGVuZ3RoIC0gMV0gPSBjb2RlO1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIG1hcHBpbmcgZGlzdCAoMC4uMzJLKSAtPiBkaXN0IGNvZGUgKDAuLjI5KSAqL1xuICBkaXN0ID0gMDtcbiAgZm9yIChjb2RlID0gMDsgY29kZSA8IDE2OyBjb2RlKyspIHtcbiAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0O1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCBleHRyYV9kYml0c1tjb2RlXSk7IG4rKykge1xuICAgICAgX2Rpc3RfY29kZVtkaXN0KytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGRpc3QgPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiBkaXN0ICE9IDI1NlwiKTtcbiAgZGlzdCA+Pj0gNzsgLyogZnJvbSBub3cgb24sIGFsbCBkaXN0YW5jZXMgYXJlIGRpdmlkZWQgYnkgMTI4ICovXG4gIGZvciAoOyBjb2RlIDwgRF9DT0RFUzsgY29kZSsrKSB7XG4gICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdCA8PCA3O1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCAoZXh0cmFfZGJpdHNbY29kZV0gLSA3KSk7IG4rKykge1xuICAgICAgX2Rpc3RfY29kZVsyNTYgKyBkaXN0KytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGRpc3QgPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiAyNTYrZGlzdCAhPSA1MTJcIik7XG5cbiAgLyogQ29uc3RydWN0IHRoZSBjb2RlcyBvZiB0aGUgc3RhdGljIGxpdGVyYWwgdHJlZSAqL1xuICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBibF9jb3VudFtiaXRzXSA9IDA7XG4gIH1cblxuICBuID0gMDtcbiAgd2hpbGUgKG4gPD0gMTQzKSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjU1KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDk7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzldKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjc5KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDc7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzddKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjg3KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgLyogQ29kZXMgMjg2IGFuZCAyODcgZG8gbm90IGV4aXN0LCBidXQgd2UgbXVzdCBpbmNsdWRlIHRoZW0gaW4gdGhlXG4gICAqIHRyZWUgY29uc3RydWN0aW9uIHRvIGdldCBhIGNhbm9uaWNhbCBIdWZmbWFuIHRyZWUgKGxvbmdlc3QgY29kZVxuICAgKiBhbGwgb25lcylcbiAgICovXG4gIGdlbl9jb2RlcyhzdGF0aWNfbHRyZWUsIExfQ09ERVMgKyAxLCBibF9jb3VudCk7XG5cbiAgLyogVGhlIHN0YXRpYyBkaXN0YW5jZSB0cmVlIGlzIHRyaXZpYWw6ICovXG4gIGZvciAobiA9IDA7IG4gPCBEX0NPREVTOyBuKyspIHtcbiAgICBzdGF0aWNfZHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gNTtcbiAgICBzdGF0aWNfZHRyZWVbbiAqIDJdLyouQ29kZSovID0gYmlfcmV2ZXJzZShuLCA1KTtcbiAgfVxuXG4gIC8vIE5vdyBkYXRhIHJlYWR5IGFuZCB3ZSBjYW4gaW5pdCBzdGF0aWMgdHJlZXNcbiAgc3RhdGljX2xfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfbHRyZWUsIGV4dHJhX2xiaXRzLCBMSVRFUkFMUyArIDEsIExfQ09ERVMsIE1BWF9CSVRTKTtcbiAgc3RhdGljX2RfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfZHRyZWUsIGV4dHJhX2RiaXRzLCAwLCAgICAgICAgICBEX0NPREVTLCBNQVhfQklUUyk7XG4gIHN0YXRpY19ibF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKG5ldyBBcnJheSgwKSwgZXh0cmFfYmxiaXRzLCAwLCAgICAgICAgIEJMX0NPREVTLCBNQVhfQkxfQklUUyk7XG5cbiAgLy9zdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgYSBuZXcgYmxvY2suXG4gKi9cbmZ1bmN0aW9uIGluaXRfYmxvY2socykge1xuICB2YXIgbjsgLyogaXRlcmF0ZXMgb3ZlciB0cmVlIGVsZW1lbnRzICovXG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgdHJlZXMuICovXG4gIGZvciAobiA9IDA7IG4gPCBMX0NPREVTOyAgbisrKSB7IHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVM7ICBuKyspIHsgcy5keW5fZHRyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuICBmb3IgKG4gPSAwOyBuIDwgQkxfQ09ERVM7IG4rKykgeyBzLmJsX3RyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuXG4gIHMuZHluX2x0cmVlW0VORF9CTE9DSyAqIDJdLyouRnJlcSovID0gMTtcbiAgcy5vcHRfbGVuID0gcy5zdGF0aWNfbGVuID0gMDtcbiAgcy5sYXN0X2xpdCA9IHMubWF0Y2hlcyA9IDA7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCB0aGUgYml0IGJ1ZmZlciBhbmQgYWxpZ24gdGhlIG91dHB1dCBvbiBhIGJ5dGUgYm91bmRhcnlcbiAqL1xuZnVuY3Rpb24gYmlfd2luZHVwKHMpXG57XG4gIGlmIChzLmJpX3ZhbGlkID4gOCkge1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+IDApIHtcbiAgICAvL3B1dF9ieXRlKHMsIChCeXRlKXMtPmJpX2J1Zik7XG4gICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZjtcbiAgfVxuICBzLmJpX2J1ZiA9IDA7XG4gIHMuYmlfdmFsaWQgPSAwO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgYSBzdG9yZWQgYmxvY2ssIHN0b3JpbmcgZmlyc3QgdGhlIGxlbmd0aCBhbmQgaXRzXG4gKiBvbmUncyBjb21wbGVtZW50IGlmIHJlcXVlc3RlZC5cbiAqL1xuZnVuY3Rpb24gY29weV9ibG9jayhzLCBidWYsIGxlbiwgaGVhZGVyKVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICAgICpidWY7ICAgIC8qIHRoZSBpbnB1dCBkYXRhICovXG4vL3Vuc2lnbmVkIGxlbjsgICAgIC8qIGl0cyBsZW5ndGggKi9cbi8vaW50ICAgICAgaGVhZGVyOyAgLyogdHJ1ZSBpZiBibG9jayBoZWFkZXIgbXVzdCBiZSB3cml0dGVuICovXG57XG4gIGJpX3dpbmR1cChzKTsgICAgICAgIC8qIGFsaWduIG9uIGJ5dGUgYm91bmRhcnkgKi9cblxuICBpZiAoaGVhZGVyKSB7XG4gICAgcHV0X3Nob3J0KHMsIGxlbik7XG4gICAgcHV0X3Nob3J0KHMsIH5sZW4pO1xuICB9XG4vLyAgd2hpbGUgKGxlbi0tKSB7XG4vLyAgICBwdXRfYnl0ZShzLCAqYnVmKyspO1xuLy8gIH1cbiAgdXRpbHMuYXJyYXlTZXQocy5wZW5kaW5nX2J1Ziwgcy53aW5kb3csIGJ1ZiwgbGVuLCBzLnBlbmRpbmcpO1xuICBzLnBlbmRpbmcgKz0gbGVuO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXBhcmVzIHRvIHN1YnRyZWVzLCB1c2luZyB0aGUgdHJlZSBkZXB0aCBhcyB0aWUgYnJlYWtlciB3aGVuXG4gKiB0aGUgc3VidHJlZXMgaGF2ZSBlcXVhbCBmcmVxdWVuY3kuIFRoaXMgbWluaW1pemVzIHRoZSB3b3JzdCBjYXNlIGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gc21hbGxlcih0cmVlLCBuLCBtLCBkZXB0aCkge1xuICB2YXIgX24yID0gbiAqIDI7XG4gIHZhciBfbTIgPSBtICogMjtcbiAgcmV0dXJuICh0cmVlW19uMl0vKi5GcmVxKi8gPCB0cmVlW19tMl0vKi5GcmVxKi8gfHxcbiAgICAgICAgICh0cmVlW19uMl0vKi5GcmVxKi8gPT09IHRyZWVbX20yXS8qLkZyZXEqLyAmJiBkZXB0aFtuXSA8PSBkZXB0aFttXSkpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlc3RvcmUgdGhlIGhlYXAgcHJvcGVydHkgYnkgbW92aW5nIGRvd24gdGhlIHRyZWUgc3RhcnRpbmcgYXQgbm9kZSBrLFxuICogZXhjaGFuZ2luZyBhIG5vZGUgd2l0aCB0aGUgc21hbGxlc3Qgb2YgaXRzIHR3byBzb25zIGlmIG5lY2Vzc2FyeSwgc3RvcHBpbmdcbiAqIHdoZW4gdGhlIGhlYXAgcHJvcGVydHkgaXMgcmUtZXN0YWJsaXNoZWQgKGVhY2ggZmF0aGVyIHNtYWxsZXIgdGhhbiBpdHNcbiAqIHR3byBzb25zKS5cbiAqL1xuZnVuY3Rpb24gcHFkb3duaGVhcChzLCB0cmVlLCBrKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAvKiB0aGUgdHJlZSB0byByZXN0b3JlICovXG4vLyAgICBpbnQgazsgICAgICAgICAgICAgICAvKiBub2RlIHRvIG1vdmUgZG93biAqL1xue1xuICB2YXIgdiA9IHMuaGVhcFtrXTtcbiAgdmFyIGogPSBrIDw8IDE7ICAvKiBsZWZ0IHNvbiBvZiBrICovXG4gIHdoaWxlIChqIDw9IHMuaGVhcF9sZW4pIHtcbiAgICAvKiBTZXQgaiB0byB0aGUgc21hbGxlc3Qgb2YgdGhlIHR3byBzb25zOiAqL1xuICAgIGlmIChqIDwgcy5oZWFwX2xlbiAmJlxuICAgICAgc21hbGxlcih0cmVlLCBzLmhlYXBbaiArIDFdLCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7XG4gICAgICBqKys7XG4gICAgfVxuICAgIC8qIEV4aXQgaWYgdiBpcyBzbWFsbGVyIHRoYW4gYm90aCBzb25zICovXG4gICAgaWYgKHNtYWxsZXIodHJlZSwgdiwgcy5oZWFwW2pdLCBzLmRlcHRoKSkgeyBicmVhazsgfVxuXG4gICAgLyogRXhjaGFuZ2UgdiB3aXRoIHRoZSBzbWFsbGVzdCBzb24gKi9cbiAgICBzLmhlYXBba10gPSBzLmhlYXBbal07XG4gICAgayA9IGo7XG5cbiAgICAvKiBBbmQgY29udGludWUgZG93biB0aGUgdHJlZSwgc2V0dGluZyBqIHRvIHRoZSBsZWZ0IHNvbiBvZiBrICovXG4gICAgaiA8PD0gMTtcbiAgfVxuICBzLmhlYXBba10gPSB2O1xufVxuXG5cbi8vIGlubGluZWQgbWFudWFsbHlcbi8vIHZhciBTTUFMTEVTVCA9IDE7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCB0aGUgYmxvY2sgZGF0YSBjb21wcmVzc2VkIHVzaW5nIHRoZSBnaXZlbiBIdWZmbWFuIHRyZWVzXG4gKi9cbmZ1bmN0aW9uIGNvbXByZXNzX2Jsb2NrKHMsIGx0cmVlLCBkdHJlZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjb25zdCBjdF9kYXRhICpsdHJlZTsgLyogbGl0ZXJhbCB0cmVlICovXG4vLyAgICBjb25zdCBjdF9kYXRhICpkdHJlZTsgLyogZGlzdGFuY2UgdHJlZSAqL1xue1xuICB2YXIgZGlzdDsgICAgICAgICAgIC8qIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nICovXG4gIHZhciBsYzsgICAgICAgICAgICAgLyogbWF0Y2ggbGVuZ3RoIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0ID09IDApICovXG4gIHZhciBseCA9IDA7ICAgICAgICAgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuICB2YXIgY29kZTsgICAgICAgICAgIC8qIHRoZSBjb2RlIHRvIHNlbmQgKi9cbiAgdmFyIGV4dHJhOyAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyB0byBzZW5kICovXG5cbiAgaWYgKHMubGFzdF9saXQgIT09IDApIHtcbiAgICBkbyB7XG4gICAgICBkaXN0ID0gKHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4ICogMl0gPDwgOCkgfCAocy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyICsgMV0pO1xuICAgICAgbGMgPSBzLnBlbmRpbmdfYnVmW3MubF9idWYgKyBseF07XG4gICAgICBseCsrO1xuXG4gICAgICBpZiAoZGlzdCA9PT0gMCkge1xuICAgICAgICBzZW5kX2NvZGUocywgbGMsIGx0cmVlKTsgLyogc2VuZCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgICAvL1RyYWNlY3YoaXNncmFwaChsYyksIChzdGRlcnIsXCIgJyVjJyBcIiwgbGMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0ggKi9cbiAgICAgICAgY29kZSA9IF9sZW5ndGhfY29kZVtsY107XG4gICAgICAgIHNlbmRfY29kZShzLCBjb2RlICsgTElURVJBTFMgKyAxLCBsdHJlZSk7IC8qIHNlbmQgdGhlIGxlbmd0aCBjb2RlICovXG4gICAgICAgIGV4dHJhID0gZXh0cmFfbGJpdHNbY29kZV07XG4gICAgICAgIGlmIChleHRyYSAhPT0gMCkge1xuICAgICAgICAgIGxjIC09IGJhc2VfbGVuZ3RoW2NvZGVdO1xuICAgICAgICAgIHNlbmRfYml0cyhzLCBsYywgZXh0cmEpOyAgICAgICAvKiBzZW5kIHRoZSBleHRyYSBsZW5ndGggYml0cyAqL1xuICAgICAgICB9XG4gICAgICAgIGRpc3QtLTsgLyogZGlzdCBpcyBub3cgdGhlIG1hdGNoIGRpc3RhbmNlIC0gMSAqL1xuICAgICAgICBjb2RlID0gZF9jb2RlKGRpc3QpO1xuICAgICAgICAvL0Fzc2VydCAoY29kZSA8IERfQ09ERVMsIFwiYmFkIGRfY29kZVwiKTtcblxuICAgICAgICBzZW5kX2NvZGUocywgY29kZSwgZHRyZWUpOyAgICAgICAvKiBzZW5kIHRoZSBkaXN0YW5jZSBjb2RlICovXG4gICAgICAgIGV4dHJhID0gZXh0cmFfZGJpdHNbY29kZV07XG4gICAgICAgIGlmIChleHRyYSAhPT0gMCkge1xuICAgICAgICAgIGRpc3QgLT0gYmFzZV9kaXN0W2NvZGVdO1xuICAgICAgICAgIHNlbmRfYml0cyhzLCBkaXN0LCBleHRyYSk7ICAgLyogc2VuZCB0aGUgZXh0cmEgZGlzdGFuY2UgYml0cyAqL1xuICAgICAgICB9XG4gICAgICB9IC8qIGxpdGVyYWwgb3IgbWF0Y2ggcGFpciA/ICovXG5cbiAgICAgIC8qIENoZWNrIHRoYXQgdGhlIG92ZXJsYXkgYmV0d2VlbiBwZW5kaW5nX2J1ZiBhbmQgZF9idWYrbF9idWYgaXMgb2s6ICovXG4gICAgICAvL0Fzc2VydCgodUludCkocy0+cGVuZGluZykgPCBzLT5saXRfYnVmc2l6ZSArIDIqbHgsXG4gICAgICAvLyAgICAgICBcInBlbmRpbmdCdWYgb3ZlcmZsb3dcIik7XG5cbiAgICB9IHdoaWxlIChseCA8IHMubGFzdF9saXQpO1xuICB9XG5cbiAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgbHRyZWUpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IG9uZSBIdWZmbWFuIHRyZWUgYW5kIGFzc2lnbnMgdGhlIGNvZGUgYml0IHN0cmluZ3MgYW5kIGxlbmd0aHMuXG4gKiBVcGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGggZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGQgZnJlcSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZHMgbGVuIGFuZCBjb2RlIGFyZSBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aFxuICogICAgIGFuZCBjb3JyZXNwb25kaW5nIGNvZGUuIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzXG4gKiAgICAgYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzIG5vdCBudWxsLiBUaGUgZmllbGQgbWF4X2NvZGUgaXMgc2V0LlxuICovXG5mdW5jdGlvbiBidWlsZF90cmVlKHMsIGRlc2MpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdHJlZV9kZXNjICpkZXNjOyAvKiB0aGUgdHJlZSBkZXNjcmlwdG9yICovXG57XG4gIHZhciB0cmVlICAgICA9IGRlc2MuZHluX3RyZWU7XG4gIHZhciBzdHJlZSAgICA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlO1xuICB2YXIgaGFzX3N0cmVlID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlO1xuICB2YXIgZWxlbXMgICAgPSBkZXNjLnN0YXRfZGVzYy5lbGVtcztcbiAgdmFyIG4sIG07ICAgICAgICAgIC8qIGl0ZXJhdGUgb3ZlciBoZWFwIGVsZW1lbnRzICovXG4gIHZhciBtYXhfY29kZSA9IC0xOyAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbiAgdmFyIG5vZGU7ICAgICAgICAgIC8qIG5ldyBub2RlIGJlaW5nIGNyZWF0ZWQgKi9cblxuICAvKiBDb25zdHJ1Y3QgdGhlIGluaXRpYWwgaGVhcCwgd2l0aCBsZWFzdCBmcmVxdWVudCBlbGVtZW50IGluXG4gICAqIGhlYXBbU01BTExFU1RdLiBUaGUgc29ucyBvZiBoZWFwW25dIGFyZSBoZWFwWzIqbl0gYW5kIGhlYXBbMipuKzFdLlxuICAgKiBoZWFwWzBdIGlzIG5vdCB1c2VkLlxuICAgKi9cbiAgcy5oZWFwX2xlbiA9IDA7XG4gIHMuaGVhcF9tYXggPSBIRUFQX1NJWkU7XG5cbiAgZm9yIChuID0gMDsgbiA8IGVsZW1zOyBuKyspIHtcbiAgICBpZiAodHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICAgIHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gbWF4X2NvZGUgPSBuO1xuICAgICAgcy5kZXB0aFtuXSA9IDA7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8qIFRoZSBwa3ppcCBmb3JtYXQgcmVxdWlyZXMgdGhhdCBhdCBsZWFzdCBvbmUgZGlzdGFuY2UgY29kZSBleGlzdHMsXG4gICAqIGFuZCB0aGF0IGF0IGxlYXN0IG9uZSBiaXQgc2hvdWxkIGJlIHNlbnQgZXZlbiBpZiB0aGVyZSBpcyBvbmx5IG9uZVxuICAgKiBwb3NzaWJsZSBjb2RlLiBTbyB0byBhdm9pZCBzcGVjaWFsIGNoZWNrcyBsYXRlciBvbiB3ZSBmb3JjZSBhdCBsZWFzdFxuICAgKiB0d28gY29kZXMgb2Ygbm9uIHplcm8gZnJlcXVlbmN5LlxuICAgKi9cbiAgd2hpbGUgKHMuaGVhcF9sZW4gPCAyKSB7XG4gICAgbm9kZSA9IHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gKG1heF9jb2RlIDwgMiA/ICsrbWF4X2NvZGUgOiAwKTtcbiAgICB0cmVlW25vZGUgKiAyXS8qLkZyZXEqLyA9IDE7XG4gICAgcy5kZXB0aFtub2RlXSA9IDA7XG4gICAgcy5vcHRfbGVuLS07XG5cbiAgICBpZiAoaGFzX3N0cmVlKSB7XG4gICAgICBzLnN0YXRpY19sZW4gLT0gc3RyZWVbbm9kZSAqIDIgKyAxXS8qLkxlbiovO1xuICAgIH1cbiAgICAvKiBub2RlIGlzIDAgb3IgMSBzbyBpdCBkb2VzIG5vdCBoYXZlIGV4dHJhIGJpdHMgKi9cbiAgfVxuICBkZXNjLm1heF9jb2RlID0gbWF4X2NvZGU7XG5cbiAgLyogVGhlIGVsZW1lbnRzIGhlYXBbaGVhcF9sZW4vMisxIC4uIGhlYXBfbGVuXSBhcmUgbGVhdmVzIG9mIHRoZSB0cmVlLFxuICAgKiBlc3RhYmxpc2ggc3ViLWhlYXBzIG9mIGluY3JlYXNpbmcgbGVuZ3RoczpcbiAgICovXG4gIGZvciAobiA9IChzLmhlYXBfbGVuID4+IDEvKmludCAvMiovKTsgbiA+PSAxOyBuLS0pIHsgcHFkb3duaGVhcChzLCB0cmVlLCBuKTsgfVxuXG4gIC8qIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGJ5IHJlcGVhdGVkbHkgY29tYmluaW5nIHRoZSBsZWFzdCB0d29cbiAgICogZnJlcXVlbnQgbm9kZXMuXG4gICAqL1xuICBub2RlID0gZWxlbXM7ICAgICAgICAgICAgICAvKiBuZXh0IGludGVybmFsIG5vZGUgb2YgdGhlIHRyZWUgKi9cbiAgZG8ge1xuICAgIC8vcHFyZW1vdmUocywgdHJlZSwgbik7ICAvKiBuID0gbm9kZSBvZiBsZWFzdCBmcmVxdWVuY3kgKi9cbiAgICAvKioqIHBxcmVtb3ZlICoqKi9cbiAgICBuID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dO1xuICAgIHMuaGVhcFsxLypTTUFMTEVTVCovXSA9IHMuaGVhcFtzLmhlYXBfbGVuLS1dO1xuICAgIHBxZG93bmhlYXAocywgdHJlZSwgMS8qU01BTExFU1QqLyk7XG4gICAgLyoqKi9cblxuICAgIG0gPSBzLmhlYXBbMS8qU01BTExFU1QqL107IC8qIG0gPSBub2RlIG9mIG5leHQgbGVhc3QgZnJlcXVlbmN5ICovXG5cbiAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG47IC8qIGtlZXAgdGhlIG5vZGVzIHNvcnRlZCBieSBmcmVxdWVuY3kgKi9cbiAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG07XG5cbiAgICAvKiBDcmVhdGUgYSBuZXcgbm9kZSBmYXRoZXIgb2YgbiBhbmQgbSAqL1xuICAgIHRyZWVbbm9kZSAqIDJdLyouRnJlcSovID0gdHJlZVtuICogMl0vKi5GcmVxKi8gKyB0cmVlW20gKiAyXS8qLkZyZXEqLztcbiAgICBzLmRlcHRoW25vZGVdID0gKHMuZGVwdGhbbl0gPj0gcy5kZXB0aFttXSA/IHMuZGVwdGhbbl0gOiBzLmRlcHRoW21dKSArIDE7XG4gICAgdHJlZVtuICogMiArIDFdLyouRGFkKi8gPSB0cmVlW20gKiAyICsgMV0vKi5EYWQqLyA9IG5vZGU7XG5cbiAgICAvKiBhbmQgaW5zZXJ0IHRoZSBuZXcgbm9kZSBpbiB0aGUgaGVhcCAqL1xuICAgIHMuaGVhcFsxLypTTUFMTEVTVCovXSA9IG5vZGUrKztcbiAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEvKlNNQUxMRVNUKi8pO1xuXG4gIH0gd2hpbGUgKHMuaGVhcF9sZW4gPj0gMik7XG5cbiAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBzLmhlYXBbMS8qU01BTExFU1QqL107XG5cbiAgLyogQXQgdGhpcyBwb2ludCwgdGhlIGZpZWxkcyBmcmVxIGFuZCBkYWQgYXJlIHNldC4gV2UgY2FuIG5vd1xuICAgKiBnZW5lcmF0ZSB0aGUgYml0IGxlbmd0aHMuXG4gICAqL1xuICBnZW5fYml0bGVuKHMsIGRlc2MpO1xuXG4gIC8qIFRoZSBmaWVsZCBsZW4gaXMgbm93IHNldCwgd2UgY2FuIGdlbmVyYXRlIHRoZSBiaXQgY29kZXMgKi9cbiAgZ2VuX2NvZGVzKHRyZWUsIG1heF9jb2RlLCBzLmJsX2NvdW50KTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNjYW4gYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgdG8gZGV0ZXJtaW5lIHRoZSBmcmVxdWVuY2llcyBvZiB0aGUgY29kZXNcbiAqIGluIHRoZSBiaXQgbGVuZ3RoIHRyZWUuXG4gKi9cbmZ1bmN0aW9uIHNjYW5fdHJlZShzLCB0cmVlLCBtYXhfY29kZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgIC8qIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWQgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgLyogYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5ICovXG57XG4gIHZhciBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIHByZXZsZW4gPSAtMTsgICAgICAgICAgLyogbGFzdCBlbWl0dGVkIGxlbmd0aCAqL1xuICB2YXIgY3VybGVuOyAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBjb2RlICovXG5cbiAgdmFyIG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV0vKi5MZW4qLzsgLyogbGVuZ3RoIG9mIG5leHQgY29kZSAqL1xuXG4gIHZhciBjb3VudCA9IDA7ICAgICAgICAgICAgIC8qIHJlcGVhdCBjb3VudCBvZiB0aGUgY3VycmVudCBjb2RlICovXG4gIHZhciBtYXhfY291bnQgPSA3OyAgICAgICAgIC8qIG1heCByZXBlYXQgY291bnQgKi9cbiAgdmFyIG1pbl9jb3VudCA9IDQ7ICAgICAgICAgLyogbWluIHJlcGVhdCBjb3VudCAqL1xuXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cbiAgdHJlZVsobWF4X2NvZGUgKyAxKSAqIDIgKyAxXS8qLkxlbiovID0gMHhmZmZmOyAvKiBndWFyZCAqL1xuXG4gIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGN1cmxlbiA9IG5leHRsZW47XG4gICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXS8qLkxlbiovO1xuXG4gICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBjb250aW51ZTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcbiAgICAgIHMuYmxfdHJlZVtjdXJsZW4gKiAyXS8qLkZyZXEqLyArPSBjb3VudDtcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XG5cbiAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHsgcy5ibF90cmVlW2N1cmxlbiAqIDJdLyouRnJlcSovKys7IH1cbiAgICAgIHMuYmxfdHJlZVtSRVBfM182ICogMl0vKi5GcmVxKi8rKztcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcbiAgICAgIHMuYmxfdHJlZVtSRVBaXzNfMTAgKiAyXS8qLkZyZXEqLysrO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHMuYmxfdHJlZVtSRVBaXzExXzEzOCAqIDJdLyouRnJlcSovKys7XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZsZW4gPSBjdXJsZW47XG5cbiAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgICAgbWF4X2NvdW50ID0gMTM4O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBtYXhfY291bnQgPSA2O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhfY291bnQgPSA3O1xuICAgICAgbWluX2NvdW50ID0gNDtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgaW4gY29tcHJlc3NlZCBmb3JtLCB1c2luZyB0aGUgY29kZXMgaW5cbiAqIGJsX3RyZWUuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfdHJlZShzLCB0cmVlLCBtYXhfY29kZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAvKiB0aGUgdHJlZSB0byBiZSBzY2FubmVkICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgICAgIC8qIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xue1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIGFsbCB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBwcmV2bGVuID0gLTE7ICAgICAgICAgIC8qIGxhc3QgZW1pdHRlZCBsZW5ndGggKi9cbiAgdmFyIGN1cmxlbjsgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgY29kZSAqL1xuXG4gIHZhciBuZXh0bGVuID0gdHJlZVswICogMiArIDFdLyouTGVuKi87IC8qIGxlbmd0aCBvZiBuZXh0IGNvZGUgKi9cblxuICB2YXIgY291bnQgPSAwOyAgICAgICAgICAgICAvKiByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZSAqL1xuICB2YXIgbWF4X2NvdW50ID0gNzsgICAgICAgICAvKiBtYXggcmVwZWF0IGNvdW50ICovXG4gIHZhciBtaW5fY291bnQgPSA0OyAgICAgICAgIC8qIG1pbiByZXBlYXQgY291bnQgKi9cblxuICAvKiB0cmVlW21heF9jb2RlKzFdLkxlbiA9IC0xOyAqLyAgLyogZ3VhcmQgYWxyZWFkeSBzZXQgKi9cbiAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgbWluX2NvdW50ID0gMztcbiAgfVxuXG4gIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGN1cmxlbiA9IG5leHRsZW47XG4gICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXS8qLkxlbiovO1xuXG4gICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBjb250aW51ZTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcbiAgICAgIGRvIHsgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTsgfSB3aGlsZSAoLS1jb3VudCAhPT0gMCk7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xuICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikge1xuICAgICAgICBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpO1xuICAgICAgICBjb3VudC0tO1xuICAgICAgfVxuICAgICAgLy9Bc3NlcnQoY291bnQgPj0gMyAmJiBjb3VudCA8PSA2LCBcIiAzXzY/XCIpO1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUF8zXzYsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAyKTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBaXzNfMTAsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAzKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzZW5kX2NvZGUocywgUkVQWl8xMV8xMzgsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAxMSwgNyk7XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZsZW4gPSBjdXJsZW47XG4gICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgbWF4X2NvdW50ID0gNjtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4X2NvdW50ID0gNztcbiAgICAgIG1pbl9jb3VudCA9IDQ7XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdHJ1Y3QgdGhlIEh1ZmZtYW4gdHJlZSBmb3IgdGhlIGJpdCBsZW5ndGhzIGFuZCByZXR1cm4gdGhlIGluZGV4IGluXG4gKiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRfYmxfdHJlZShzKSB7XG4gIHZhciBtYXhfYmxpbmRleDsgIC8qIGluZGV4IG9mIGxhc3QgYml0IGxlbmd0aCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXEgKi9cblxuICAvKiBEZXRlcm1pbmUgdGhlIGJpdCBsZW5ndGggZnJlcXVlbmNpZXMgZm9yIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzICovXG4gIHNjYW5fdHJlZShzLCBzLmR5bl9sdHJlZSwgcy5sX2Rlc2MubWF4X2NvZGUpO1xuICBzY2FuX3RyZWUocywgcy5keW5fZHRyZWUsIHMuZF9kZXNjLm1heF9jb2RlKTtcblxuICAvKiBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlOiAqL1xuICBidWlsZF90cmVlKHMsIHMuYmxfZGVzYyk7XG4gIC8qIG9wdF9sZW4gbm93IGluY2x1ZGVzIHRoZSBsZW5ndGggb2YgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLCBleGNlcHRcbiAgICogdGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGhzIGNvZGVzIGFuZCB0aGUgNSs1KzQgYml0cyBmb3IgdGhlIGNvdW50cy5cbiAgICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgYml0IGxlbmd0aCBjb2RlcyB0byBzZW5kLiBUaGUgcGt6aXAgZm9ybWF0XG4gICAqIHJlcXVpcmVzIHRoYXQgYXQgbGVhc3QgNCBiaXQgbGVuZ3RoIGNvZGVzIGJlIHNlbnQuIChhcHBub3RlLnR4dCBzYXlzXG4gICAqIDMgYnV0IHRoZSBhY3R1YWwgdmFsdWUgdXNlZCBpcyA0LilcbiAgICovXG4gIGZvciAobWF4X2JsaW5kZXggPSBCTF9DT0RFUyAtIDE7IG1heF9ibGluZGV4ID49IDM7IG1heF9ibGluZGV4LS0pIHtcbiAgICBpZiAocy5ibF90cmVlW2JsX29yZGVyW21heF9ibGluZGV4XSAqIDIgKyAxXS8qLkxlbiovICE9PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgLyogVXBkYXRlIG9wdF9sZW4gdG8gaW5jbHVkZSB0aGUgYml0IGxlbmd0aCB0cmVlIGFuZCBjb3VudHMgKi9cbiAgcy5vcHRfbGVuICs9IDMgKiAobWF4X2JsaW5kZXggKyAxKSArIDUgKyA1ICsgNDtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5keW4gdHJlZXM6IGR5biAlbGQsIHN0YXQgJWxkXCIsXG4gIC8vICAgICAgICBzLT5vcHRfbGVuLCBzLT5zdGF0aWNfbGVuKSk7XG5cbiAgcmV0dXJuIG1heF9ibGluZGV4O1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCB0aGUgaGVhZGVyIGZvciBhIGJsb2NrIHVzaW5nIGR5bmFtaWMgSHVmZm1hbiB0cmVlczogdGhlIGNvdW50cywgdGhlXG4gKiBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RoIGNvZGVzLCB0aGUgbGl0ZXJhbCB0cmVlIGFuZCB0aGUgZGlzdGFuY2UgdHJlZS5cbiAqIElOIGFzc2VydGlvbjogbGNvZGVzID49IDI1NywgZGNvZGVzID49IDEsIGJsY29kZXMgPj0gNC5cbiAqL1xuZnVuY3Rpb24gc2VuZF9hbGxfdHJlZXMocywgbGNvZGVzLCBkY29kZXMsIGJsY29kZXMpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgaW50IGxjb2RlcywgZGNvZGVzLCBibGNvZGVzOyAvKiBudW1iZXIgb2YgY29kZXMgZm9yIGVhY2ggdHJlZSAqL1xue1xuICB2YXIgcmFuazsgICAgICAgICAgICAgICAgICAgIC8qIGluZGV4IGluIGJsX29yZGVyICovXG5cbiAgLy9Bc3NlcnQgKGxjb2RlcyA+PSAyNTcgJiYgZGNvZGVzID49IDEgJiYgYmxjb2RlcyA+PSA0LCBcIm5vdCBlbm91Z2ggY29kZXNcIik7XG4gIC8vQXNzZXJ0IChsY29kZXMgPD0gTF9DT0RFUyAmJiBkY29kZXMgPD0gRF9DT0RFUyAmJiBibGNvZGVzIDw9IEJMX0NPREVTLFxuICAvLyAgICAgICAgXCJ0b28gbWFueSBjb2Rlc1wiKTtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCBjb3VudHM6IFwiKSk7XG4gIHNlbmRfYml0cyhzLCBsY29kZXMgLSAyNTcsIDUpOyAvKiBub3QgKzI1NSBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHQgKi9cbiAgc2VuZF9iaXRzKHMsIGRjb2RlcyAtIDEsICAgNSk7XG4gIHNlbmRfYml0cyhzLCBibGNvZGVzIC0gNCwgIDQpOyAvKiBub3QgLTMgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0ICovXG4gIGZvciAocmFuayA9IDA7IHJhbmsgPCBibGNvZGVzOyByYW5rKyspIHtcbiAgICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIGNvZGUgJTJkIFwiLCBibF9vcmRlcltyYW5rXSkpO1xuICAgIHNlbmRfYml0cyhzLCBzLmJsX3RyZWVbYmxfb3JkZXJbcmFua10gKiAyICsgMV0vKi5MZW4qLywgMyk7XG4gIH1cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcblxuICBzZW5kX3RyZWUocywgcy5keW5fbHRyZWUsIGxjb2RlcyAtIDEpOyAvKiBsaXRlcmFsIHRyZWUgKi9cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5saXQgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG5cbiAgc2VuZF90cmVlKHMsIHMuZHluX2R0cmVlLCBkY29kZXMgLSAxKTsgLyogZGlzdGFuY2UgdHJlZSAqL1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmRpc3QgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDaGVjayBpZiB0aGUgZGF0YSB0eXBlIGlzIFRFWFQgb3IgQklOQVJZLCB1c2luZyB0aGUgZm9sbG93aW5nIGFsZ29yaXRobTpcbiAqIC0gVEVYVCBpZiB0aGUgdHdvIGNvbmRpdGlvbnMgYmVsb3cgYXJlIHNhdGlzZmllZDpcbiAqICAgIGEpIFRoZXJlIGFyZSBubyBub24tcG9ydGFibGUgY29udHJvbCBjaGFyYWN0ZXJzIGJlbG9uZ2luZyB0byB0aGVcbiAqICAgICAgIFwiYmxhY2sgbGlzdFwiICgwLi42LCAxNC4uMjUsIDI4Li4zMSkuXG4gKiAgICBiKSBUaGVyZSBpcyBhdCBsZWFzdCBvbmUgcHJpbnRhYmxlIGNoYXJhY3RlciBiZWxvbmdpbmcgdG8gdGhlXG4gKiAgICAgICBcIndoaXRlIGxpc3RcIiAoOSB7VEFCfSwgMTAge0xGfSwgMTMge0NSfSwgMzIuLjI1NSkuXG4gKiAtIEJJTkFSWSBvdGhlcndpc2UuXG4gKiAtIFRoZSBmb2xsb3dpbmcgcGFydGlhbGx5LXBvcnRhYmxlIGNvbnRyb2wgY2hhcmFjdGVycyBmb3JtIGFcbiAqICAgXCJncmF5IGxpc3RcIiB0aGF0IGlzIGlnbm9yZWQgaW4gdGhpcyBkZXRlY3Rpb24gYWxnb3JpdGhtOlxuICogICAoNyB7QkVMfSwgOCB7QlN9LCAxMSB7VlR9LCAxMiB7RkZ9LCAyNiB7U1VCfSwgMjcge0VTQ30pLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGRzIEZyZXEgb2YgZHluX2x0cmVlIGFyZSBzZXQuXG4gKi9cbmZ1bmN0aW9uIGRldGVjdF9kYXRhX3R5cGUocykge1xuICAvKiBibGFja19tYXNrIGlzIHRoZSBiaXQgbWFzayBvZiBibGFjay1saXN0ZWQgYnl0ZXNcbiAgICogc2V0IGJpdHMgMC4uNiwgMTQuLjI1LCBhbmQgMjguLjMxXG4gICAqIDB4ZjNmZmMwN2YgPSBiaW5hcnkgMTExMTAwMTExMTExMTExMTExMDAwMDAwMDExMTExMTFcbiAgICovXG4gIHZhciBibGFja19tYXNrID0gMHhmM2ZmYzA3ZjtcbiAgdmFyIG47XG5cbiAgLyogQ2hlY2sgZm9yIG5vbi10ZXh0dWFsIChcImJsYWNrLWxpc3RlZFwiKSBieXRlcy4gKi9cbiAgZm9yIChuID0gMDsgbiA8PSAzMTsgbisrLCBibGFja19tYXNrID4+Pj0gMSkge1xuICAgIGlmICgoYmxhY2tfbWFzayAmIDEpICYmIChzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApKSB7XG4gICAgICByZXR1cm4gWl9CSU5BUlk7XG4gICAgfVxuICB9XG5cbiAgLyogQ2hlY2sgZm9yIHRleHR1YWwgKFwid2hpdGUtbGlzdGVkXCIpIGJ5dGVzLiAqL1xuICBpZiAocy5keW5fbHRyZWVbOSAqIDJdLyouRnJlcSovICE9PSAwIHx8IHMuZHluX2x0cmVlWzEwICogMl0vKi5GcmVxKi8gIT09IDAgfHxcbiAgICAgIHMuZHluX2x0cmVlWzEzICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICByZXR1cm4gWl9URVhUO1xuICB9XG4gIGZvciAobiA9IDMyOyBuIDwgTElURVJBTFM7IG4rKykge1xuICAgIGlmIChzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICAgIHJldHVybiBaX1RFWFQ7XG4gICAgfVxuICB9XG5cbiAgLyogVGhlcmUgYXJlIG5vIFwiYmxhY2stbGlzdGVkXCIgb3IgXCJ3aGl0ZS1saXN0ZWRcIiBieXRlczpcbiAgICogdGhpcyBzdHJlYW0gZWl0aGVyIGlzIGVtcHR5IG9yIGhhcyB0b2xlcmF0ZWQgKFwiZ3JheS1saXN0ZWRcIikgYnl0ZXMgb25seS5cbiAgICovXG4gIHJldHVybiBaX0JJTkFSWTtcbn1cblxuXG52YXIgc3RhdGljX2luaXRfZG9uZSA9IGZhbHNlO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIHRyZWUgZGF0YSBzdHJ1Y3R1cmVzIGZvciBhIG5ldyB6bGliIHN0cmVhbS5cbiAqL1xuZnVuY3Rpb24gX3RyX2luaXQocylcbntcblxuICBpZiAoIXN0YXRpY19pbml0X2RvbmUpIHtcbiAgICB0cl9zdGF0aWNfaW5pdCgpO1xuICAgIHN0YXRpY19pbml0X2RvbmUgPSB0cnVlO1xuICB9XG5cbiAgcy5sX2Rlc2MgID0gbmV3IFRyZWVEZXNjKHMuZHluX2x0cmVlLCBzdGF0aWNfbF9kZXNjKTtcbiAgcy5kX2Rlc2MgID0gbmV3IFRyZWVEZXNjKHMuZHluX2R0cmVlLCBzdGF0aWNfZF9kZXNjKTtcbiAgcy5ibF9kZXNjID0gbmV3IFRyZWVEZXNjKHMuYmxfdHJlZSwgc3RhdGljX2JsX2Rlc2MpO1xuXG4gIHMuYmlfYnVmID0gMDtcbiAgcy5iaV92YWxpZCA9IDA7XG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgZmlyc3QgYmxvY2sgb2YgdGhlIGZpcnN0IGZpbGU6ICovXG4gIGluaXRfYmxvY2socyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgc3RvcmVkIGJsb2NrXG4gKi9cbmZ1bmN0aW9uIF90cl9zdG9yZWRfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICpidWY7ICAgICAgIC8qIGlucHV0IGJsb2NrICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG57XG4gIHNlbmRfYml0cyhzLCAoU1RPUkVEX0JMT0NLIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpOyAgICAvKiBzZW5kIGJsb2NrIHR5cGUgKi9cbiAgY29weV9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIHRydWUpOyAvKiB3aXRoIGhlYWRlciAqL1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBvbmUgZW1wdHkgc3RhdGljIGJsb2NrIHRvIGdpdmUgZW5vdWdoIGxvb2thaGVhZCBmb3IgaW5mbGF0ZS5cbiAqIFRoaXMgdGFrZXMgMTAgYml0cywgb2Ygd2hpY2ggNyBtYXkgcmVtYWluIGluIHRoZSBiaXQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBfdHJfYWxpZ24ocykge1xuICBzZW5kX2JpdHMocywgU1RBVElDX1RSRUVTIDw8IDEsIDMpO1xuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBzdGF0aWNfbHRyZWUpO1xuICBiaV9mbHVzaChzKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZyBmb3IgdGhlIGN1cnJlbnQgYmxvY2s6IGR5bmFtaWMgdHJlZXMsIHN0YXRpY1xuICogdHJlZXMgb3Igc3RvcmUsIGFuZCBvdXRwdXQgdGhlIGVuY29kZWQgYmxvY2sgdG8gdGhlIHppcCBmaWxlLlxuICovXG5mdW5jdGlvbiBfdHJfZmx1c2hfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICpidWY7ICAgICAgIC8qIGlucHV0IGJsb2NrLCBvciBOVUxMIGlmIHRvbyBvbGQgKi9cbi8vdWxnIHN0b3JlZF9sZW47ICAgLyogbGVuZ3RoIG9mIGlucHV0IGJsb2NrICovXG4vL2ludCBsYXN0OyAgICAgICAgIC8qIG9uZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGUgKi9cbntcbiAgdmFyIG9wdF9sZW5iLCBzdGF0aWNfbGVuYjsgIC8qIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gaW4gYnl0ZXMgKi9cbiAgdmFyIG1heF9ibGluZGV4ID0gMDsgICAgICAgIC8qIGluZGV4IG9mIGxhc3QgYml0IGxlbmd0aCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXEgKi9cblxuICAvKiBCdWlsZCB0aGUgSHVmZm1hbiB0cmVlcyB1bmxlc3MgYSBzdG9yZWQgYmxvY2sgaXMgZm9yY2VkICovXG4gIGlmIChzLmxldmVsID4gMCkge1xuXG4gICAgLyogQ2hlY2sgaWYgdGhlIGZpbGUgaXMgYmluYXJ5IG9yIHRleHQgKi9cbiAgICBpZiAocy5zdHJtLmRhdGFfdHlwZSA9PT0gWl9VTktOT1dOKSB7XG4gICAgICBzLnN0cm0uZGF0YV90eXBlID0gZGV0ZWN0X2RhdGFfdHlwZShzKTtcbiAgICB9XG5cbiAgICAvKiBDb25zdHJ1Y3QgdGhlIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzICovXG4gICAgYnVpbGRfdHJlZShzLCBzLmxfZGVzYyk7XG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxubGl0IGRhdGE6IGR5biAlbGQsIHN0YXQgJWxkXCIsIHMtPm9wdF9sZW4sXG4gICAgLy8gICAgICAgIHMtPnN0YXRpY19sZW4pKTtcblxuICAgIGJ1aWxkX3RyZWUocywgcy5kX2Rlc2MpO1xuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbmRpc3QgZGF0YTogZHluICVsZCwgc3RhdCAlbGRcIiwgcy0+b3B0X2xlbixcbiAgICAvLyAgICAgICAgcy0+c3RhdGljX2xlbikpO1xuICAgIC8qIEF0IHRoaXMgcG9pbnQsIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gYXJlIHRoZSB0b3RhbCBiaXQgbGVuZ3RocyBvZlxuICAgICAqIHRoZSBjb21wcmVzc2VkIGJsb2NrIGRhdGEsIGV4Y2x1ZGluZyB0aGUgdHJlZSByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG5cbiAgICAvKiBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlIGZvciB0aGUgYWJvdmUgdHdvIHRyZWVzLCBhbmQgZ2V0IHRoZSBpbmRleFxuICAgICAqIGluIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuICAgICAqL1xuICAgIG1heF9ibGluZGV4ID0gYnVpbGRfYmxfdHJlZShzKTtcblxuICAgIC8qIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZy4gQ29tcHV0ZSB0aGUgYmxvY2sgbGVuZ3RocyBpbiBieXRlcy4gKi9cbiAgICBvcHRfbGVuYiA9IChzLm9wdF9sZW4gKyAzICsgNykgPj4+IDM7XG4gICAgc3RhdGljX2xlbmIgPSAocy5zdGF0aWNfbGVuICsgMyArIDcpID4+PiAzO1xuXG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxub3B0ICVsdSglbHUpIHN0YXQgJWx1KCVsdSkgc3RvcmVkICVsdSBsaXQgJXUgXCIsXG4gICAgLy8gICAgICAgIG9wdF9sZW5iLCBzLT5vcHRfbGVuLCBzdGF0aWNfbGVuYiwgcy0+c3RhdGljX2xlbiwgc3RvcmVkX2xlbixcbiAgICAvLyAgICAgICAgcy0+bGFzdF9saXQpKTtcblxuICAgIGlmIChzdGF0aWNfbGVuYiA8PSBvcHRfbGVuYikgeyBvcHRfbGVuYiA9IHN0YXRpY19sZW5iOyB9XG5cbiAgfSBlbHNlIHtcbiAgICAvLyBBc3NlcnQoYnVmICE9IChjaGFyKikwLCBcImxvc3QgYnVmXCIpO1xuICAgIG9wdF9sZW5iID0gc3RhdGljX2xlbmIgPSBzdG9yZWRfbGVuICsgNTsgLyogZm9yY2UgYSBzdG9yZWQgYmxvY2sgKi9cbiAgfVxuXG4gIGlmICgoc3RvcmVkX2xlbiArIDQgPD0gb3B0X2xlbmIpICYmIChidWYgIT09IC0xKSkge1xuICAgIC8qIDQ6IHR3byB3b3JkcyBmb3IgdGhlIGxlbmd0aHMgKi9cblxuICAgIC8qIFRoZSB0ZXN0IGJ1ZiAhPSBOVUxMIGlzIG9ubHkgbmVjZXNzYXJ5IGlmIExJVF9CVUZTSVpFID4gV1NJWkUuXG4gICAgICogT3RoZXJ3aXNlIHdlIGNhbid0IGhhdmUgcHJvY2Vzc2VkIG1vcmUgdGhhbiBXU0laRSBpbnB1dCBieXRlcyBzaW5jZVxuICAgICAqIHRoZSBsYXN0IGJsb2NrIGZsdXNoLCBiZWNhdXNlIGNvbXByZXNzaW9uIHdvdWxkIGhhdmUgYmVlblxuICAgICAqIHN1Y2Nlc3NmdWwuIElmIExJVF9CVUZTSVpFIDw9IFdTSVpFLCBpdCBpcyBuZXZlciB0b28gbGF0ZSB0b1xuICAgICAqIHRyYW5zZm9ybSBhIGJsb2NrIGludG8gYSBzdG9yZWQgYmxvY2suXG4gICAgICovXG4gICAgX3RyX3N0b3JlZF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpO1xuXG4gIH0gZWxzZSBpZiAocy5zdHJhdGVneSA9PT0gWl9GSVhFRCB8fCBzdGF0aWNfbGVuYiA9PT0gb3B0X2xlbmIpIHtcblxuICAgIHNlbmRfYml0cyhzLCAoU1RBVElDX1RSRUVTIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpO1xuICAgIGNvbXByZXNzX2Jsb2NrKHMsIHN0YXRpY19sdHJlZSwgc3RhdGljX2R0cmVlKTtcblxuICB9IGVsc2Uge1xuICAgIHNlbmRfYml0cyhzLCAoRFlOX1RSRUVTIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpO1xuICAgIHNlbmRfYWxsX3RyZWVzKHMsIHMubF9kZXNjLm1heF9jb2RlICsgMSwgcy5kX2Rlc2MubWF4X2NvZGUgKyAxLCBtYXhfYmxpbmRleCArIDEpO1xuICAgIGNvbXByZXNzX2Jsb2NrKHMsIHMuZHluX2x0cmVlLCBzLmR5bl9kdHJlZSk7XG4gIH1cbiAgLy8gQXNzZXJ0IChzLT5jb21wcmVzc2VkX2xlbiA9PSBzLT5iaXRzX3NlbnQsIFwiYmFkIGNvbXByZXNzZWQgc2l6ZVwiKTtcbiAgLyogVGhlIGFib3ZlIGNoZWNrIGlzIG1hZGUgbW9kIDJeMzIsIGZvciBmaWxlcyBsYXJnZXIgdGhhbiA1MTIgTUJcbiAgICogYW5kIHVMb25nIGltcGxlbWVudGVkIG9uIDMyIGJpdHMuXG4gICAqL1xuICBpbml0X2Jsb2NrKHMpO1xuXG4gIGlmIChsYXN0KSB7XG4gICAgYmlfd2luZHVwKHMpO1xuICB9XG4gIC8vIFRyYWNldigoc3RkZXJyLFwiXFxuY29tcHJsZW4gJWx1KCVsdSkgXCIsIHMtPmNvbXByZXNzZWRfbGVuPj4zLFxuICAvLyAgICAgICBzLT5jb21wcmVzc2VkX2xlbi03Kmxhc3QpKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTYXZlIHRoZSBtYXRjaCBpbmZvIGFuZCB0YWxseSB0aGUgZnJlcXVlbmN5IGNvdW50cy4gUmV0dXJuIHRydWUgaWZcbiAqIHRoZSBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gX3RyX3RhbGx5KHMsIGRpc3QsIGxjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHVuc2lnbmVkIGRpc3Q7ICAvKiBkaXN0YW5jZSBvZiBtYXRjaGVkIHN0cmluZyAqL1xuLy8gICAgdW5zaWduZWQgbGM7ICAgIC8qIG1hdGNoIGxlbmd0aC1NSU5fTUFUQ0ggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3Q9PTApICovXG57XG4gIC8vdmFyIG91dF9sZW5ndGgsIGluX2xlbmd0aCwgZGNvZGU7XG5cbiAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDJdICAgICA9IChkaXN0ID4+PiA4KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyICsgMV0gPSBkaXN0ICYgMHhmZjtcblxuICBzLnBlbmRpbmdfYnVmW3MubF9idWYgKyBzLmxhc3RfbGl0XSA9IGxjICYgMHhmZjtcbiAgcy5sYXN0X2xpdCsrO1xuXG4gIGlmIChkaXN0ID09PSAwKSB7XG4gICAgLyogbGMgaXMgdGhlIHVubWF0Y2hlZCBjaGFyICovXG4gICAgcy5keW5fbHRyZWVbbGMgKiAyXS8qLkZyZXEqLysrO1xuICB9IGVsc2Uge1xuICAgIHMubWF0Y2hlcysrO1xuICAgIC8qIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0ggKi9cbiAgICBkaXN0LS07ICAgICAgICAgICAgIC8qIGRpc3QgPSBtYXRjaCBkaXN0YW5jZSAtIDEgKi9cbiAgICAvL0Fzc2VydCgodXNoKWRpc3QgPCAodXNoKU1BWF9ESVNUKHMpICYmXG4gICAgLy8gICAgICAgKHVzaClsYyA8PSAodXNoKShNQVhfTUFUQ0gtTUlOX01BVENIKSAmJlxuICAgIC8vICAgICAgICh1c2gpZF9jb2RlKGRpc3QpIDwgKHVzaClEX0NPREVTLCAgXCJfdHJfdGFsbHk6IGJhZCBtYXRjaFwiKTtcblxuICAgIHMuZHluX2x0cmVlWyhfbGVuZ3RoX2NvZGVbbGNdICsgTElURVJBTFMgKyAxKSAqIDJdLyouRnJlcSovKys7XG4gICAgcy5keW5fZHRyZWVbZF9jb2RlKGRpc3QpICogMl0vKi5GcmVxKi8rKztcbiAgfVxuXG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmF1bHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuXG4vLyNpZmRlZiBUUlVOQ0FURV9CTE9DS1xuLy8gIC8qIFRyeSB0byBndWVzcyBpZiBpdCBpcyBwcm9maXRhYmxlIHRvIHN0b3AgdGhlIGN1cnJlbnQgYmxvY2sgaGVyZSAqL1xuLy8gIGlmICgocy5sYXN0X2xpdCAmIDB4MWZmZikgPT09IDAgJiYgcy5sZXZlbCA+IDIpIHtcbi8vICAgIC8qIENvbXB1dGUgYW4gdXBwZXIgYm91bmQgZm9yIHRoZSBjb21wcmVzc2VkIGxlbmd0aCAqL1xuLy8gICAgb3V0X2xlbmd0aCA9IHMubGFzdF9saXQqODtcbi8vICAgIGluX2xlbmd0aCA9IHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0O1xuLy9cbi8vICAgIGZvciAoZGNvZGUgPSAwOyBkY29kZSA8IERfQ09ERVM7IGRjb2RlKyspIHtcbi8vICAgICAgb3V0X2xlbmd0aCArPSBzLmR5bl9kdHJlZVtkY29kZSoyXS8qLkZyZXEqLyAqICg1ICsgZXh0cmFfZGJpdHNbZGNvZGVdKTtcbi8vICAgIH1cbi8vICAgIG91dF9sZW5ndGggPj4+PSAzO1xuLy8gICAgLy9UcmFjZXYoKHN0ZGVycixcIlxcbmxhc3RfbGl0ICV1LCBpbiAlbGQsIG91dCB+JWxkKCVsZCUlKSBcIixcbi8vICAgIC8vICAgICAgIHMtPmxhc3RfbGl0LCBpbl9sZW5ndGgsIG91dF9sZW5ndGgsXG4vLyAgICAvLyAgICAgICAxMDBMIC0gb3V0X2xlbmd0aCoxMDBML2luX2xlbmd0aCkpO1xuLy8gICAgaWYgKHMubWF0Y2hlcyA8IChzLmxhc3RfbGl0Pj4xKS8qaW50IC8yKi8gJiYgb3V0X2xlbmd0aCA8IChpbl9sZW5ndGg+PjEpLyppbnQgLzIqLykge1xuLy8gICAgICByZXR1cm4gdHJ1ZTtcbi8vICAgIH1cbi8vICB9XG4vLyNlbmRpZlxuXG4gIHJldHVybiAocy5sYXN0X2xpdCA9PT0gcy5saXRfYnVmc2l6ZSAtIDEpO1xuICAvKiBXZSBhdm9pZCBlcXVhbGl0eSB3aXRoIGxpdF9idWZzaXplIGJlY2F1c2Ugb2Ygd3JhcGFyb3VuZCBhdCA2NEtcbiAgICogb24gMTYgYml0IG1hY2hpbmVzIGFuZCBiZWNhdXNlIHN0b3JlZCBibG9ja3MgYXJlIHJlc3RyaWN0ZWQgdG9cbiAgICogNjRLLTEgYnl0ZXMuXG4gICAqL1xufVxuXG5leHBvcnRzLl90cl9pbml0ICA9IF90cl9pbml0O1xuZXhwb3J0cy5fdHJfc3RvcmVkX2Jsb2NrID0gX3RyX3N0b3JlZF9ibG9jaztcbmV4cG9ydHMuX3RyX2ZsdXNoX2Jsb2NrICA9IF90cl9mbHVzaF9ibG9jaztcbmV4cG9ydHMuX3RyX3RhbGx5ID0gX3RyX3RhbGx5O1xuZXhwb3J0cy5fdHJfYWxpZ24gPSBfdHJfYWxpZ247XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gWlN0cmVhbSgpIHtcbiAgLyogbmV4dCBpbnB1dCBieXRlICovXG4gIHRoaXMuaW5wdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9pbiA9IDA7XG4gIC8qIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUgYXQgaW5wdXQgKi9cbiAgdGhpcy5hdmFpbF9pbiA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBpbnB1dCBieXRlcyByZWFkIHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX2luID0gMDtcbiAgLyogbmV4dCBvdXRwdXQgYnl0ZSBzaG91bGQgYmUgcHV0IHRoZXJlICovXG4gIHRoaXMub3V0cHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfb3V0ID0gMDtcbiAgLyogcmVtYWluaW5nIGZyZWUgc3BhY2UgYXQgb3V0cHV0ICovXG4gIHRoaXMuYXZhaWxfb3V0ID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGJ5dGVzIG91dHB1dCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9vdXQgPSAwO1xuICAvKiBsYXN0IGVycm9yIG1lc3NhZ2UsIE5VTEwgaWYgbm8gZXJyb3IgKi9cbiAgdGhpcy5tc2cgPSAnJy8qWl9OVUxMKi87XG4gIC8qIG5vdCB2aXNpYmxlIGJ5IGFwcGxpY2F0aW9ucyAqL1xuICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgLyogYmVzdCBndWVzcyBhYm91dCB0aGUgZGF0YSB0eXBlOiBiaW5hcnkgb3IgdGV4dCAqL1xuICB0aGlzLmRhdGFfdHlwZSA9IDIvKlpfVU5LTk9XTiovO1xuICAvKiBhZGxlcjMyIHZhbHVlIG9mIHRoZSB1bmNvbXByZXNzZWQgZGF0YSAqL1xuICB0aGlzLmFkbGVyID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBaU3RyZWFtO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8XG4gICAgIXByb2Nlc3MudmVyc2lvbiB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MC4nKSA9PT0gMCB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS4nKSA9PT0gMCAmJiBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuOC4nKSAhPT0gMCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHsgbmV4dFRpY2s6IG5leHRUaWNrIH07XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3Ncbn1cblxuZnVuY3Rpb24gbmV4dFRpY2soZm4sIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2FsbGJhY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGFyZ3MsIGk7XG4gIHN3aXRjaCAobGVuKSB7XG4gIGNhc2UgMDpcbiAgY2FzZSAxOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZuKTtcbiAgY2FzZSAyOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja09uZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSk7XG4gICAgfSk7XG4gIGNhc2UgMzpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUd28oKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIpO1xuICAgIH0pO1xuICBjYXNlIDQ6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVGhyZWUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH0pO1xuICBkZWZhdWx0OlxuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgYXJnc1tpKytdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2soKSB7XG4gICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9KTtcbiAgfVxufVxuXG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1yZXR1cm4ga2V5cztcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxue1xuICAvLyBhdm9pZCBzY29wZSBjcmVlcCwgdGhlIGtleXMgYXJyYXkgY2FuIHRoZW4gYmUgY29sbGVjdGVkXG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG4gIH1cbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwbmEubmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5EdXBsZXgucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5wdXNoKG51bGwpO1xuICB0aGlzLmVuZCgpO1xuXG4gIHBuYS5uZXh0VGljayhjYiwgZXJyKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWJ1ZyA9IHZvaWQgMDtcbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdCcpO1xudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcbnZhciBTdHJpbmdEZWNvZGVyO1xuXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG52YXIga1Byb3h5RXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTtcblxuICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChpc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciByZWFkYWJsZUh3bSA9IG9wdGlvbnMucmVhZGFibGVIaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuXG4gIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHJlYWRhYmxlSHdtIHx8IHJlYWRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gcmVhZGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xuXG4gIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBldmVudCAncmVhZGFibGUnLydkYXRhJyBpcyBlbWl0dGVkXG4gIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlXG4gIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIGNiKGVycik7XG59O1xuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHNraXBDaHVua0NoZWNrO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICBlbmNvZGluZyA9ICcnO1xuICAgICAgfVxuICAgICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlLCBza2lwQ2h1bmtDaGVjayk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIG51bGwsIHRydWUsIGZhbHNlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVyO1xuICAgIGlmICghc2tpcENodW5rQ2hlY2spIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gICAgaWYgKGVyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHtcbiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcbiAgICAgICAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKSk7ZWxzZSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZGVkKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFlbmNvZGluZykge1xuICAgICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsubGVuZ3RoICE9PSAwKSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO2Vsc2UgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkge1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH1cbiAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXI7XG4gIGlmICghX2lzVWludDhBcnJheShjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubmVlZFJlYWRhYmxlIHx8IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiA4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjtcbiAgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAobiAhPT0gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gICAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gICAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XG4gIH1cblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpIHBuYS5uZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO2Vsc2UgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICBmbG93KHN0cmVhbSk7XG59XG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztlbHNlIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ19yZWFkKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogdW5waXBlO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcG5hLm5leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG5cbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIC8vIElmIHRoZSB1c2VyIHB1c2hlcyBtb3JlIGRhdGEgd2hpbGUgd2UncmUgd3JpdGluZyB0byBkZXN0IHRoZW4gd2UnbGwgZW5kIHVwXG4gIC8vIGluIG9uZGF0YSBhZ2Fpbi4gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIGluY3JlYXNlIGF3YWl0RHJhaW4gb25jZSBiZWNhdXNlXG4gIC8vIGRlc3Qgd2lsbCBvbmx5IGVtaXQgb25lICdkcmFpbicgZXZlbnQgZm9yIHRoZSBtdWx0aXBsZSB3cml0ZXMuXG4gIC8vID0+IEludHJvZHVjZSBhIGd1YXJkIG9uIGluY3JlYXNpbmcgYXdhaXREcmFpbi5cbiAgdmFyIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQgJiYgIWluY3JlYXNlZEF3YWl0RHJhaW4pIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB1bnBpcGVJbmZvID0geyBoYXNVbnBpcGVkOiBmYWxzZSB9O1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIH1yZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyBTdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcG5hLm5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHt9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBfdGhpcy5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gX3RoaXMucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHtcbiAgICBzdHJlYW0ub24oa1Byb3h5RXZlbnRzW25dLCB0aGlzLmVtaXQuYmluZCh0aGlzLCBrUHJveHlFdmVudHNbbl0pKTtcbiAgfVxuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHRoaXMuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICAvLyBub3RoaW5nIGJ1ZmZlcmVkXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gIHZhciByZXQ7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgbGlzdFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxuICAgIHJldCA9IGZyb21MaXN0UGFydGlhbChuLCBzdGF0ZS5idWZmZXIsIHN0YXRlLmRlY29kZXIpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gRXh0cmFjdHMgb25seSBlbm91Z2ggYnVmZmVyZWQgZGF0YSB0byBzYXRpc2Z5IHRoZSBhbW91bnQgcmVxdWVzdGVkLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdFBhcnRpYWwobiwgbGlzdCwgaGFzU3RyaW5ncykge1xuICB2YXIgcmV0O1xuICBpZiAobiA8IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzXG4gICAgcmV0ID0gbGlzdC5oZWFkLmRhdGEuc2xpY2UoMCwgbik7XG4gICAgbGlzdC5oZWFkLmRhdGEgPSBsaXN0LmhlYWQuZGF0YS5zbGljZShuKTtcbiAgfSBlbHNlIGlmIChuID09PSBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBmaXJzdCBjaHVuayBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVzdWx0IHNwYW5zIG1vcmUgdGhhbiBvbmUgYnVmZmVyXG4gICAgcmV0ID0gaGFzU3RyaW5ncyA/IGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIDogY29weUZyb21CdWZmZXIobiwgbGlzdCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YVxuLy8gY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSB7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHZhciByZXQgPSBwLmRhdGE7XG4gIG4gLT0gcmV0Lmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgc3RyID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47XG4gICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSByZXQgKz0gc3RyO2Vsc2UgcmV0ICs9IHN0ci5zbGljZSgwLCBuKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gc3RyLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGEgY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KSB7XG4gIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHAuZGF0YS5jb3B5KHJldCk7XG4gIG4gLT0gcC5kYXRhLmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgYnVmID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBidWYubGVuZ3RoID8gYnVmLmxlbmd0aCA6IG47XG4gICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKCdcImVuZFJlYWRhYmxlKClcIiBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShlciwgZGF0YSkge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3dyaXRlIGNhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lcycpKTtcbiAgfVxuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICB0aGlzLnB1c2goZGF0YSk7XG5cbiAgY2IoZXIpO1xuXG4gIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSB7XG4gICAgYWZ0ZXJUcmFuc2Zvcm06IGFmdGVyVHJhbnNmb3JtLmJpbmQodGhpcyksXG4gICAgbmVlZFRyYW5zZm9ybTogZmFsc2UsXG4gICAgdHJhbnNmb3JtaW5nOiBmYWxzZSxcbiAgICB3cml0ZWNiOiBudWxsLFxuICAgIHdyaXRlY2h1bms6IG51bGwsXG4gICAgd3JpdGVlbmNvZGluZzogbnVsbFxuICB9O1xuXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XG4gIH1cblxuICAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gIHRoaXMub24oJ3ByZWZpbmlzaCcsIHByZWZpbmlzaCk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaCgpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgICBkb25lKF90aGlzLCBlciwgZGF0YSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZG9uZSh0aGlzLCBudWxsLCBudWxsKTtcbiAgfVxufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfdHJhbnNmb3JtKCkgaXMgbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveS5jYWxsKHRoaXMsIGVyciwgZnVuY3Rpb24gKGVycjIpIHtcbiAgICBjYihlcnIyKTtcbiAgICBfdGhpczIuZW1pdCgnY2xvc2UnKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIGlmIChzdHJlYW0uX3dyaXRhYmxlU3RhdGUubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmIChzdHJlYW0uX3RyYW5zZm9ybVN0YXRlLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyogPHJlcGxhY2VtZW50PiAqL1xuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufVxuXG4vLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3Rcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxuZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuZW50cnkgPSBudWxsO1xuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBvbkNvcmtlZEZpbmlzaChfdGhpcywgc3RhdGUpO1xuICB9O1xufVxuLyogPC9yZXBsYWNlbWVudD4gKi9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBhc3luY1dyaXRlID0gIXByb2Nlc3MuYnJvd3NlciAmJiBbJ3YwLjEwJywgJ3YwLjkuJ10uaW5kZXhPZihwcm9jZXNzLnZlcnNpb24uc2xpY2UoMCwgNSkpID4gLTEgPyBzZXRJbW1lZGlhdGUgOiBwbmEubmV4dFRpY2s7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG51dGlsLmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBub3AoKSB7fVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cbiAgdmFyIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciB3cml0YWJsZUh3bSA9IG9wdGlvbnMud3JpdGFibGVIaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuXG4gIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHdyaXRhYmxlSHdtIHx8IHdyaXRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gd3JpdGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xuXG4gIC8vIGlmIF9maW5hbCBoYXMgYmVlbiBjYWxsZWRcbiAgdGhpcy5maW5hbENhbGxlZCA9IGZhbHNlO1xuXG4gIC8vIGRyYWluIGV2ZW50IGZsYWcuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuXG4gIC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuXG4gIC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpXG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHt9XG59KSgpO1xuXG4vLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcyxcbi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS5cbnZhciByZWFsSGFzSW5zdGFuY2U7XG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICBpZiAocmVhbEhhc0luc3RhbmNlLmNhbGwodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodGhpcyAhPT0gV3JpdGFibGUpIHJldHVybiBmYWxzZTtcblxuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cblxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgaWYgKCFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkge1xuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIH1cblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maW5hbCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsO1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJykpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG59XG5cbi8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXJcbi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWRcbi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIHZhciBlciA9IGZhbHNlO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcbiAgdmFyIGlzQnVmID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgX2lzVWludDhBcnJheShjaHVuayk7XG5cbiAgaWYgKGlzQnVmICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChpc0J1ZikgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuXG4gIGlmIChzdGF0ZS5lbmRlZCkgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgaWYgKCFpc0J1Zikge1xuICAgIHZhciBuZXdDaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuICAgIGlmIChjaHVuayAhPT0gbmV3Q2h1bmspIHtcbiAgICAgIGlzQnVmID0gdHJ1ZTtcbiAgICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gICAgICBjaHVuayA9IG5ld0NodW5rO1xuICAgIH1cbiAgfVxuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0ge1xuICAgICAgY2h1bms6IGNodW5rLFxuICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgICAgaXNCdWY6IGlzQnVmLFxuICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcblxuICBpZiAoc3luYykge1xuICAgIC8vIGRlZmVyIHRoZSBjYWxsYmFjayBpZiB3ZSBhcmUgYmVpbmcgY2FsbGVkIHN5bmNocm9ub3VzbHlcbiAgICAvLyB0byBhdm9pZCBwaWxpbmcgdXAgdGhpbmdzIG9uIHRoZSBzdGFja1xuICAgIHBuYS5uZXh0VGljayhjYiwgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBhbmQgaXQgd2lsbCBhbHdheXMgaGFwcGVuXG4gICAgLy8gYWZ0ZXIgZXJyb3JcbiAgICBwbmEubmV4dFRpY2soZmluaXNoTWF5YmUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgY2FsbGVyIGV4cGVjdCB0aGlzIHRvIGhhcHBlbiBiZWZvcmUgaWZcbiAgICAvLyBpdCBpcyBhc3luY1xuICAgIGNiKGVyKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGJ1dCBmaW5pc2ggbXVzdFxuICAgIC8vIGFsd2F5cyBmb2xsb3cgZXJyb3JcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICAvKjxyZXBsYWNlbWVudD4qL1xuICAgICAgYXN5bmNXcml0ZShhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgLyo8L3JlcGxhY2VtZW50PiovXG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsKTtcbiAgICB2YXIgaG9sZGVyID0gc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlO1xuICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5O1xuXG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgYWxsQnVmZmVycyA9IHRydWU7XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBpZiAoIWVudHJ5LmlzQnVmKSBhbGxCdWZmZXJzID0gZmFsc2U7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cbiAgICBidWZmZXIuYWxsQnVmZmVycyA9IGFsbEJ1ZmZlcnM7XG5cbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7XG5cbiAgICAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICAgIGlmIChob2xkZXIubmV4dCkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50LS07XG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRXJyb3IoJ193cml0ZSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfVxuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xufTtcblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuZnVuY3Rpb24gY2FsbEZpbmFsKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RyZWFtLl9maW5hbChmdW5jdGlvbiAoZXJyKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgaWYgKGVycikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9XG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkICYmICFzdGF0ZS5maW5hbENhbGxlZCkge1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtLl9maW5hbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgICBzdGF0ZS5maW5hbENhbGxlZCA9IHRydWU7XG4gICAgICBwbmEubmV4dFRpY2soY2FsbEZpbmFsLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHBuYS5uZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9uQ29ya2VkRmluaXNoKGNvcmtSZXEsIHN0YXRlLCBlcnIpIHtcbiAgdmFyIGVudHJ5ID0gY29ya1JlcS5lbnRyeTtcbiAgY29ya1JlcS5lbnRyeSA9IG51bGw7XG4gIHdoaWxlIChlbnRyeSkge1xuICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVycik7XG4gICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICB9XG4gIGlmIChzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUpIHtcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IGNvcmtSZXE7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gY29ya1JlcTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMuZW5kKCk7XG4gIGNiKGVycik7XG59OyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmZ1bmN0aW9uIGNvcHlCdWZmZXIoc3JjLCB0YXJnZXQsIG9mZnNldCkge1xuICBzcmMuY29weSh0YXJnZXQsIG9mZnNldCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWZmZXJMaXN0KTtcblxuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH1cblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiBudWxsIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIHVuc2hpZnQodikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogdGhpcy5oZWFkIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAgIC0tdGhpcy5sZW5ndGg7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBqb2luKHMpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7XG4gICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgIHJldCArPSBzICsgcC5kYXRhO1xuICAgIH1yZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdChuKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRoaXMuaGVhZC5kYXRhO1xuICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChwKSB7XG4gICAgICBjb3B5QnVmZmVyKHAuZGF0YSwgcmV0LCBpKTtcbiAgICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcbiAgICAgIHAgPSBwLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgcmV0dXJuIEJ1ZmZlckxpc3Q7XG59KCk7XG5cbmlmICh1dGlsICYmIHV0aWwuaW5zcGVjdCAmJiB1dGlsLmluc3BlY3QuY3VzdG9tKSB7XG4gIG1vZHVsZS5leHBvcnRzLnByb3RvdHlwZVt1dGlsLmluc3BlY3QuY3VzdG9tXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdXRpbC5pbnNwZWN0KHsgbGVuZ3RoOiB0aGlzLmxlbmd0aCB9KTtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgJyAnICsgb2JqO1xuICB9O1xufSIsIid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLy8gdW5kb2N1bWVudGVkIGNiKCkgQVBJLCBuZWVkZWQgZm9yIGNvcmUsIG5vdCBmb3IgcHVibGljIEFQSVxuZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcblxuICBpZiAocmVhZGFibGVEZXN0cm95ZWQgfHwgd3JpdGFibGVEZXN0cm95ZWQpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIGlmIChlcnIgJiYgKCF0aGlzLl93cml0YWJsZVN0YXRlIHx8ICF0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkpIHtcbiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB3ZSBzZXQgZGVzdHJveWVkIHRvIHRydWUgYmVmb3JlIGZpcmluZyBlcnJvciBjYWxsYmFja3MgaW4gb3JkZXJcbiAgLy8gdG8gbWFrZSBpdCByZS1lbnRyYW5jZSBzYWZlIGluIGNhc2UgZGVzdHJveSgpIGlzIGNhbGxlZCB3aXRoaW4gY2FsbGJhY2tzXG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICAvLyBpZiB0aGlzIGlzIGEgZHVwbGV4IHN0cmVhbSBtYXJrIHRoZSB3cml0YWJsZSBwYXJ0IGFzIGRlc3Ryb3llZCBhcyB3ZWxsXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgdGhpcy5fZGVzdHJveShlcnIgfHwgbnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmICghY2IgJiYgZXJyKSB7XG4gICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIF90aGlzLCBlcnIpO1xuICAgICAgaWYgKF90aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIF90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiB1bmRlc3Ryb3koKSB7XG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdEVycm9yTlQoc2VsZiwgZXJyKSB7XG4gIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVzdHJveTogZGVzdHJveSxcbiAgdW5kZXN0cm95OiB1bmRlc3Ryb3lcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVhZGFibGUnKS5QYXNzVGhyb3VnaFxuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBleHBvcnRzO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlRyYW5zZm9ybVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXG5cblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbCgwKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKHNpemUpXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtO1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5pbmhlcml0cyhTdHJlYW0sIEVFKTtcblN0cmVhbS5SZWFkYWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcycpO1xuU3RyZWFtLldyaXRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzJyk7XG5TdHJlYW0uRHVwbGV4ID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcycpO1xuU3RyZWFtLlRyYW5zZm9ybSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMnKTtcblN0cmVhbS5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcycpO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjQueFxuU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTtcblxuXG5cbi8vIG9sZC1zdHlsZSBzdHJlYW1zLiAgTm90ZSB0aGF0IHRoZSBwaXBlIG1ldGhvZCAodGhlIG9ubHkgcmVsZXZhbnRcbi8vIHBhcnQgb2YgdGhpcyBjbGFzcykgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgUmVhZGFibGUgY2xhc3MuXG5cbmZ1bmN0aW9uIFN0cmVhbSgpIHtcbiAgRUUuY2FsbCh0aGlzKTtcbn1cblxuU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgb3B0aW9ucykge1xuICB2YXIgc291cmNlID0gdGhpcztcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBpZiAoZGVzdC53cml0YWJsZSkge1xuICAgICAgaWYgKGZhbHNlID09PSBkZXN0LndyaXRlKGNodW5rKSAmJiBzb3VyY2UucGF1c2UpIHtcbiAgICAgICAgc291cmNlLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRyYWluKCkge1xuICAgIGlmIChzb3VyY2UucmVhZGFibGUgJiYgc291cmNlLnJlc3VtZSkge1xuICAgICAgc291cmNlLnJlc3VtZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgLy8gSWYgdGhlICdlbmQnIG9wdGlvbiBpcyBub3Qgc3VwcGxpZWQsIGRlc3QuZW5kKCkgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS5cbiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XG4gICAgc291cmNlLm9uKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9XG5cbiAgdmFyIGRpZE9uRW5kID0gZmFsc2U7XG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIGRlc3QuZGVzdHJveSgpO1xuICB9XG5cbiAgLy8gZG9uJ3QgbGVhdmUgZGFuZ2xpbmcgcGlwZXMgd2hlbiB0aGVyZSBhcmUgZXJyb3JzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgY2xlYW51cCgpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHRoaXMsICdlcnJvcicpID09PSAwKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkIHN0cmVhbSBlcnJvciBpbiBwaXBlLlxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLlxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuICB9XG5cbiAgc291cmNlLm9uKCdlbmQnLCBjbGVhbnVwKTtcbiAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3Qub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc291cmNlKTtcblxuICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKVxuICByZXR1cm4gZGVzdDtcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGlzRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZyB8fCBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgZW5jb2RpbmcgPSAnJyArIGVuY29kaW5nO1xuICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOmNhc2UgJ3V0ZjgnOmNhc2UgJ3V0Zi04JzpjYXNlICdhc2NpaSc6Y2FzZSAnYmluYXJ5JzpjYXNlICdiYXNlNjQnOmNhc2UgJ3VjczInOmNhc2UgJ3Vjcy0yJzpjYXNlICd1dGYxNmxlJzpjYXNlICd1dGYtMTZsZSc6Y2FzZSAncmF3JzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgaWYgKCFlbmMpIHJldHVybiAndXRmOCc7XG4gIHZhciByZXRyaWVkO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jKSB7XG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuICd1dGY4JztcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiAndXRmMTZsZSc7XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuICdsYXRpbjEnO1xuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBlbmM7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAocmV0cmllZCkgcmV0dXJuOyAvLyB1bmRlZmluZWRcbiAgICAgICAgZW5jID0gKCcnICsgZW5jKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXRyaWVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIERvIG5vdCBjYWNoZSBgQnVmZmVyLmlzRW5jb2RpbmdgIHdoZW4gY2hlY2tpbmcgZW5jb2RpbmcgbmFtZXMgYXMgc29tZVxuLy8gbW9kdWxlcyBtb25rZXktcGF0Y2ggaXQgdG8gc3VwcG9ydCBhZGRpdGlvbmFsIGVuY29kaW5nc1xuZnVuY3Rpb24gbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIHZhciBuZW5jID0gX25vcm1hbGl6ZUVuY29kaW5nKGVuYyk7XG4gIGlmICh0eXBlb2YgbmVuYyAhPT0gJ3N0cmluZycgJiYgKEJ1ZmZlci5pc0VuY29kaW5nID09PSBpc0VuY29kaW5nIHx8ICFpc0VuY29kaW5nKGVuYykpKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmMpO1xuICByZXR1cm4gbmVuYyB8fCBlbmM7XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy5cbmV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IFN0cmluZ0RlY29kZXI7XG5mdW5jdGlvbiBTdHJpbmdEZWNvZGVyKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSBub3JtYWxpemVFbmNvZGluZyhlbmNvZGluZyk7XG4gIHZhciBuYjtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICB0aGlzLnRleHQgPSB1dGYxNlRleHQ7XG4gICAgICB0aGlzLmVuZCA9IHV0ZjE2RW5kO1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICB0aGlzLmZpbGxMYXN0ID0gdXRmOEZpbGxMYXN0O1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHRoaXMudGV4dCA9IGJhc2U2NFRleHQ7XG4gICAgICB0aGlzLmVuZCA9IGJhc2U2NEVuZDtcbiAgICAgIG5iID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gc2ltcGxlV3JpdGU7XG4gICAgICB0aGlzLmVuZCA9IHNpbXBsZUVuZDtcbiAgICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgdGhpcy5sYXN0VG90YWwgPSAwO1xuICB0aGlzLmxhc3RDaGFyID0gQnVmZmVyLmFsbG9jVW5zYWZlKG5iKTtcbn1cblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIHZhciByO1xuICB2YXIgaTtcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICByID0gdGhpcy5maWxsTGFzdChidWYpO1xuICAgIGlmIChyID09PSB1bmRlZmluZWQpIHJldHVybiAnJztcbiAgICBpID0gdGhpcy5sYXN0TmVlZDtcbiAgICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgfSBlbHNlIHtcbiAgICBpID0gMDtcbiAgfVxuICBpZiAoaSA8IGJ1Zi5sZW5ndGgpIHJldHVybiByID8gciArIHRoaXMudGV4dChidWYsIGkpIDogdGhpcy50ZXh0KGJ1ZiwgaSk7XG4gIHJldHVybiByIHx8ICcnO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gdXRmOEVuZDtcblxuLy8gUmV0dXJucyBvbmx5IGNvbXBsZXRlIGNoYXJhY3RlcnMgaW4gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLnRleHQgPSB1dGY4VGV4dDtcblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBwYXJ0aWFsIG5vbi1VVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZmlsbExhc3QgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59O1xuXG4vLyBDaGVja3MgdGhlIHR5cGUgb2YgYSBVVEYtOCBieXRlLCB3aGV0aGVyIGl0J3MgQVNDSUksIGEgbGVhZGluZyBieXRlLCBvciBhXG4vLyBjb250aW51YXRpb24gYnl0ZS4gSWYgYW4gaW52YWxpZCBieXRlIGlzIGRldGVjdGVkLCAtMiBpcyByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0J5dGUoYnl0ZSkge1xuICBpZiAoYnl0ZSA8PSAweDdGKSByZXR1cm4gMDtlbHNlIGlmIChieXRlID4+IDUgPT09IDB4MDYpIHJldHVybiAyO2Vsc2UgaWYgKGJ5dGUgPj4gNCA9PT0gMHgwRSkgcmV0dXJuIDM7ZWxzZSBpZiAoYnl0ZSA+PiAzID09PSAweDFFKSByZXR1cm4gNDtcbiAgcmV0dXJuIGJ5dGUgPj4gNiA9PT0gMHgwMiA/IC0xIDogLTI7XG59XG5cbi8vIENoZWNrcyBhdCBtb3N0IDMgYnl0ZXMgYXQgdGhlIGVuZCBvZiBhIEJ1ZmZlciBpbiBvcmRlciB0byBkZXRlY3QgYW5cbi8vIGluY29tcGxldGUgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIuIFRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgKDIsIDMsIG9yIDQpXG4vLyBuZWVkZWQgdG8gY29tcGxldGUgdGhlIFVURi04IGNoYXJhY3RlciAoaWYgYXBwbGljYWJsZSkgYXJlIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrSW5jb21wbGV0ZShzZWxmLCBidWYsIGkpIHtcbiAgdmFyIGogPSBidWYubGVuZ3RoIC0gMTtcbiAgaWYgKGogPCBpKSByZXR1cm4gMDtcbiAgdmFyIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDE7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDI7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHtcbiAgICAgIGlmIChuYiA9PT0gMikgbmIgPSAwO2Vsc2Ugc2VsZi5sYXN0TmVlZCA9IG5iIC0gMztcbiAgICB9XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vLyBWYWxpZGF0ZXMgYXMgbWFueSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgYXNcbi8vIG5lZWRlZCBvciBhcmUgYXZhaWxhYmxlLiBJZiB3ZSBzZWUgYSBub24tY29udGludWF0aW9uIGJ5dGUgd2hlcmUgd2UgZXhwZWN0XG4vLyBvbmUsIHdlIFwicmVwbGFjZVwiIHRoZSB2YWxpZGF0ZWQgY29udGludWF0aW9uIGJ5dGVzIHdlJ3ZlIHNlZW4gc28gZmFyIHdpdGhcbi8vIGEgc2luZ2xlIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlciAoJ1xcdWZmZmQnKSwgdG8gbWF0Y2ggdjgncyBVVEYtOCBkZWNvZGluZ1xuLy8gYmVoYXZpb3IuIFRoZSBjb250aW51YXRpb24gYnl0ZSBjaGVjayBpcyBpbmNsdWRlZCB0aHJlZSB0aW1lcyBpbiB0aGUgY2FzZVxuLy8gd2hlcmUgYWxsIG9mIHRoZSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgY2hhcmFjdGVyIGV4aXN0IGluIHRoZSBzYW1lIGJ1ZmZlci5cbi8vIEl0IGlzIGFsc28gZG9uZSB0aGlzIHdheSBhcyBhIHNsaWdodCBwZXJmb3JtYW5jZSBpbmNyZWFzZSBpbnN0ZWFkIG9mIHVzaW5nIGFcbi8vIGxvb3AuXG5mdW5jdGlvbiB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHNlbGYsIGJ1ZiwgcCkge1xuICBpZiAoKGJ1ZlswXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgc2VsZi5sYXN0TmVlZCA9IDA7XG4gICAgcmV0dXJuICdcXHVmZmZkJztcbiAgfVxuICBpZiAoc2VsZi5sYXN0TmVlZCA+IDEgJiYgYnVmLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoKGJ1ZlsxXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICBzZWxmLmxhc3ROZWVkID0gMTtcbiAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgfVxuICAgIGlmIChzZWxmLmxhc3ROZWVkID4gMiAmJiBidWYubGVuZ3RoID4gMikge1xuICAgICAgaWYgKChidWZbMl0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgICBzZWxmLmxhc3ROZWVkID0gMjtcbiAgICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyLlxuZnVuY3Rpb24gdXRmOEZpbGxMYXN0KGJ1Zikge1xuICB2YXIgcCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgdmFyIHIgPSB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHRoaXMsIGJ1ZiwgcCk7XG4gIGlmIChyICE9PSB1bmRlZmluZWQpIHJldHVybiByO1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59XG5cbi8vIFJldHVybnMgYWxsIGNvbXBsZXRlIFVURi04IGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIuIElmIHRoZSBCdWZmZXIgZW5kZWQgb24gYVxuLy8gcGFydGlhbCBjaGFyYWN0ZXIsIHRoZSBjaGFyYWN0ZXIncyBieXRlcyBhcmUgYnVmZmVyZWQgdW50aWwgdGhlIHJlcXVpcmVkXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXJlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIHV0ZjhUZXh0KGJ1ZiwgaSkge1xuICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7XG4gIGlmICghdGhpcy5sYXN0TmVlZCkgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGkpO1xuICB0aGlzLmxhc3RUb3RhbCA9IHRvdGFsO1xuICB2YXIgZW5kID0gYnVmLmxlbmd0aCAtICh0b3RhbCAtIHRoaXMubGFzdE5lZWQpO1xuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCAwLCBlbmQpO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSwgZW5kKTtcbn1cblxuLy8gRm9yIFVURi04LCBhIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpcyBhZGRlZCB3aGVuIGVuZGluZyBvbiBhIHBhcnRpYWxcbi8vIGNoYXJhY3Rlci5cbmZ1bmN0aW9uIHV0ZjhFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgJ1xcdWZmZmQnO1xuICByZXR1cm4gcjtcbn1cblxuLy8gVVRGLTE2TEUgdHlwaWNhbGx5IG5lZWRzIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyLCBidXQgZXZlbiBpZiB3ZSBoYXZlIGFuIGV2ZW5cbi8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgZW5kIG9uIGEgbGVhZGluZy9oaWdoXG4vLyBzdXJyb2dhdGUuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCB0d28gYnl0ZXMgaW4gb3JkZXIgdG9cbi8vIGRlY29kZSB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJvcGVybHkuXG5mdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7XG4gIGlmICgoYnVmLmxlbmd0aCAtIGkpICUgMiA9PT0gMCkge1xuICAgIHZhciByID0gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSk7XG4gICAgaWYgKHIpIHtcbiAgICAgIHZhciBjID0gci5jaGFyQ29kZUF0KHIubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERCRkYpIHtcbiAgICAgICAgdGhpcy5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHRoaXMubGFzdFRvdGFsID0gNDtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAxO1xuICB0aGlzLmxhc3RUb3RhbCA9IDI7XG4gIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSwgYnVmLmxlbmd0aCAtIDEpO1xufVxuXG4vLyBGb3IgVVRGLTE2TEUgd2UgZG8gbm90IGV4cGxpY2l0bHkgYXBwZW5kIHNwZWNpYWwgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBpZiB3ZVxuLy8gZW5kIG9uIGEgcGFydGlhbCBjaGFyYWN0ZXIsIHdlIHNpbXBseSBsZXQgdjggaGFuZGxlIHRoYXQuXG5mdW5jdGlvbiB1dGYxNkVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHZhciBlbmQgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gICAgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgZW5kKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gYmFzZTY0VGV4dChidWYsIGkpIHtcbiAgdmFyIG4gPSAoYnVmLmxlbmd0aCAtIGkpICUgMztcbiAgaWYgKG4gPT09IDApIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGkpO1xuICB0aGlzLmxhc3ROZWVkID0gMyAtIG47XG4gIHRoaXMubGFzdFRvdGFsID0gMztcbiAgaWYgKG4gPT09IDEpIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpLCBidWYubGVuZ3RoIC0gbik7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCAzIC0gdGhpcy5sYXN0TmVlZCk7XG4gIHJldHVybiByO1xufVxuXG4vLyBQYXNzIGJ5dGVzIG9uIHRocm91Z2ggZm9yIHNpbmdsZS1ieXRlIGVuY29kaW5ncyAoZS5nLiBhc2NpaSwgbGF0aW4xLCBoZXgpXG5mdW5jdGlvbiBzaW1wbGVXcml0ZShidWYpIHtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRW5kKGJ1Zikge1xuICByZXR1cm4gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbn0iLCJ2YXIgbmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzL2Jyb3dzZXIuanMnKS5uZXh0VGljaztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBpbW1lZGlhdGVJZHMgPSB7fTtcbnZhciBuZXh0SW1tZWRpYXRlSWQgPSAwO1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkgeyB0aW1lb3V0LmNsb3NlKCk7IH07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwod2luZG93LCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gVGhhdCdzIG5vdCBob3cgbm9kZS5qcyBpbXBsZW1lbnRzIGl0IGJ1dCB0aGUgZXhwb3NlZCBhcGkgaXMgdGhlIHNhbWUuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHNldEltbWVkaWF0ZSA6IGZ1bmN0aW9uKGZuKSB7XG4gIHZhciBpZCA9IG5leHRJbW1lZGlhdGVJZCsrO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gZmFsc2UgOiBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgaW1tZWRpYXRlSWRzW2lkXSA9IHRydWU7XG5cbiAgbmV4dFRpY2soZnVuY3Rpb24gb25OZXh0VGljaygpIHtcbiAgICBpZiAoaW1tZWRpYXRlSWRzW2lkXSkge1xuICAgICAgLy8gZm4uY2FsbCgpIGlzIGZhc3RlciBzbyB3ZSBvcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiB1c2UtY2FzZVxuICAgICAgLy8gQHNlZSBodHRwOi8vanNwZXJmLmNvbS9jYWxsLWFwcGx5LXNlZ3VcbiAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm4uY2FsbChudWxsKTtcbiAgICAgIH1cbiAgICAgIC8vIFByZXZlbnQgaWRzIGZyb20gbGVha2luZ1xuICAgICAgZXhwb3J0cy5jbGVhckltbWVkaWF0ZShpZCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gaWQ7XG59O1xuXG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gdHlwZW9mIGNsZWFySW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBjbGVhckltbWVkaWF0ZSA6IGZ1bmN0aW9uKGlkKSB7XG4gIGRlbGV0ZSBpbW1lZGlhdGVJZHNbaWRdO1xufTsiLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7XG5cbi8qKlxuICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbiAqIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIG5ldyBcImRlcHJlY2F0ZWRcIiB2ZXJzaW9uIG9mIGBmbmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVwcmVjYXRlIChmbiwgbXNnKSB7XG4gIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGBsb2NhbFN0b3JhZ2VgIGZvciBib29sZWFuIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb25maWcgKG5hbWUpIHtcbiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXNcbiAgdHJ5IHtcbiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcbiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG4iLCJ2YXIgYnVuZGxlRm4gPSBhcmd1bWVudHNbM107XG52YXIgc291cmNlcyA9IGFyZ3VtZW50c1s0XTtcbnZhciBjYWNoZSA9IGFyZ3VtZW50c1s1XTtcblxudmFyIHN0cmluZ2lmeSA9IEpTT04uc3RyaW5naWZ5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgb3B0aW9ucykge1xuICAgIHZhciB3a2V5O1xuICAgIHZhciBjYWNoZUtleXMgPSBPYmplY3Qua2V5cyhjYWNoZSk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNhY2hlS2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGNhY2hlS2V5c1tpXTtcbiAgICAgICAgdmFyIGV4cCA9IGNhY2hlW2tleV0uZXhwb3J0cztcbiAgICAgICAgLy8gVXNpbmcgYmFiZWwgYXMgYSB0cmFuc3BpbGVyIHRvIHVzZSBlc21vZHVsZSwgdGhlIGV4cG9ydCB3aWxsIGFsd2F5c1xuICAgICAgICAvLyBiZSBhbiBvYmplY3Qgd2l0aCB0aGUgZGVmYXVsdCBleHBvcnQgYXMgYSBwcm9wZXJ0eSBvZiBpdC4gVG8gZW5zdXJlXG4gICAgICAgIC8vIHRoZSBleGlzdGluZyBhcGkgYW5kIGJhYmVsIGVzbW9kdWxlIGV4cG9ydHMgYXJlIGJvdGggc3VwcG9ydGVkIHdlXG4gICAgICAgIC8vIGNoZWNrIGZvciBib3RoXG4gICAgICAgIGlmIChleHAgPT09IGZuIHx8IGV4cCAmJiBleHAuZGVmYXVsdCA9PT0gZm4pIHtcbiAgICAgICAgICAgIHdrZXkgPSBrZXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghd2tleSkge1xuICAgICAgICB3a2V5ID0gTWF0aC5mbG9vcihNYXRoLnBvdygxNiwgOCkgKiBNYXRoLnJhbmRvbSgpKS50b1N0cmluZygxNik7XG4gICAgICAgIHZhciB3Y2FjaGUgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYWNoZUtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gY2FjaGVLZXlzW2ldO1xuICAgICAgICAgICAgd2NhY2hlW2tleV0gPSBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlc1t3a2V5XSA9IFtcbiAgICAgICAgICAgICdmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsnICsgZm4gKyAnKHNlbGYpOyB9JyxcbiAgICAgICAgICAgIHdjYWNoZVxuICAgICAgICBdO1xuICAgIH1cbiAgICB2YXIgc2tleSA9IE1hdGguZmxvb3IoTWF0aC5wb3coMTYsIDgpICogTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoMTYpO1xuXG4gICAgdmFyIHNjYWNoZSA9IHt9OyBzY2FjaGVbd2tleV0gPSB3a2V5O1xuICAgIHNvdXJjZXNbc2tleV0gPSBbXG4gICAgICAgICdmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsnICtcbiAgICAgICAgICAgIC8vIHRyeSB0byBjYWxsIGRlZmF1bHQgaWYgZGVmaW5lZCB0byBhbHNvIHN1cHBvcnQgYmFiZWwgZXNtb2R1bGUgZXhwb3J0c1xuICAgICAgICAgICAgJ3ZhciBmID0gcmVxdWlyZSgnICsgc3RyaW5naWZ5KHdrZXkpICsgJyk7JyArXG4gICAgICAgICAgICAnKGYuZGVmYXVsdCA/IGYuZGVmYXVsdCA6IGYpKHNlbGYpOycgK1xuICAgICAgICAnfScsXG4gICAgICAgIHNjYWNoZVxuICAgIF07XG5cbiAgICB2YXIgd29ya2VyU291cmNlcyA9IHt9O1xuICAgIHJlc29sdmVTb3VyY2VzKHNrZXkpO1xuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVNvdXJjZXMoa2V5KSB7XG4gICAgICAgIHdvcmtlclNvdXJjZXNba2V5XSA9IHRydWU7XG5cbiAgICAgICAgZm9yICh2YXIgZGVwUGF0aCBpbiBzb3VyY2VzW2tleV1bMV0pIHtcbiAgICAgICAgICAgIHZhciBkZXBLZXkgPSBzb3VyY2VzW2tleV1bMV1bZGVwUGF0aF07XG4gICAgICAgICAgICBpZiAoIXdvcmtlclNvdXJjZXNbZGVwS2V5XSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVTb3VyY2VzKGRlcEtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3JjID0gJygnICsgYnVuZGxlRm4gKyAnKSh7J1xuICAgICAgICArIE9iamVjdC5rZXlzKHdvcmtlclNvdXJjZXMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5KGtleSkgKyAnOlsnXG4gICAgICAgICAgICAgICAgKyBzb3VyY2VzW2tleV1bMF1cbiAgICAgICAgICAgICAgICArICcsJyArIHN0cmluZ2lmeShzb3VyY2VzW2tleV1bMV0pICsgJ10nXG4gICAgICAgICAgICA7XG4gICAgICAgIH0pLmpvaW4oJywnKVxuICAgICAgICArICd9LHt9LFsnICsgc3RyaW5naWZ5KHNrZXkpICsgJ10pJ1xuICAgIDtcblxuICAgIHZhciBVUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwgfHwgd2luZG93Lm1velVSTCB8fCB3aW5kb3cubXNVUkw7XG5cbiAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtzcmNdLCB7IHR5cGU6ICd0ZXh0L2phdmFzY3JpcHQnIH0pO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYmFyZSkgeyByZXR1cm4gYmxvYjsgfVxuICAgIHZhciB3b3JrZXJVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgIHZhciB3b3JrZXIgPSBuZXcgV29ya2VyKHdvcmtlclVybCk7XG4gICAgd29ya2VyLm9iamVjdFVSTCA9IHdvcmtlclVybDtcbiAgICByZXR1cm4gd29ya2VyO1xufTtcbiIsImltcG9ydCBsaWIgZnJvbSBcIi4vbWFpblwiO1xubW9kdWxlLmV4cG9ydHMgPSBsaWI7XG4iLCIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJFeGlmUmVhZGVyXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIkV4aWZSZWFkZXJcIl0gPSBmYWN0b3J5KCk7XG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4vKioqKioqLyBcdFx0cmV0dXJuIG5zO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2V4aWYtcmVhZGVyLmpzXCIpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoe1xuXG4vKioqLyBcIi4vc3JjL2J5dGUtb3JkZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9ieXRlLW9yZGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwczovL21vemlsbGEub3JnL01QTC8yLjAvLiAqL1xudmFyIExJVFRMRV9FTkRJQU4gPSAweDQ5NDk7XG52YXIgQklHX0VORElBTiA9IDB4NGQ0ZDtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICBCSUdfRU5ESUFOOiBCSUdfRU5ESUFOLFxuICBMSVRUTEVfRU5ESUFOOiBMSVRUTEVfRU5ESUFOLFxuICBnZXRCeXRlT3JkZXI6IGdldEJ5dGVPcmRlclxufSk7XG5cbmZ1bmN0aW9uIGdldEJ5dGVPcmRlcihkYXRhVmlldywgdGlmZkhlYWRlck9mZnNldCkge1xuICBpZiAoZGF0YVZpZXcuZ2V0VWludDE2KHRpZmZIZWFkZXJPZmZzZXQpID09PSBMSVRUTEVfRU5ESUFOKSB7XG4gICAgcmV0dXJuIExJVFRMRV9FTkRJQU47XG4gIH0gZWxzZSBpZiAoZGF0YVZpZXcuZ2V0VWludDE2KHRpZmZIZWFkZXJPZmZzZXQpID09PSBCSUdfRU5ESUFOKSB7XG4gICAgcmV0dXJuIEJJR19FTkRJQU47XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgYnl0ZSBvcmRlciB2YWx1ZS4gRmF1bHR5IGltYWdlLicpO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb25zdGFudHMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnN0YW50cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwczovL21vemlsbGEub3JnL01QTC8yLjAvLiAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gIFVTRV9GSUxFOiB0cnVlLFxuICBVU0VfUE5HX0ZJTEU6IHRydWUsXG4gIFVTRV9FWElGOiB0cnVlLFxuICBVU0VfSVBUQzogdHJ1ZSxcbiAgVVNFX1hNUDogdHJ1ZSxcbiAgVVNFX0lDQzogdHJ1ZSxcbiAgVVNFX1RIVU1CTkFJTDogdHJ1ZSxcbiAgVVNFX1RJRkY6IHRydWUsXG4gIFVTRV9KUEVHOiB0cnVlLFxuICBVU0VfUE5HOiB0cnVlLFxuICBVU0VfSEVJQzogdHJ1ZSxcbiAgVVNFX1dFQlA6IHRydWVcbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kYXRhdmlldy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9kYXRhdmlldy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBEYXRhVmlldzsgfSk7XG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxudmFyIERhdGFWaWV3ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRGF0YVZpZXcoYnVmZmVyKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERhdGFWaWV3KTtcblxuICAgIGlmIChidWZmZXJUeXBlSXNVbnN1cHBvcnRlZChidWZmZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGFWaWV3OiBQYXNzZWQgYnVmZmVyIHR5cGUgaXMgdW5zdXBwb3J0ZWQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgdGhpcy5ieXRlTGVuZ3RoID0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKERhdGFWaWV3LCBbe1xuICAgIGtleTogXCJnZXRVaW50OFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRVaW50OChvZmZzZXQpIHtcbiAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VWludDE2XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFVpbnQxNihvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgICAgaWYgKGxpdHRsZUVuZGlhbikge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIucmVhZFVJbnQxNkxFKG9mZnNldCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VWludDMyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFVpbnQzMihvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgICAgaWYgKGxpdHRsZUVuZGlhbikge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIucmVhZFVJbnQzMkxFKG9mZnNldCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SW50MzJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW50MzIob2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICAgIGlmIChsaXR0bGVFbmRpYW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLnJlYWRJbnQzMkxFKG9mZnNldCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5yZWFkSW50MzJCRShvZmZzZXQpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEYXRhVmlldztcbn0oKTtcblxuXG5cbmZ1bmN0aW9uIGJ1ZmZlclR5cGVJc1Vuc3VwcG9ydGVkKGJ1ZmZlcikge1xuICByZXR1cm4gX3R5cGVvZihidWZmZXIpICE9PSAnb2JqZWN0JyB8fCBidWZmZXIubGVuZ3RoID09PSB1bmRlZmluZWQgfHwgYnVmZmVyLnJlYWRVSW50OCA9PT0gdW5kZWZpbmVkIHx8IGJ1ZmZlci5yZWFkVUludDE2TEUgPT09IHVuZGVmaW5lZCB8fCBidWZmZXIucmVhZFVJbnQxNkJFID09PSB1bmRlZmluZWQgfHwgYnVmZmVyLnJlYWRVSW50MzJMRSA9PT0gdW5kZWZpbmVkIHx8IGJ1ZmZlci5yZWFkVUludDMyQkUgPT09IHVuZGVmaW5lZCB8fCBidWZmZXIucmVhZEludDMyTEUgPT09IHVuZGVmaW5lZCB8fCBidWZmZXIucmVhZEludDMyQkUgPT09IHVuZGVmaW5lZDtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZG9tLXBhcnNlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2RvbS1wYXJzZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgZ2V0OiBnZXRcbn0pO1xuXG5mdW5jdGlvbiBnZXQoKSB7XG4gIGlmICh0eXBlb2YgRE9NUGFyc2VyICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBET01QYXJzZXI7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBldmFsKCdyZXF1aXJlJykoJ3htbGRvbScpLkRPTVBhcnNlcjsgLy8gVGhpcyBzdG9wcyBXZWJwYWNrIGZyb20gcmVwbGFjaW5nIHRoZSByZXF1aXJlIHdpdGggYSBnZW5lcmljIGltcG9ydCBhbmQgYnVuZGxpbmcgdGhlIG1vZHVsZS5cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2Vycm9ycy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZXJyb3JzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uICovXG5cbi8qKlxuICogVGhyb3duIHdoZW4gbm8gRXhpZiBtZXRhZGF0YSB3YXMgZm91bmQgZm9yIHRoZSBnaXZlbiBpbWFnZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gTWV0YWRhdGFNaXNzaW5nRXJyb3IobWVzc2FnZSkge1xuICB0aGlzLm5hbWUgPSAnTWV0YWRhdGFNaXNzaW5nRXJyb3InO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdObyBFeGlmIGRhdGEnO1xuICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG59XG5cbk1ldGFkYXRhTWlzc2luZ0Vycm9yLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gIE1ldGFkYXRhTWlzc2luZ0Vycm9yOiBNZXRhZGF0YU1pc3NpbmdFcnJvclxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2V4aWYtcmVhZGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2V4aWYtcmVhZGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQsIGVycm9ycywgbG9hZCwgbG9hZFZpZXcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZXJyb3JzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZXJyb3JzOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJsb2FkXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbG9hZDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibG9hZFZpZXdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBsb2FkVmlldzsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzLmpzICovIFwiLi9zcmMvdXRpbHMuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RhdGF2aWV3X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2RhdGF2aWV3LmpzICovIFwiLi9zcmMvZGF0YXZpZXcuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbnN0YW50c19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb25zdGFudHMuanMgKi8gXCIuL3NyYy9jb25zdGFudHMuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3RhZ19uYW1lc191dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90YWctbmFtZXMtdXRpbHMuanMgKi8gXCIuL3NyYy90YWctbmFtZXMtdXRpbHMuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ltYWdlX2hlYWRlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbWFnZS1oZWFkZXIuanMgKi8gXCIuL3NyYy9pbWFnZS1oZWFkZXIuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3RhZ3NfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdGFncy5qcyAqLyBcIi4vc3JjL3RhZ3MuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZpbGVfdGFnc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9maWxlLXRhZ3MuanMgKi8gXCIuL3NyYy9maWxlLXRhZ3MuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2lwdGNfdGFnc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcHRjLXRhZ3MuanMgKi8gXCIuL3NyYy9pcHRjLXRhZ3MuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3htcF90YWdzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3htcC10YWdzLmpzICovIFwiLi9zcmMveG1wLXRhZ3MuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ljY190YWdzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ljYy10YWdzLmpzICovIFwiLi9zcmMvaWNjLXRhZ3MuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3BuZ19maWxlX3RhZ3NfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3BuZy1maWxlLXRhZ3MuanMgKi8gXCIuL3NyYy9wbmctZmlsZS10YWdzLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90aHVtYm5haWxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RodW1ibmFpbC5qcyAqLyBcIi4vc3JjL3RodW1ibmFpbC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXJyb3JzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9lcnJvcnMuanMgKi8gXCIuL3NyYy9lcnJvcnMuanNcIik7XG4vKipcbiAqIEV4aWZSZWFkZXJcbiAqIGh0dHA6Ly9naXRodWIuY29tL21hdHRpYXN3L2V4aWZyZWFkZXJcbiAqIENvcHlyaWdodCAoQykgMjAxMS0yMDIwICBNYXR0aWFzIFdhbGxhbmRlciA8bWF0dGlhc0B3YWxsYW5kZXIuZXU+XG4gKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqL1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICBsb2FkOiBsb2FkLFxuICBsb2FkVmlldzogbG9hZFZpZXcsXG4gIGVycm9yczogX2Vycm9yc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfX1tcImRlZmF1bHRcIl1cbn0pO1xudmFyIGVycm9ycyA9IF9lcnJvcnNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX19bXCJkZWZhdWx0XCJdO1xuZnVuY3Rpb24gbG9hZChkYXRhKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7XG4gICAgZXhwYW5kZWQ6IGZhbHNlXG4gIH07XG5cbiAgaWYgKGlzTm9kZUJ1ZmZlcihkYXRhKSkge1xuICAgIC8vIEZpbGUgZGF0YSByZWFkIGluIE5vZGUgY2FuIHNoYXJlIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlciB3aXRoIG90aGVyXG4gICAgLy8gZGF0YS4gVGhlcmVmb3JlIGl0J3Mgc2FmZXN0IHRvIGdldCBhIG5ldyBvbmUgdG8gYXZvaWQgd2VpcmQgYnVncy5cbiAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSkuYnVmZmVyO1xuICB9XG5cbiAgcmV0dXJuIGxvYWRWaWV3KGdldERhdGFWaWV3KGRhdGEpLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gaXNOb2RlQnVmZmVyKGRhdGEpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKGRhdGEpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERhdGFWaWV3KGRhdGEpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IERhdGFWaWV3KGRhdGEpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBuZXcgX2RhdGF2aWV3X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdKGRhdGEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxvYWRWaWV3KGRhdGFWaWV3KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7XG4gICAgZXhwYW5kZWQ6IGZhbHNlXG4gIH07XG4gIHZhciBmb3VuZE1ldGFEYXRhID0gZmFsc2U7XG4gIHZhciB0YWdzID0ge307XG5cbiAgdmFyIF9JbWFnZUhlYWRlciRwYXJzZUFwcCA9IF9pbWFnZV9oZWFkZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImRlZmF1bHRcIl0ucGFyc2VBcHBNYXJrZXJzKGRhdGFWaWV3KSxcbiAgICAgIGZpbGVEYXRhT2Zmc2V0ID0gX0ltYWdlSGVhZGVyJHBhcnNlQXBwLmZpbGVEYXRhT2Zmc2V0LFxuICAgICAgdGlmZkhlYWRlck9mZnNldCA9IF9JbWFnZUhlYWRlciRwYXJzZUFwcC50aWZmSGVhZGVyT2Zmc2V0LFxuICAgICAgaXB0Y0RhdGFPZmZzZXQgPSBfSW1hZ2VIZWFkZXIkcGFyc2VBcHAuaXB0Y0RhdGFPZmZzZXQsXG4gICAgICB4bXBDaHVua3MgPSBfSW1hZ2VIZWFkZXIkcGFyc2VBcHAueG1wQ2h1bmtzLFxuICAgICAgaWNjQ2h1bmtzID0gX0ltYWdlSGVhZGVyJHBhcnNlQXBwLmljY0NodW5rcyxcbiAgICAgIHBuZ0hlYWRlck9mZnNldCA9IF9JbWFnZUhlYWRlciRwYXJzZUFwcC5wbmdIZWFkZXJPZmZzZXQ7XG5cbiAgaWYgKF9jb25zdGFudHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0uVVNFX0pQRUcgJiYgX2NvbnN0YW50c19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXS5VU0VfRklMRSAmJiBoYXNGaWxlRGF0YShmaWxlRGF0YU9mZnNldCkpIHtcbiAgICBmb3VuZE1ldGFEYXRhID0gdHJ1ZTtcbiAgICB2YXIgcmVhZFRhZ3MgPSBfZmlsZV90YWdzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJkZWZhdWx0XCJdLnJlYWQoZGF0YVZpZXcsIGZpbGVEYXRhT2Zmc2V0KTtcblxuICAgIGlmIChvcHRpb25zLmV4cGFuZGVkKSB7XG4gICAgICB0YWdzLmZpbGUgPSByZWFkVGFncztcbiAgICB9IGVsc2Uge1xuICAgICAgdGFncyA9IE9iamVjdChfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIm9iamVjdEFzc2lnblwiXSkoe30sIHRhZ3MsIHJlYWRUYWdzKTtcbiAgICB9XG4gIH1cblxuICBpZiAoX2NvbnN0YW50c19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXS5VU0VfRVhJRiAmJiBoYXNFeGlmRGF0YSh0aWZmSGVhZGVyT2Zmc2V0KSkge1xuICAgIGZvdW5kTWV0YURhdGEgPSB0cnVlO1xuXG4gICAgdmFyIF9yZWFkVGFncyA9IF90YWdzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJkZWZhdWx0XCJdLnJlYWQoZGF0YVZpZXcsIHRpZmZIZWFkZXJPZmZzZXQpO1xuXG4gICAgaWYgKF9yZWFkVGFncy5UaHVtYm5haWwpIHtcbiAgICAgIHRhZ3MuVGh1bWJuYWlsID0gX3JlYWRUYWdzLlRodW1ibmFpbDtcbiAgICAgIGRlbGV0ZSBfcmVhZFRhZ3MuVGh1bWJuYWlsO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmV4cGFuZGVkKSB7XG4gICAgICB0YWdzLmV4aWYgPSBfcmVhZFRhZ3M7XG4gICAgICBhZGRHcHNHcm91cCh0YWdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFncyA9IE9iamVjdChfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIm9iamVjdEFzc2lnblwiXSkoe30sIHRhZ3MsIF9yZWFkVGFncyk7XG4gICAgfVxuXG4gICAgaWYgKF9jb25zdGFudHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0uVVNFX1RJRkYgJiYgX2NvbnN0YW50c19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXS5VU0VfSVBUQyAmJiBfcmVhZFRhZ3NbJ0lQVEMtTkFBJ10gJiYgIWhhc0lwdGNEYXRhKGlwdGNEYXRhT2Zmc2V0KSkge1xuICAgICAgdmFyIHJlYWRJcHRjVGFncyA9IF9pcHRjX3RhZ3NfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcImRlZmF1bHRcIl0ucmVhZChfcmVhZFRhZ3NbJ0lQVEMtTkFBJ10udmFsdWUsIDApO1xuXG4gICAgICBpZiAob3B0aW9ucy5leHBhbmRlZCkge1xuICAgICAgICB0YWdzLmlwdGMgPSByZWFkSXB0Y1RhZ3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YWdzID0gT2JqZWN0KF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wib2JqZWN0QXNzaWduXCJdKSh7fSwgdGFncywgcmVhZElwdGNUYWdzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoX2NvbnN0YW50c19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXS5VU0VfVElGRiAmJiBfY29uc3RhbnRzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdLlVTRV9YTVAgJiYgX3JlYWRUYWdzWydBcHBsaWNhdGlvbk5vdGVzJ10gJiYgIWhhc1htcERhdGEoeG1wQ2h1bmtzKSkge1xuICAgICAgdmFyIHJlYWRYbXBUYWdzID0gX3htcF90YWdzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bXCJkZWZhdWx0XCJdLnJlYWQoT2JqZWN0KF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZ2V0U3RyaW5nVmFsdWVGcm9tQXJyYXlcIl0pKF9yZWFkVGFnc1snQXBwbGljYXRpb25Ob3RlcyddLnZhbHVlKSk7XG5cbiAgICAgIGlmIChvcHRpb25zLmV4cGFuZGVkKSB7XG4gICAgICAgIHRhZ3MueG1wID0gcmVhZFhtcFRhZ3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YWdzID0gT2JqZWN0KF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wib2JqZWN0QXNzaWduXCJdKSh7fSwgdGFncywgcmVhZFhtcFRhZ3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChfY29uc3RhbnRzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdLlVTRV9USUZGICYmIF9jb25zdGFudHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0uVVNFX0lDQyAmJiBfcmVhZFRhZ3NbJ0lDQ19Qcm9maWxlJ10gJiYgIWhhc0ljY0RhdGEoaWNjQ2h1bmtzKSkge1xuICAgICAgdmFyIHJlYWRJY2NUYWdzID0gX2ljY190YWdzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bXCJkZWZhdWx0XCJdLnJlYWQoX3JlYWRUYWdzWydJQ0NfUHJvZmlsZSddLnZhbHVlLCBbe1xuICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgIGxlbmd0aDogX3JlYWRUYWdzWydJQ0NfUHJvZmlsZSddLnZhbHVlLmxlbmd0aCxcbiAgICAgICAgY2h1bmtOdW1iZXI6IDEsXG4gICAgICAgIGNodW5rc1RvdGFsOiAxXG4gICAgICB9XSk7XG5cbiAgICAgIGlmIChvcHRpb25zLmV4cGFuZGVkKSB7XG4gICAgICAgIHRhZ3MuaWNjID0gcmVhZEljY1RhZ3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YWdzID0gT2JqZWN0KF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wib2JqZWN0QXNzaWduXCJdKSh7fSwgdGFncywgcmVhZEljY1RhZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChfY29uc3RhbnRzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdLlVTRV9KUEVHICYmIF9jb25zdGFudHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0uVVNFX0lQVEMgJiYgaGFzSXB0Y0RhdGEoaXB0Y0RhdGFPZmZzZXQpKSB7XG4gICAgZm91bmRNZXRhRGF0YSA9IHRydWU7XG5cbiAgICB2YXIgX3JlYWRUYWdzMiA9IF9pcHRjX3RhZ3NfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcImRlZmF1bHRcIl0ucmVhZChkYXRhVmlldywgaXB0Y0RhdGFPZmZzZXQpO1xuXG4gICAgaWYgKG9wdGlvbnMuZXhwYW5kZWQpIHtcbiAgICAgIHRhZ3MuaXB0YyA9IF9yZWFkVGFnczI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhZ3MgPSBPYmplY3QoX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJvYmplY3RBc3NpZ25cIl0pKHt9LCB0YWdzLCBfcmVhZFRhZ3MyKTtcbiAgICB9XG4gIH1cblxuICBpZiAoX2NvbnN0YW50c19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXS5VU0VfWE1QICYmIGhhc1htcERhdGEoeG1wQ2h1bmtzKSkge1xuICAgIGZvdW5kTWV0YURhdGEgPSB0cnVlO1xuXG4gICAgdmFyIF9yZWFkVGFnczMgPSBfeG1wX3RhZ3NfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcImRlZmF1bHRcIl0ucmVhZChkYXRhVmlldywgeG1wQ2h1bmtzKTtcblxuICAgIGlmIChvcHRpb25zLmV4cGFuZGVkKSB7XG4gICAgICB0YWdzLnhtcCA9IF9yZWFkVGFnczM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhZ3MgPSBPYmplY3QoX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJvYmplY3RBc3NpZ25cIl0pKHt9LCB0YWdzLCBfcmVhZFRhZ3MzKTtcbiAgICB9XG4gIH1cblxuICBpZiAoKF9jb25zdGFudHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0uVVNFX0pQRUcgfHwgX2NvbnN0YW50c19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXS5VU0VfV0VCUCkgJiYgX2NvbnN0YW50c19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXS5VU0VfSUNDICYmIGhhc0ljY0RhdGEoaWNjQ2h1bmtzKSkge1xuICAgIGZvdW5kTWV0YURhdGEgPSB0cnVlO1xuXG4gICAgdmFyIF9yZWFkVGFnczQgPSBfaWNjX3RhZ3NfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1tcImRlZmF1bHRcIl0ucmVhZChkYXRhVmlldywgaWNjQ2h1bmtzKTtcblxuICAgIGlmIChvcHRpb25zLmV4cGFuZGVkKSB7XG4gICAgICB0YWdzLmljYyA9IF9yZWFkVGFnczQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhZ3MgPSBPYmplY3QoX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJvYmplY3RBc3NpZ25cIl0pKHt9LCB0YWdzLCBfcmVhZFRhZ3M0KTtcbiAgICB9XG4gIH1cblxuICBpZiAoX2NvbnN0YW50c19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXS5VU0VfUE5HICYmIF9jb25zdGFudHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0uVVNFX1BOR19GSUxFICYmIGhhc1BuZ0ZpbGVEYXRhKHBuZ0hlYWRlck9mZnNldCkpIHtcbiAgICBmb3VuZE1ldGFEYXRhID0gdHJ1ZTtcblxuICAgIHZhciBfcmVhZFRhZ3M1ID0gX3BuZ19maWxlX3RhZ3NfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bXCJkZWZhdWx0XCJdLnJlYWQoZGF0YVZpZXcsIHBuZ0hlYWRlck9mZnNldCk7XG5cbiAgICBpZiAob3B0aW9ucy5leHBhbmRlZCkge1xuICAgICAgdGFncy5wbmdGaWxlID0gX3JlYWRUYWdzNTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFncyA9IE9iamVjdChfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIm9iamVjdEFzc2lnblwiXSkoe30sIHRhZ3MsIF9yZWFkVGFnczUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB0aHVtYm5haWwgPSAoX2NvbnN0YW50c19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXS5VU0VfSlBFRyB8fCBfY29uc3RhbnRzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdLlVTRV9XRUJQKSAmJiBfY29uc3RhbnRzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdLlVTRV9FWElGICYmIF9jb25zdGFudHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0uVVNFX1RIVU1CTkFJTCAmJiBfdGh1bWJuYWlsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fW1wiZGVmYXVsdFwiXS5nZXQoZGF0YVZpZXcsIHRhZ3MuVGh1bWJuYWlsLCB0aWZmSGVhZGVyT2Zmc2V0KTtcblxuICBpZiAodGh1bWJuYWlsKSB7XG4gICAgZm91bmRNZXRhRGF0YSA9IHRydWU7XG4gICAgdGFncy5UaHVtYm5haWwgPSB0aHVtYm5haWw7XG4gIH0gZWxzZSB7XG4gICAgZGVsZXRlIHRhZ3MuVGh1bWJuYWlsO1xuICB9XG5cbiAgaWYgKCFmb3VuZE1ldGFEYXRhKSB7XG4gICAgdGhyb3cgbmV3IF9lcnJvcnNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX19bXCJkZWZhdWx0XCJdLk1ldGFkYXRhTWlzc2luZ0Vycm9yKCk7XG4gIH1cblxuICByZXR1cm4gdGFncztcbn1cblxuZnVuY3Rpb24gaGFzRmlsZURhdGEoZmlsZURhdGFPZmZzZXQpIHtcbiAgcmV0dXJuIGZpbGVEYXRhT2Zmc2V0ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc0V4aWZEYXRhKHRpZmZIZWFkZXJPZmZzZXQpIHtcbiAgcmV0dXJuIHRpZmZIZWFkZXJPZmZzZXQgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gYWRkR3BzR3JvdXAodGFncykge1xuICBpZiAodGFncy5leGlmKSB7XG4gICAgaWYgKHRhZ3MuZXhpZi5HUFNMYXRpdHVkZSAmJiB0YWdzLmV4aWYuR1BTTGF0aXR1ZGVSZWYpIHtcbiAgICAgIHRhZ3MuZ3BzID0gdGFncy5ncHMgfHwge307XG4gICAgICB0YWdzLmdwcy5MYXRpdHVkZSA9IE9iamVjdChfdGFnX25hbWVzX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJnZXRDYWxjdWxhdGVkR3BzVmFsdWVcIl0pKHRhZ3MuZXhpZi5HUFNMYXRpdHVkZS52YWx1ZSk7XG5cbiAgICAgIGlmICh0YWdzLmV4aWYuR1BTTGF0aXR1ZGVSZWYudmFsdWUuam9pbignJykgPT09ICdTJykge1xuICAgICAgICB0YWdzLmdwcy5MYXRpdHVkZSA9IC10YWdzLmdwcy5MYXRpdHVkZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGFncy5leGlmLkdQU0xvbmdpdHVkZSAmJiB0YWdzLmV4aWYuR1BTTG9uZ2l0dWRlUmVmKSB7XG4gICAgICB0YWdzLmdwcyA9IHRhZ3MuZ3BzIHx8IHt9O1xuICAgICAgdGFncy5ncHMuTG9uZ2l0dWRlID0gT2JqZWN0KF90YWdfbmFtZXNfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImdldENhbGN1bGF0ZWRHcHNWYWx1ZVwiXSkodGFncy5leGlmLkdQU0xvbmdpdHVkZS52YWx1ZSk7XG5cbiAgICAgIGlmICh0YWdzLmV4aWYuR1BTTG9uZ2l0dWRlUmVmLnZhbHVlLmpvaW4oJycpID09PSAnVycpIHtcbiAgICAgICAgdGFncy5ncHMuTG9uZ2l0dWRlID0gLXRhZ3MuZ3BzLkxvbmdpdHVkZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGFncy5leGlmLkdQU0FsdGl0dWRlICYmIHRhZ3MuZXhpZi5HUFNBbHRpdHVkZVJlZikge1xuICAgICAgdGFncy5ncHMgPSB0YWdzLmdwcyB8fCB7fTtcbiAgICAgIHRhZ3MuZ3BzLkFsdGl0dWRlID0gdGFncy5leGlmLkdQU0FsdGl0dWRlLnZhbHVlWzBdIC8gdGFncy5leGlmLkdQU0FsdGl0dWRlLnZhbHVlWzFdO1xuXG4gICAgICBpZiAodGFncy5leGlmLkdQU0FsdGl0dWRlUmVmLnZhbHVlID09PSAxKSB7XG4gICAgICAgIHRhZ3MuZ3BzLkFsdGl0dWRlID0gLXRhZ3MuZ3BzLkFsdGl0dWRlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNJcHRjRGF0YShpcHRjRGF0YU9mZnNldCkge1xuICByZXR1cm4gaXB0Y0RhdGFPZmZzZXQgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzWG1wRGF0YSh4bXBDaHVua3MpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoeG1wQ2h1bmtzKSAmJiB4bXBDaHVua3MubGVuZ3RoID4gMDtcbn1cblxuZnVuY3Rpb24gaGFzSWNjRGF0YShpY2NEYXRhT2Zmc2V0cykge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShpY2NEYXRhT2Zmc2V0cykgJiYgaWNjRGF0YU9mZnNldHMubGVuZ3RoID4gMDtcbn1cblxuZnVuY3Rpb24gaGFzUG5nRmlsZURhdGEocG5nRmlsZURhdGFPZmZzZXQpIHtcbiAgcmV0dXJuIHBuZ0ZpbGVEYXRhT2Zmc2V0ICE9PSB1bmRlZmluZWQ7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2ZpbGUtdGFncy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZmlsZS10YWdzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90eXBlcy5qcyAqLyBcIi4vc3JjL3R5cGVzLmpzXCIpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uICovXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICByZWFkOiByZWFkXG59KTtcblxuZnVuY3Rpb24gcmVhZChkYXRhVmlldywgZmlsZURhdGFPZmZzZXQpIHtcbiAgdmFyIGxlbmd0aCA9IGdldExlbmd0aChkYXRhVmlldywgZmlsZURhdGFPZmZzZXQpO1xuICB2YXIgbnVtYmVyT2ZDb2xvckNvbXBvbmVudHMgPSBnZXROdW1iZXJPZkNvbG9yQ29tcG9uZW50cyhkYXRhVmlldywgZmlsZURhdGFPZmZzZXQsIGxlbmd0aCk7XG4gIHJldHVybiB7XG4gICAgJ0JpdHMgUGVyIFNhbXBsZSc6IGdldERhdGFQcmVjaXNpb24oZGF0YVZpZXcsIGZpbGVEYXRhT2Zmc2V0LCBsZW5ndGgpLFxuICAgICdJbWFnZSBIZWlnaHQnOiBnZXRJbWFnZUhlaWdodChkYXRhVmlldywgZmlsZURhdGFPZmZzZXQsIGxlbmd0aCksXG4gICAgJ0ltYWdlIFdpZHRoJzogZ2V0SW1hZ2VXaWR0aChkYXRhVmlldywgZmlsZURhdGFPZmZzZXQsIGxlbmd0aCksXG4gICAgJ0NvbG9yIENvbXBvbmVudHMnOiBudW1iZXJPZkNvbG9yQ29tcG9uZW50cyxcbiAgICAnU3Vic2FtcGxpbmcnOiBudW1iZXJPZkNvbG9yQ29tcG9uZW50cyAmJiBnZXRTdWJzYW1wbGluZyhkYXRhVmlldywgZmlsZURhdGFPZmZzZXQsIG51bWJlck9mQ29sb3JDb21wb25lbnRzLnZhbHVlLCBsZW5ndGgpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldExlbmd0aChkYXRhVmlldywgZmlsZURhdGFPZmZzZXQpIHtcbiAgcmV0dXJuIF90eXBlc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXS5nZXRTaG9ydEF0KGRhdGFWaWV3LCBmaWxlRGF0YU9mZnNldCk7XG59XG5cbmZ1bmN0aW9uIGdldERhdGFQcmVjaXNpb24oZGF0YVZpZXcsIGZpbGVEYXRhT2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIE9GRlNFVCA9IDI7XG4gIHZhciBTSVpFID0gMTtcblxuICBpZiAoT0ZGU0VUICsgU0laRSA+IGxlbmd0aCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgdmFsdWUgPSBfdHlwZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0uZ2V0Qnl0ZUF0KGRhdGFWaWV3LCBmaWxlRGF0YU9mZnNldCArIE9GRlNFVCk7XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGRlc2NyaXB0aW9uOiAnJyArIHZhbHVlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEltYWdlSGVpZ2h0KGRhdGFWaWV3LCBmaWxlRGF0YU9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBPRkZTRVQgPSAzO1xuICB2YXIgU0laRSA9IDI7XG5cbiAgaWYgKE9GRlNFVCArIFNJWkUgPiBsZW5ndGgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gX3R5cGVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdLmdldFNob3J0QXQoZGF0YVZpZXcsIGZpbGVEYXRhT2Zmc2V0ICsgT0ZGU0VUKTtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgZGVzY3JpcHRpb246IFwiXCIuY29uY2F0KHZhbHVlLCBcInB4XCIpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEltYWdlV2lkdGgoZGF0YVZpZXcsIGZpbGVEYXRhT2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIE9GRlNFVCA9IDU7XG4gIHZhciBTSVpFID0gMjtcblxuICBpZiAoT0ZGU0VUICsgU0laRSA+IGxlbmd0aCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgdmFsdWUgPSBfdHlwZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0uZ2V0U2hvcnRBdChkYXRhVmlldywgZmlsZURhdGFPZmZzZXQgKyBPRkZTRVQpO1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBkZXNjcmlwdGlvbjogXCJcIi5jb25jYXQodmFsdWUsIFwicHhcIilcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0TnVtYmVyT2ZDb2xvckNvbXBvbmVudHMoZGF0YVZpZXcsIGZpbGVEYXRhT2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIE9GRlNFVCA9IDc7XG4gIHZhciBTSVpFID0gMTtcblxuICBpZiAoT0ZGU0VUICsgU0laRSA+IGxlbmd0aCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgdmFsdWUgPSBfdHlwZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0uZ2V0Qnl0ZUF0KGRhdGFWaWV3LCBmaWxlRGF0YU9mZnNldCArIE9GRlNFVCk7XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGRlc2NyaXB0aW9uOiAnJyArIHZhbHVlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFN1YnNhbXBsaW5nKGRhdGFWaWV3LCBmaWxlRGF0YU9mZnNldCwgbnVtYmVyT2ZDb2xvckNvbXBvbmVudHMsIGxlbmd0aCkge1xuICB2YXIgT0ZGU0VUID0gODtcbiAgdmFyIFNJWkUgPSAzICogbnVtYmVyT2ZDb2xvckNvbXBvbmVudHM7XG5cbiAgaWYgKE9GRlNFVCArIFNJWkUgPiBsZW5ndGgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIGNvbXBvbmVudHMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bWJlck9mQ29sb3JDb21wb25lbnRzOyBpKyspIHtcbiAgICB2YXIgY29tcG9uZW50T2Zmc2V0ID0gZmlsZURhdGFPZmZzZXQgKyBPRkZTRVQgKyBpICogMztcbiAgICBjb21wb25lbnRzLnB1c2goW190eXBlc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXS5nZXRCeXRlQXQoZGF0YVZpZXcsIGNvbXBvbmVudE9mZnNldCksIF90eXBlc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXS5nZXRCeXRlQXQoZGF0YVZpZXcsIGNvbXBvbmVudE9mZnNldCArIDEpLCBfdHlwZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0uZ2V0Qnl0ZUF0KGRhdGFWaWV3LCBjb21wb25lbnRPZmZzZXQgKyAyKV0pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogY29tcG9uZW50cyxcbiAgICBkZXNjcmlwdGlvbjogY29tcG9uZW50cy5sZW5ndGggPiAxID8gZ2V0Q29tcG9uZW50SWRzKGNvbXBvbmVudHMpICsgZ2V0U2FtcGxpbmdUeXBlKGNvbXBvbmVudHMpIDogJydcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50SWRzKGNvbXBvbmVudHMpIHtcbiAgdmFyIGlkcyA9IHtcbiAgICAweDAxOiAnWScsXG4gICAgMHgwMjogJ0NiJyxcbiAgICAweDAzOiAnQ3InLFxuICAgIDB4MDQ6ICdJJyxcbiAgICAweDA1OiAnUSdcbiAgfTtcbiAgcmV0dXJuIGNvbXBvbmVudHMubWFwKGZ1bmN0aW9uIChjb21wb250ZW50KSB7XG4gICAgcmV0dXJuIGlkc1tjb21wb250ZW50WzBdXTtcbiAgfSkuam9pbignJyk7XG59XG5cbmZ1bmN0aW9uIGdldFNhbXBsaW5nVHlwZShjb21wb25lbnRzKSB7XG4gIHZhciB0eXBlcyA9IHtcbiAgICAweDExOiAnNDo0OjQgKDEgMSknLFxuICAgIDB4MTI6ICc0OjQ6MCAoMSAyKScsXG4gICAgMHgxNDogJzQ6NDoxICgxIDQpJyxcbiAgICAweDIxOiAnNDoyOjIgKDIgMSknLFxuICAgIDB4MjI6ICc0OjI6MCAoMiAyKScsXG4gICAgMHgyNDogJzQ6MjoxICgyIDQpJyxcbiAgICAweDQxOiAnNDoxOjEgKDQgMSknLFxuICAgIDB4NDI6ICc0OjE6MCAoNCAyKSdcbiAgfTtcblxuICBpZiAoY29tcG9uZW50cy5sZW5ndGggPT09IDAgfHwgY29tcG9uZW50c1swXVsxXSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVzW2NvbXBvbmVudHNbMF1bMV1dID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICByZXR1cm4gdHlwZXNbY29tcG9uZW50c1swXVsxXV07XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2ljYy10YWctbmFtZXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9pY2MtdGFnLW5hbWVzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogaWNjVGFncywgaWNjUHJvZmlsZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJpY2NUYWdzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaWNjVGFnczsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaWNjUHJvZmlsZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGljY1Byb2ZpbGU7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlscy5qcyAqLyBcIi4vc3JjL3V0aWxzLmpzXCIpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uICovXG5cbnZhciBpY2NUYWdzID0ge1xuICAnZGVzYyc6IHtcbiAgICAnbmFtZSc6ICdJQ0MgRGVzY3JpcHRpb24nXG4gIH0sXG4gICdjcHJ0Jzoge1xuICAgICduYW1lJzogJ0lDQyBDb3B5cmlnaHQnXG4gIH0sXG4gICdkbWRkJzoge1xuICAgICduYW1lJzogJ0lDQyBEZXZpY2UgTW9kZWwgRGVzY3JpcHRpb24nXG4gIH0sXG4gICd2dWVkJzoge1xuICAgICduYW1lJzogJ0lDQyBWaWV3aW5nIENvbmRpdGlvbnMgRGVzY3JpcHRpb24nXG4gIH0sXG4gICdkbW5kJzoge1xuICAgICduYW1lJzogJ0lDQyBEZXZpY2UgTWFudWZhY3R1cmVyIGZvciBEaXNwbGF5J1xuICB9LFxuICAndGVjaCc6IHtcbiAgICAnbmFtZSc6ICdUZWNobm9sb2d5J1xuICB9XG59O1xudmFyIGljY1Byb2ZpbGUgPSB7XG4gIDQ6IHtcbiAgICAnbmFtZSc6ICdQcmVmZXJyZWQgQ01NIHR5cGUnLFxuICAgICd2YWx1ZSc6IGZ1bmN0aW9uIHZhbHVlKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICAgIHJldHVybiBPYmplY3QoX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJnZXRTdHJpbmdGcm9tRGF0YVZpZXdcIl0pKGRhdGFWaWV3LCBvZmZzZXQsIDQpO1xuICAgIH0sXG4gICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCA/IHRvQ29tcGFueSh2YWx1ZSkgOiAnJztcbiAgICB9XG4gIH0sXG4gIDg6IHtcbiAgICAnbmFtZSc6ICdQcm9maWxlIFZlcnNpb24nLFxuICAgICd2YWx1ZSc6IGZ1bmN0aW9uIHZhbHVlKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICAgIHJldHVybiBkYXRhVmlldy5nZXRVaW50OChvZmZzZXQpLnRvU3RyaW5nKDEwKSArICcuJyArIChkYXRhVmlldy5nZXRVaW50OChvZmZzZXQgKyAxKSA+PiA0KS50b1N0cmluZygxMCkgKyAnLicgKyAoZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgMSkgJSAxNikudG9TdHJpbmcoMTApO1xuICAgIH1cbiAgfSxcbiAgMTI6IHtcbiAgICAnbmFtZSc6ICdQcm9maWxlL0RldmljZSBjbGFzcycsXG4gICAgJ3ZhbHVlJzogZnVuY3Rpb24gdmFsdWUoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgICAgcmV0dXJuIE9iamVjdChfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImdldFN0cmluZ0Zyb21EYXRhVmlld1wiXSkoZGF0YVZpZXcsIG9mZnNldCwgNCk7XG4gICAgfSxcbiAgICAnZGVzY3JpcHRpb24nOiBmdW5jdGlvbiBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgc3dpdGNoICh2YWx1ZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIGNhc2UgJ3NjbnInOlxuICAgICAgICAgIHJldHVybiAnSW5wdXQgRGV2aWNlIHByb2ZpbGUnO1xuXG4gICAgICAgIGNhc2UgJ21udHInOlxuICAgICAgICAgIHJldHVybiAnRGlzcGxheSBEZXZpY2UgcHJvZmlsZSc7XG5cbiAgICAgICAgY2FzZSAncHJ0cic6XG4gICAgICAgICAgcmV0dXJuICdPdXRwdXQgRGV2aWNlIHByb2ZpbGUnO1xuXG4gICAgICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgICAgIHJldHVybiAnRGV2aWNlTGluayBwcm9maWxlJztcblxuICAgICAgICBjYXNlICdhYnN0JzpcbiAgICAgICAgICByZXR1cm4gJ0Fic3RyYWN0IHByb2ZpbGUnO1xuXG4gICAgICAgIGNhc2UgJ3NwYWMnOlxuICAgICAgICAgIHJldHVybiAnQ29sb3JTcGFjZSBwcm9maWxlJztcblxuICAgICAgICBjYXNlICdubWNsJzpcbiAgICAgICAgICByZXR1cm4gJ05hbWVkQ29sb3IgcHJvZmlsZSc7XG5cbiAgICAgICAgY2FzZSAnY2VuYyc6XG4gICAgICAgICAgcmV0dXJuICdDb2xvckVuY29kaW5nU3BhY2UgcHJvZmlsZSc7XG5cbiAgICAgICAgY2FzZSAnbWlkICc6XG4gICAgICAgICAgcmV0dXJuICdNdWx0aXBsZXhJZGVudGlmaWNhdGlvbiBwcm9maWxlJztcblxuICAgICAgICBjYXNlICdtbG5rJzpcbiAgICAgICAgICByZXR1cm4gJ011bHRpcGxleExpbmsgcHJvZmlsZSc7XG5cbiAgICAgICAgY2FzZSAnbXZpcyc6XG4gICAgICAgICAgcmV0dXJuICdNdWx0aXBsZXhWaXN1YWxpemF0aW9uIHByb2ZpbGUnO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgMTY6IHtcbiAgICAnbmFtZSc6ICdDb2xvciBTcGFjZScsXG4gICAgJ3ZhbHVlJzogZnVuY3Rpb24gdmFsdWUoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgICAgcmV0dXJuIE9iamVjdChfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImdldFN0cmluZ0Zyb21EYXRhVmlld1wiXSkoZGF0YVZpZXcsIG9mZnNldCwgNCk7XG4gICAgfVxuICB9LFxuICAyMDoge1xuICAgICduYW1lJzogJ0Nvbm5lY3Rpb24gU3BhY2UnLFxuICAgICd2YWx1ZSc6IGZ1bmN0aW9uIHZhbHVlKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICAgIHJldHVybiBPYmplY3QoX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJnZXRTdHJpbmdGcm9tRGF0YVZpZXdcIl0pKGRhdGFWaWV3LCBvZmZzZXQsIDQpO1xuICAgIH1cbiAgfSxcbiAgMjQ6IHtcbiAgICAnbmFtZSc6ICdJQ0MgUHJvZmlsZSBEYXRlJyxcbiAgICAndmFsdWUnOiBmdW5jdGlvbiB2YWx1ZShkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgICByZXR1cm4gcGFyc2VEYXRlKGRhdGFWaWV3LCBvZmZzZXQpLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuICB9LFxuICAzNjoge1xuICAgICduYW1lJzogJ0lDQyBTaWduYXR1cmUnLFxuICAgICd2YWx1ZSc6IGZ1bmN0aW9uIHZhbHVlKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICAgIHJldHVybiBzbGljZVRvU3RyaW5nKGRhdGFWaWV3LmJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIDQpKTtcbiAgICB9XG4gIH0sXG4gIDQwOiB7XG4gICAgJ25hbWUnOiAnUHJpbWFyeSBQbGF0Zm9ybScsXG4gICAgJ3ZhbHVlJzogZnVuY3Rpb24gdmFsdWUoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgICAgcmV0dXJuIE9iamVjdChfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImdldFN0cmluZ0Zyb21EYXRhVmlld1wiXSkoZGF0YVZpZXcsIG9mZnNldCwgNCk7XG4gICAgfSxcbiAgICAnZGVzY3JpcHRpb24nOiBmdW5jdGlvbiBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRvQ29tcGFueSh2YWx1ZSk7XG4gICAgfVxuICB9LFxuICA0ODoge1xuICAgICduYW1lJzogJ0RldmljZSBNYW51ZmFjdHVyZXInLFxuICAgICd2YWx1ZSc6IGZ1bmN0aW9uIHZhbHVlKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICAgIHJldHVybiBPYmplY3QoX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJnZXRTdHJpbmdGcm9tRGF0YVZpZXdcIl0pKGRhdGFWaWV3LCBvZmZzZXQsIDQpO1xuICAgIH0sXG4gICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0b0NvbXBhbnkodmFsdWUpO1xuICAgIH1cbiAgfSxcbiAgNTI6IHtcbiAgICAnbmFtZSc6ICdEZXZpY2UgTW9kZWwgTnVtYmVyJyxcbiAgICAndmFsdWUnOiBmdW5jdGlvbiB2YWx1ZShkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgICByZXR1cm4gT2JqZWN0KF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZ2V0U3RyaW5nRnJvbURhdGFWaWV3XCJdKShkYXRhVmlldywgb2Zmc2V0LCA0KTtcbiAgICB9XG4gIH0sXG4gIDY0OiB7XG4gICAgJ25hbWUnOiAnUmVuZGVyaW5nIEludGVudCcsXG4gICAgJ3ZhbHVlJzogZnVuY3Rpb24gdmFsdWUoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgICAgcmV0dXJuIGRhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgIH0sXG4gICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiAnUGVyY2VwdHVhbCc7XG5cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiAnUmVsYXRpdmUgQ29sb3JpbWV0cmljJztcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuICdTYXR1cmF0aW9uJztcblxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcmV0dXJuICdBYnNvbHV0ZSBDb2xvcmltZXRyaWMnO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgODA6IHtcbiAgICAnbmFtZSc6ICdQcm9maWxlIENyZWF0b3InLFxuICAgICd2YWx1ZSc6IGZ1bmN0aW9uIHZhbHVlKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICAgIHJldHVybiBPYmplY3QoX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJnZXRTdHJpbmdGcm9tRGF0YVZpZXdcIl0pKGRhdGFWaWV3LCBvZmZzZXQsIDQpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gcGFyc2VEYXRlKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgdmFyIHllYXIgPSBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0KTtcbiAgdmFyIG1vbnRoID0gZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldCArIDIpIC0gMTtcbiAgdmFyIGRheSA9IGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQgKyA0KTtcbiAgdmFyIGhvdXJzID0gZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldCArIDYpO1xuICB2YXIgbWludXRlcyA9IGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQgKyA4KTtcbiAgdmFyIHNlY29uZHMgPSBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0ICsgMTApO1xuICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMpKTtcbn1cblxuZnVuY3Rpb24gc2xpY2VUb1N0cmluZyhzbGljZSkge1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShzbGljZSkpO1xufVxuXG5mdW5jdGlvbiB0b0NvbXBhbnkodmFsdWUpIHtcbiAgc3dpdGNoICh2YWx1ZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnYXBwbCc6XG4gICAgICByZXR1cm4gJ0FwcGxlJztcblxuICAgIGNhc2UgJ2FkYmUnOlxuICAgICAgcmV0dXJuICdBZG9iZSc7XG5cbiAgICBjYXNlICdtc2Z0JzpcbiAgICAgIHJldHVybiAnTWljcm9zb2Z0JztcblxuICAgIGNhc2UgJ3N1bncnOlxuICAgICAgcmV0dXJuICdTdW4gTWljcm9zeXN0ZW1zJztcblxuICAgIGNhc2UgJ3NnaSc6XG4gICAgICByZXR1cm4gJ1NpbGljb24gR3JhcGhpY3MnO1xuXG4gICAgY2FzZSAndGdudCc6XG4gICAgICByZXR1cm4gJ1RhbGlnZW50JztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvaWNjLXRhZ3MuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvaWNjLXRhZ3MuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCwgcGFyc2VUYWdzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInBhcnNlVGFnc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHBhcnNlVGFnczsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ljY190YWdfbmFtZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaWNjLXRhZy1uYW1lcy5qcyAqLyBcIi4vc3JjL2ljYy10YWctbmFtZXMuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzLmpzICovIFwiLi9zcmMvdXRpbHMuanNcIik7XG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy4gKi9cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgcmVhZDogcmVhZFxufSk7XG52YXIgUFJPRklMRV9IRUFERVJfTEVOR1RIID0gODQ7XG52YXIgSUNDX1RBR19DT1VOVF9PRkZTRVQgPSAxMjg7XG52YXIgSUNDX1NJR05BVFVSRSA9ICdhY3NwJztcbnZhciBUQUdfVFlQRV9ERVNDID0gJ2Rlc2MnO1xudmFyIFRBR19UWVBFX01VTFRJX0xPQ0FMSVpFRF9VTklDT0RFX1RZUEUgPSAnbWx1Yyc7XG52YXIgVEFHX1RZUEVfVEVYVCA9ICd0ZXh0JztcbnZhciBUQUdfVFlQRV9TSUdOQVRVUkUgPSAnc2lnICc7XG52YXIgVEFHX1RBQkxFX1NJTkdMRV9UQUdfREFUQSA9IDEyOyAvLyBJQ0MgcHJvZmlsZSBkYXRhIGNhbiBiZSBsb25nZXIgdGhhbiBhcHBsaWNhdGlvbiBzZWdtZW50IG1heCBsZW5ndGggb2YgfjY0ay5cbi8vIHNvIGl0IGNhbiBiZSBzcGxpdCBpbnRvIG11bHRpcGxlIEFQUDIgc2VnbWVudHMuIEVhY2ggc2VnbWVudCBpbmNsdWRlc1xuLy8gdG90YWwgY2h1bmsgY291bnQgYW5kIGNodW5rIG51bWJlci5cbi8vIEhlcmUgd2UgcmVhZCBhbGwgY2h1bmtzIGludG8gc2luZ2xlIGNvbnRpbmlvdXMgYXJyYXkgb2YgYnl0ZXMuXG5cbmZ1bmN0aW9uIHJlYWQoZGF0YVZpZXcsIGljY0RhdGEpIHtcbiAgdHJ5IHtcbiAgICB2YXIgdG90YWxJY2NQcm9maWxlTGVuZ3RoID0gaWNjRGF0YS5yZWR1Y2UoZnVuY3Rpb24gKHN1bSwgaWNjKSB7XG4gICAgICByZXR1cm4gc3VtICsgaWNjLmxlbmd0aDtcbiAgICB9LCAwKTtcbiAgICB2YXIgaWNjQmluYXJ5RGF0YSA9IG5ldyBVaW50OEFycmF5KHRvdGFsSWNjUHJvZmlsZUxlbmd0aCk7XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgdmFyIGJ1ZmZlciA9IGdldEJ1ZmZlcihkYXRhVmlldyk7XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChjaHVua051bWJlcikge1xuICAgICAgdmFyIGljY0RhdGFDaHVuayA9IGljY0RhdGEuZmluZChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geC5jaHVua051bWJlciA9PT0gY2h1bmtOdW1iZXI7XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFpY2NEYXRhQ2h1bmspIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSUNDIGNodW5rIFwiLmNvbmNhdChjaHVua051bWJlciwgXCIgbm90IGZvdW5kXCIpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRhdGEgPSBidWZmZXIuc2xpY2UoaWNjRGF0YUNodW5rLm9mZnNldCwgaWNjRGF0YUNodW5rLm9mZnNldCArIGljY0RhdGFDaHVuay5sZW5ndGgpO1xuICAgICAgdmFyIGNodW5rRGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgICAgaWNjQmluYXJ5RGF0YS5zZXQoY2h1bmtEYXRhLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IGNodW5rRGF0YS5sZW5ndGg7XG4gICAgfTtcblxuICAgIGZvciAodmFyIGNodW5rTnVtYmVyID0gMTsgY2h1bmtOdW1iZXIgPD0gaWNjRGF0YS5sZW5ndGg7IGNodW5rTnVtYmVyKyspIHtcbiAgICAgIF9sb29wKGNodW5rTnVtYmVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VUYWdzKG5ldyBEYXRhVmlldyhpY2NCaW5hcnlEYXRhLmJ1ZmZlcikpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7fTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRCdWZmZXIoZGF0YVZpZXcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YVZpZXcpKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhVmlldyhVaW50OEFycmF5LmZyb20oZGF0YVZpZXcpLmJ1ZmZlcikuYnVmZmVyO1xuICB9XG5cbiAgcmV0dXJuIGRhdGFWaWV3LmJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gaWNjRG9lc05vdEhhdmVUYWdDb3VudChidWZmZXIpIHtcbiAgcmV0dXJuIGJ1ZmZlci5sZW5ndGggPCBJQ0NfVEFHX0NPVU5UX09GRlNFVCArIDQ7XG59XG5cbmZ1bmN0aW9uIGhhc1RhZ3NEYXRhKGJ1ZmZlciwgdGFnSGVhZGVyT2Zmc2V0KSB7XG4gIHJldHVybiBidWZmZXIubGVuZ3RoIDwgdGFnSGVhZGVyT2Zmc2V0ICsgVEFHX1RBQkxFX1NJTkdMRV9UQUdfREFUQTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUYWdzKGRhdGFWaWV3KSB7XG4gIHZhciBidWZmZXIgPSBkYXRhVmlldy5idWZmZXI7XG4gIHZhciBsZW5ndGggPSBkYXRhVmlldy5nZXRVaW50MzIoKTtcblxuICBpZiAoZGF0YVZpZXcuYnl0ZUxlbmd0aCAhPT0gbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJQ0MgcHJvZmlsZSBsZW5ndGggbm90IG1hdGNoaW5nJyk7XG4gIH1cblxuICBpZiAoZGF0YVZpZXcubGVuZ3RoIDwgUFJPRklMRV9IRUFERVJfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJQ0MgcHJvZmlsZSB0b28gc2hvcnQnKTtcbiAgfVxuXG4gIHZhciB0YWdzID0ge307XG4gIHZhciBpY2NQcm9maWxlS2V5cyA9IE9iamVjdC5rZXlzKF9pY2NfdGFnX25hbWVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpY2NQcm9maWxlXCJdKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGljY1Byb2ZpbGVLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG9mZnNldCA9IGljY1Byb2ZpbGVLZXlzW2ldO1xuICAgIHZhciBwcm9maWxlRW50cnkgPSBfaWNjX3RhZ19uYW1lc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaWNjUHJvZmlsZVwiXVtvZmZzZXRdO1xuICAgIHZhciB2YWx1ZSA9IHByb2ZpbGVFbnRyeS52YWx1ZShkYXRhVmlldywgcGFyc2VJbnQob2Zmc2V0LCAxMCkpO1xuICAgIHZhciBkZXNjcmlwdGlvbiA9IHZhbHVlO1xuXG4gICAgaWYgKHByb2ZpbGVFbnRyeS5kZXNjcmlwdGlvbikge1xuICAgICAgZGVzY3JpcHRpb24gPSBwcm9maWxlRW50cnkuZGVzY3JpcHRpb24odmFsdWUpO1xuICAgIH1cblxuICAgIHRhZ3NbcHJvZmlsZUVudHJ5Lm5hbWVdID0ge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uXG4gICAgfTtcbiAgfVxuXG4gIHZhciBzaWduYXR1cmUgPSBzbGljZVRvU3RyaW5nKGJ1ZmZlci5zbGljZSgzNiwgNDApKTtcblxuICBpZiAoc2lnbmF0dXJlICE9PSBJQ0NfU0lHTkFUVVJFKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJQ0MgcHJvZmlsZTogbWlzc2luZyBzaWduYXR1cmUnKTtcbiAgfVxuICAvKiBJQ0MgZGF0YSBpcyBpbmNvbXBsZXRlIGJ1dCB3ZSBoYXZlIGhlYWRlciBwYXJzZWQgc28gbGV0cyByZXR1cm4gaXQgKi9cblxuXG4gIGlmIChpY2NEb2VzTm90SGF2ZVRhZ0NvdW50KGJ1ZmZlcikpIHtcbiAgICByZXR1cm4gdGFncztcbiAgfVxuXG4gIHZhciB0YWdDb3VudCA9IGRhdGFWaWV3LmdldFVpbnQzMigxMjgpO1xuICB2YXIgdGFnSGVhZGVyT2Zmc2V0ID0gMTMyO1xuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCB0YWdDb3VudDsgX2krKykge1xuICAgIGlmIChoYXNUYWdzRGF0YShidWZmZXIsIHRhZ0hlYWRlck9mZnNldCkpIHtcbiAgICAgIC8vIFRhZ3MgYXJlIGNvcnJ1cHRlZCAob2Zmc2V0IHRvbyBmYXIpLCByZXR1cm4gd2hhdCB3ZSBwYXJzZWQgdW50aWwgbm93XG4gICAgICByZXR1cm4gdGFncztcbiAgICB9XG5cbiAgICB2YXIgdGFnU2lnbmF0dXJlID0gT2JqZWN0KF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZ2V0U3RyaW5nRnJvbURhdGFWaWV3XCJdKShkYXRhVmlldywgdGFnSGVhZGVyT2Zmc2V0LCA0KTtcbiAgICB2YXIgdGFnT2Zmc2V0ID0gZGF0YVZpZXcuZ2V0VWludDMyKHRhZ0hlYWRlck9mZnNldCArIDQpO1xuICAgIHZhciB0YWdTaXplID0gZGF0YVZpZXcuZ2V0VWludDMyKHRhZ0hlYWRlck9mZnNldCArIDgpO1xuXG4gICAgaWYgKHRhZ09mZnNldCA+IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIC8vIFRhZyBkYXRhIGlzIGludmFsaWQsIGxldHMgcmV0dXJuIHdoYXQgd2UgbWFuYWdlZCB0byBwYXJzZVxuICAgICAgcmV0dXJuIHRhZ3M7XG4gICAgfVxuXG4gICAgdmFyIHRhZ1R5cGUgPSBPYmplY3QoX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJnZXRTdHJpbmdGcm9tRGF0YVZpZXdcIl0pKGRhdGFWaWV3LCB0YWdPZmZzZXQsIDQpO1xuXG4gICAgaWYgKHRhZ1R5cGUgPT09IFRBR19UWVBFX0RFU0MpIHtcbiAgICAgIHZhciB0YWdWYWx1ZVNpemUgPSBkYXRhVmlldy5nZXRVaW50MzIodGFnT2Zmc2V0ICsgOCk7XG5cbiAgICAgIGlmICh0YWdWYWx1ZVNpemUgPiB0YWdTaXplKSB7XG4gICAgICAgIC8vIFRhZyBkYXRhIGlzIGludmFsaWQsIGxldHMgcmV0dXJuIHdoYXQgd2UgbWFuYWdlZCB0byBwYXJzZVxuICAgICAgICByZXR1cm4gdGFncztcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbCA9IHNsaWNlVG9TdHJpbmcoYnVmZmVyLnNsaWNlKHRhZ09mZnNldCArIDEyLCB0YWdPZmZzZXQgKyB0YWdWYWx1ZVNpemUgKyAxMSkpO1xuICAgICAgYWRkVGFnKHRhZ3MsIHRhZ1NpZ25hdHVyZSwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKHRhZ1R5cGUgPT09IFRBR19UWVBFX01VTFRJX0xPQ0FMSVpFRF9VTklDT0RFX1RZUEUpIHtcbiAgICAgIHZhciBudW1SZWNvcmRzID0gZGF0YVZpZXcuZ2V0VWludDMyKHRhZ09mZnNldCArIDgpO1xuICAgICAgdmFyIHJlY29yZFNpemUgPSBkYXRhVmlldy5nZXRVaW50MzIodGFnT2Zmc2V0ICsgMTIpO1xuXG4gICAgICB2YXIgX29mZnNldCA9IHRhZ09mZnNldCArIDE2O1xuXG4gICAgICB2YXIgX3ZhbCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciByZWNvcmROdW0gPSAwOyByZWNvcmROdW0gPCBudW1SZWNvcmRzOyByZWNvcmROdW0rKykge1xuICAgICAgICB2YXIgbGFuZ3VhZ2VDb2RlID0gT2JqZWN0KF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZ2V0U3RyaW5nRnJvbURhdGFWaWV3XCJdKShkYXRhVmlldywgX29mZnNldCArIDAsIDIpO1xuICAgICAgICB2YXIgY291bnRyeUNvZGUgPSBPYmplY3QoX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJnZXRTdHJpbmdGcm9tRGF0YVZpZXdcIl0pKGRhdGFWaWV3LCBfb2Zmc2V0ICsgMiwgMik7XG4gICAgICAgIHZhciB0ZXh0TGVuZ3RoID0gZGF0YVZpZXcuZ2V0VWludDMyKF9vZmZzZXQgKyA0KTtcbiAgICAgICAgdmFyIHRleHRPZmZzZXQgPSBkYXRhVmlldy5nZXRVaW50MzIoX29mZnNldCArIDgpO1xuICAgICAgICB2YXIgdGV4dCA9IE9iamVjdChfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImdldFVuaWNvZGVTdHJpbmdGcm9tRGF0YVZpZXdcIl0pKGRhdGFWaWV3LCB0YWdPZmZzZXQgKyB0ZXh0T2Zmc2V0LCB0ZXh0TGVuZ3RoKTtcblxuICAgICAgICBfdmFsLnB1c2goe1xuICAgICAgICAgIGxhbmd1YWdlQ29kZTogbGFuZ3VhZ2VDb2RlLFxuICAgICAgICAgIGNvdW50cnlDb2RlOiBjb3VudHJ5Q29kZSxcbiAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF9vZmZzZXQgKz0gcmVjb3JkU2l6ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG51bVJlY29yZHMgPT09IDEpIHtcbiAgICAgICAgYWRkVGFnKHRhZ3MsIHRhZ1NpZ25hdHVyZSwgX3ZhbFswXS50ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWxPYmogPSB7fTtcblxuICAgICAgICBmb3IgKHZhciB2YWxJbmRleCA9IDA7IHZhbEluZGV4IDwgX3ZhbC5sZW5ndGg7IHZhbEluZGV4KyspIHtcbiAgICAgICAgICB2YWxPYmpbXCJcIi5jb25jYXQoX3ZhbFt2YWxJbmRleF0ubGFuZ3VhZ2VDb2RlLCBcIi1cIikuY29uY2F0KF92YWxbdmFsSW5kZXhdLmNvdW50cnlDb2RlKV0gPSBfdmFsW3ZhbEluZGV4XS50ZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgYWRkVGFnKHRhZ3MsIHRhZ1NpZ25hdHVyZSwgdmFsT2JqKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRhZ1R5cGUgPT09IFRBR19UWVBFX1RFWFQpIHtcbiAgICAgIHZhciBfdmFsMiA9IHNsaWNlVG9TdHJpbmcoYnVmZmVyLnNsaWNlKHRhZ09mZnNldCArIDgsIHRhZ09mZnNldCArIHRhZ1NpemUgLSA3KSk7XG5cbiAgICAgIGFkZFRhZyh0YWdzLCB0YWdTaWduYXR1cmUsIF92YWwyKTtcbiAgICB9IGVsc2UgaWYgKHRhZ1R5cGUgPT09IFRBR19UWVBFX1NJR05BVFVSRSkge1xuICAgICAgdmFyIF92YWwzID0gc2xpY2VUb1N0cmluZyhidWZmZXIuc2xpY2UodGFnT2Zmc2V0ICsgOCwgdGFnT2Zmc2V0ICsgMTIpKTtcblxuICAgICAgYWRkVGFnKHRhZ3MsIHRhZ1NpZ25hdHVyZSwgX3ZhbDMpO1xuICAgIH1cblxuICAgIHRhZ0hlYWRlck9mZnNldCA9IHRhZ0hlYWRlck9mZnNldCArIDEyO1xuICB9XG5cbiAgcmV0dXJuIHRhZ3M7XG59XG5cbmZ1bmN0aW9uIHNsaWNlVG9TdHJpbmcoc2xpY2UpIHtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkoc2xpY2UpKTtcbn1cblxuZnVuY3Rpb24gYWRkVGFnKHRhZ3MsIHRhZ1NpZ25hdHVyZSwgdmFsdWUpIHtcbiAgaWYgKF9pY2NfdGFnX25hbWVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpY2NUYWdzXCJdW3RhZ1NpZ25hdHVyZV0pIHtcbiAgICB0YWdzW19pY2NfdGFnX25hbWVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpY2NUYWdzXCJdW3RhZ1NpZ25hdHVyZV0ubmFtZV0gPSB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBkZXNjcmlwdGlvbjogdmFsdWVcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRhZ3NbdGFnU2lnbmF0dXJlXSA9IHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGRlc2NyaXB0aW9uOiB2YWx1ZVxuICAgIH07XG4gIH1cbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvaW1hZ2UtaGVhZGVyLWhlaWMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvaW1hZ2UtaGVhZGVyLWhlaWMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMuanMgKi8gXCIuL3NyYy91dGlscy5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29uc3RhbnRzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnN0YW50cy5qcyAqLyBcIi4vc3JjL2NvbnN0YW50cy5qc1wiKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwczovL21vemlsbGEub3JnL01QTC8yLjAvLiAqL1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICBpc0hlaWNGaWxlOiBpc0hlaWNGaWxlLFxuICBmaW5kSGVpY09mZnNldHM6IGZpbmRIZWljT2Zmc2V0c1xufSk7XG5cbmZ1bmN0aW9uIGlzSGVpY0ZpbGUoZGF0YVZpZXcpIHtcbiAgdmFyIEhFSUNfSUQgPSAnZnR5cCc7XG4gIHZhciBIRUlDX0lEX09GRlNFVCA9IDQ7XG4gIHZhciBIRUlDX01BSk9SX0JSQU5EUyA9IFsnaGVpYycsICdoZWl4JywgJ2hldmMnLCAnaGV2eCcsICdoZWltJywgJ2hlaXMnLCAnaGV2bScsICdoZXZzJywgJ21pZjEnXTtcbiAgdmFyIEhFSUNfTUFKT1JfQlJBTkRfTEVOR1RIID0gNDtcbiAgdmFyIGhlaWNNYWpvckJyYW5kID0gT2JqZWN0KF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZ2V0U3RyaW5nRnJvbURhdGFWaWV3XCJdKShkYXRhVmlldywgSEVJQ19JRF9PRkZTRVQgKyBIRUlDX0lELmxlbmd0aCwgSEVJQ19NQUpPUl9CUkFORF9MRU5HVEgpO1xuICByZXR1cm4gT2JqZWN0KF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZ2V0U3RyaW5nRnJvbURhdGFWaWV3XCJdKShkYXRhVmlldywgSEVJQ19JRF9PRkZTRVQsIEhFSUNfSUQubGVuZ3RoKSA9PT0gSEVJQ19JRCAmJiBIRUlDX01BSk9SX0JSQU5EUy5pbmRleE9mKGhlaWNNYWpvckJyYW5kKSAhPT0gLTE7XG59XG5cbmZ1bmN0aW9uIGZpbmRIZWljT2Zmc2V0cyhkYXRhVmlldykge1xuICBpZiAoX2NvbnN0YW50c19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXS5VU0VfRVhJRiB8fCBfY29uc3RhbnRzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLlVTRV9JQ0MpIHtcbiAgICB2YXIgX2ZpbmRNZXRhQXRvbSA9IGZpbmRNZXRhQXRvbShkYXRhVmlldyksXG4gICAgICAgIG1ldGFPZmZzZXQgPSBfZmluZE1ldGFBdG9tLm9mZnNldCxcbiAgICAgICAgbWV0YUxlbmd0aCA9IF9maW5kTWV0YUF0b20ubGVuZ3RoO1xuXG4gICAgaWYgKG1ldGFPZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGFzQXBwTWFya2VyczogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIG1ldGFFbmRPZmZzZXQgPSBNYXRoLm1pbihtZXRhT2Zmc2V0ICsgbWV0YUxlbmd0aCwgZGF0YVZpZXcuYnl0ZUxlbmd0aCk7XG5cbiAgICB2YXIgX2ZpbmRNZXRhSXRlbXMgPSBmaW5kTWV0YUl0ZW1zKGRhdGFWaWV3LCBtZXRhT2Zmc2V0LCBtZXRhRW5kT2Zmc2V0KSxcbiAgICAgICAgZXhpZkl0ZW1PZmZzZXQgPSBfZmluZE1ldGFJdGVtcy5leGlmSXRlbU9mZnNldCxcbiAgICAgICAgaWxvY09mZnNldCA9IF9maW5kTWV0YUl0ZW1zLmlsb2NPZmZzZXQsXG4gICAgICAgIGNvbHJPZmZzZXQgPSBfZmluZE1ldGFJdGVtcy5jb2xyT2Zmc2V0O1xuXG4gICAgdmFyIGV4aWZPZmZzZXQgPSBmaW5kRXhpZk9mZnNldChkYXRhVmlldywgZXhpZkl0ZW1PZmZzZXQsIGlsb2NPZmZzZXQsIG1ldGFFbmRPZmZzZXQpO1xuICAgIHZhciBpY2NDaHVua3MgPSBmaW5kSWNjQ2h1bmtzKGRhdGFWaWV3LCBjb2xyT2Zmc2V0LCBtZXRhRW5kT2Zmc2V0KTtcbiAgICByZXR1cm4ge1xuICAgICAgaGFzQXBwTWFya2VyczogZXhpZk9mZnNldCAhPT0gdW5kZWZpbmVkIHx8IGljY0NodW5rcyAhPT0gdW5kZWZpbmVkLFxuICAgICAgdGlmZkhlYWRlck9mZnNldDogZXhpZk9mZnNldCxcbiAgICAgIGljY0NodW5rczogaWNjQ2h1bmtzXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaGFzQXBwTWFya2VyczogZmFsc2VcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmluZE1ldGFBdG9tKGRhdGFWaWV3KSB7XG4gIHZhciBBVE9NX0xFTkdUSF9TSVpFID0gNDtcbiAgdmFyIEFUT01fVFlQRV9TSVpFID0gNDtcbiAgdmFyIEFUT01fTUlOX0xFTkdUSCA9IDg7XG4gIHZhciBBVE9NX1RZUEVfT0ZGU0VUID0gNDtcbiAgdmFyIG9mZnNldCA9IDA7XG5cbiAgd2hpbGUgKG9mZnNldCArIEFUT01fTEVOR1RIX1NJWkUgKyBBVE9NX1RZUEVfU0laRSA8PSBkYXRhVmlldy5ieXRlTGVuZ3RoKSB7XG4gICAgdmFyIGF0b21MZW5ndGggPSBnZXRBdG9tTGVuZ3RoKGRhdGFWaWV3LCBvZmZzZXQpO1xuXG4gICAgaWYgKGF0b21MZW5ndGggPj0gQVRPTV9NSU5fTEVOR1RIKSB7XG4gICAgICB2YXIgYXRvbVR5cGUgPSBPYmplY3QoX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJnZXRTdHJpbmdGcm9tRGF0YVZpZXdcIl0pKGRhdGFWaWV3LCBvZmZzZXQgKyBBVE9NX1RZUEVfT0ZGU0VULCBBVE9NX1RZUEVfU0laRSk7XG5cbiAgICAgIGlmIChhdG9tVHlwZSA9PT0gJ21ldGEnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgbGVuZ3RoOiBhdG9tTGVuZ3RoXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgb2Zmc2V0ICs9IGF0b21MZW5ndGg7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG9mZnNldDogdW5kZWZpbmVkLFxuICAgIGxlbmd0aDogMFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRBdG9tTGVuZ3RoKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgdmFyIEFUT01fRVhURU5ERURfU0laRV9MT1dfT0ZGU0VUID0gMTI7XG4gIHZhciBhdG9tTGVuZ3RoID0gZGF0YVZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG5cbiAgaWYgKGV4dGVuZHNUb0VuZE9mRmlsZShhdG9tTGVuZ3RoKSkge1xuICAgIHJldHVybiBkYXRhVmlldy5ieXRlTGVuZ3RoIC0gb2Zmc2V0O1xuICB9XG5cbiAgaWYgKGhhc0V4dGVuZGVkU2l6ZShhdG9tTGVuZ3RoKSkge1xuICAgIGlmIChoYXNFbXB0eUhpZ2hCaXRzKGRhdGFWaWV3LCBvZmZzZXQpKSB7XG4gICAgICAvLyBJdCdzIGEgYml0IHRyaWNreSB0byBoYW5kbGUgNjQgYml0IG51bWJlcnMgaW4gSmF2YVNjcmlwdC4gTGV0J3NcbiAgICAgIC8vIHdhaXQgdW50aWwgdGhlcmUgYXJlIHJlYWwtd29ybGQgZXhhbXBsZXMgd2hlcmUgaXQgaXMgbmVjZXNzYXJ5LlxuICAgICAgcmV0dXJuIGRhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQgKyBBVE9NX0VYVEVOREVEX1NJWkVfTE9XX09GRlNFVCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGF0b21MZW5ndGg7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZHNUb0VuZE9mRmlsZShhdG9tTGVuZ3RoKSB7XG4gIHJldHVybiBhdG9tTGVuZ3RoID09PSAwO1xufVxuXG5mdW5jdGlvbiBoYXNFeHRlbmRlZFNpemUoYXRvbUxlbmd0aCkge1xuICByZXR1cm4gYXRvbUxlbmd0aCA9PT0gMTtcbn1cblxuZnVuY3Rpb24gaGFzRW1wdHlIaWdoQml0cyhkYXRhVmlldywgb2Zmc2V0KSB7XG4gIHZhciBBVE9NX0VYVEVOREVEX1NJWkVfT0ZGU0VUID0gODtcbiAgcmV0dXJuIGRhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQgKyBBVE9NX0VYVEVOREVEX1NJWkVfT0ZGU0VUKSA9PT0gMDtcbn1cblxuZnVuY3Rpb24gZmluZE1ldGFJdGVtcyhkYXRhVmlldywgb2Zmc2V0LCBtZXRhRW5kT2Zmc2V0KSB7XG4gIHZhciBTVFJJTkdfU0laRSA9IDQ7XG4gIHZhciBJVEVNX0lOREVYX1JFTF9PRkZTRVQgPSAtNDtcbiAgdmFyIG9mZnNldHMgPSB7XG4gICAgaWxvY09mZnNldDogdW5kZWZpbmVkLFxuICAgIGV4aWZJdGVtT2Zmc2V0OiB1bmRlZmluZWQsXG4gICAgY29sck9mZnNldDogdW5kZWZpbmVkXG4gIH07XG5cbiAgd2hpbGUgKG9mZnNldCArIFNUUklOR19TSVpFIDw9IG1ldGFFbmRPZmZzZXQgJiYgKCFvZmZzZXRzLmlsb2NPZmZzZXQgfHwgIW9mZnNldHMuZXhpZkl0ZW1PZmZzZXQgfHwgIW9mZnNldHMuY29sck9mZnNldCkpIHtcbiAgICB2YXIgaXRlbU5hbWUgPSBPYmplY3QoX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJnZXRTdHJpbmdGcm9tRGF0YVZpZXdcIl0pKGRhdGFWaWV3LCBvZmZzZXQsIFNUUklOR19TSVpFKTtcblxuICAgIGlmIChfY29uc3RhbnRzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLlVTRV9FWElGICYmIGl0ZW1OYW1lID09PSAnaWxvYycpIHtcbiAgICAgIG9mZnNldHMuaWxvY09mZnNldCA9IG9mZnNldDtcbiAgICB9IGVsc2UgaWYgKF9jb25zdGFudHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0uVVNFX0VYSUYgJiYgaXRlbU5hbWUgPT09ICdFeGlmJykge1xuICAgICAgb2Zmc2V0cy5leGlmSXRlbU9mZnNldCA9IG9mZnNldCArIElURU1fSU5ERVhfUkVMX09GRlNFVDtcbiAgICB9IGVsc2UgaWYgKF9jb25zdGFudHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0uVVNFX0lDQyAmJiBpdGVtTmFtZSA9PT0gJ2NvbHInKSB7XG4gICAgICBvZmZzZXRzLmNvbHJPZmZzZXQgPSBvZmZzZXQgKyBJVEVNX0lOREVYX1JFTF9PRkZTRVQ7XG4gICAgfVxuXG4gICAgb2Zmc2V0Kys7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0cztcbn1cblxuZnVuY3Rpb24gZmluZEV4aWZPZmZzZXQoZGF0YVZpZXcsIGV4aWZJdGVtT2Zmc2V0LCBvZmZzZXQsIG1ldGFFbmRPZmZzZXQpIHtcbiAgdmFyIEVYSUZfSVRFTV9PRkZTRVRfU0laRSA9IDI7XG4gIHZhciBJTE9DX0RBVEFfT0ZGU0VUID0gMTI7XG4gIHZhciBFWElGX1BPSU5URVJfT0ZGU0VUID0gODtcbiAgdmFyIEVYSUZfUE9JTlRFUl9TSVpFID0gNDtcbiAgdmFyIEVYSUZfUFJFRklYX0xFTkdUSF9PRkZTRVQgPSA0O1xuICB2YXIgSUxPQ19JVEVNX1NJWkUgPSAxNjtcblxuICBpZiAoIW9mZnNldCB8fCAhZXhpZkl0ZW1PZmZzZXQgfHwgZXhpZkl0ZW1PZmZzZXQgKyBFWElGX0lURU1fT0ZGU0VUX1NJWkUgPiBtZXRhRW5kT2Zmc2V0KSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBleGlmSXRlbUluZGV4ID0gZGF0YVZpZXcuZ2V0VWludDE2KGV4aWZJdGVtT2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IElMT0NfREFUQV9PRkZTRVQ7XG5cbiAgd2hpbGUgKG9mZnNldCArIElMT0NfSVRFTV9TSVpFIDw9IG1ldGFFbmRPZmZzZXQpIHtcbiAgICB2YXIgaXRlbUluZGV4ID0gZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldCk7XG5cbiAgICBpZiAoaXRlbUluZGV4ID09PSBleGlmSXRlbUluZGV4KSB7XG4gICAgICB2YXIgZXhpZlBvaW50ZXIgPSBkYXRhVmlldy5nZXRVaW50MzIob2Zmc2V0ICsgRVhJRl9QT0lOVEVSX09GRlNFVCk7XG5cbiAgICAgIGlmIChleGlmUG9pbnRlciArIEVYSUZfUE9JTlRFUl9TSVpFIDw9IGRhdGFWaWV3LmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgdmFyIGV4aWZPZmZzZXQgPSBkYXRhVmlldy5nZXRVaW50MzIoZXhpZlBvaW50ZXIpO1xuICAgICAgICB2YXIgcHJlZml4TGVuZ3RoID0gZXhpZk9mZnNldCArIEVYSUZfUFJFRklYX0xFTkdUSF9PRkZTRVQ7XG4gICAgICAgIHJldHVybiBleGlmUG9pbnRlciArIHByZWZpeExlbmd0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvZmZzZXQgKz0gSUxPQ19JVEVNX1NJWkU7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBmaW5kSWNjQ2h1bmtzKGRhdGFWaWV3LCBvZmZzZXQsIG1ldGFFbmRPZmZzZXQpIHtcbiAgdmFyIElURU1fVFlQRV9PRkZTRVQgPSA4O1xuICB2YXIgSVRFTV9UWVBFX1NJWkUgPSA0O1xuICB2YXIgSVRFTV9DT05URU5UX09GRlNFVCA9IDEyO1xuXG4gIGlmICghb2Zmc2V0IHx8IG9mZnNldCArIElURU1fQ09OVEVOVF9PRkZTRVQgPiBtZXRhRW5kT2Zmc2V0KSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBjb2xvclR5cGUgPSBPYmplY3QoX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJnZXRTdHJpbmdGcm9tRGF0YVZpZXdcIl0pKGRhdGFWaWV3LCBvZmZzZXQgKyBJVEVNX1RZUEVfT0ZGU0VULCBJVEVNX1RZUEVfU0laRSk7XG5cbiAgaWYgKGNvbG9yVHlwZSAhPT0gJ3Byb2YnICYmIGNvbG9yVHlwZSAhPT0gJ3JJQ0MnKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiBbe1xuICAgIG9mZnNldDogb2Zmc2V0ICsgSVRFTV9DT05URU5UX09GRlNFVCxcbiAgICBsZW5ndGg6IGdldEF0b21MZW5ndGgoZGF0YVZpZXcsIG9mZnNldCkgLSBJVEVNX0NPTlRFTlRfT0ZGU0VULFxuICAgIGNodW5rTnVtYmVyOiAxLFxuICAgIGNodW5rc1RvdGFsOiAxXG4gIH1dO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9pbWFnZS1oZWFkZXItanBlZy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9pbWFnZS1oZWFkZXItanBlZy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlscy5qcyAqLyBcIi4vc3JjL3V0aWxzLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb25zdGFudHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29uc3RhbnRzLmpzICovIFwiLi9zcmMvY29uc3RhbnRzLmpzXCIpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uICovXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gIGlzSnBlZ0ZpbGU6IGlzSnBlZ0ZpbGUsXG4gIGZpbmRKcGVnT2Zmc2V0czogZmluZEpwZWdPZmZzZXRzXG59KTtcbnZhciBNSU5fSlBFR19EQVRBX0JVRkZFUl9MRU5HVEggPSAyO1xudmFyIEpQRUdfSUQgPSAweGZmZDg7XG52YXIgSlBFR19JRF9TSVpFID0gMjtcbnZhciBBUFBfSURfT0ZGU0VUID0gNDtcbnZhciBBUFBfTUFSS0VSX1NJWkUgPSAyO1xudmFyIFRJRkZfSEVBREVSX09GRlNFVCA9IDEwOyAvLyBGcm9tIHN0YXJ0IG9mIEFQUDEgbWFya2VyLlxuXG52YXIgSVBUQ19EQVRBX09GRlNFVCA9IDE4OyAvLyBGcm9tIHN0YXJ0IG9mIEFQUDEzIG1hcmtlci5cblxudmFyIFhNUF9EQVRBX09GRlNFVCA9IDMzOyAvLyBGcm9tIHN0YXJ0IG9mIEFQUDEgbWFya2VyLlxuXG52YXIgWE1QX0VYVEVOREVEX0RBVEFfT0ZGU0VUID0gNzk7IC8vIEZyb20gc3RhcnQgb2YgQVBQMSBtYXJrZXIgaW5jbHVkaW5nIEdVSUQsIHRvdGFsIGxlbmd0aCwgYW5kIG9mZnNldC5cblxudmFyIEFQUDJfSUNDX0RBVEFfT0ZGU0VUID0gMTg7IC8vIEZyb20gc3RhcnQgb2YgQVBQMiBtYXJrZXIgaW5jbHVkaW5nIG1hcmtlciBhbmQgY2h1bmsvY2h1bmsgdG90YWwgbnVtYmVycy5cblxudmFyIEFQUDJfSUNDX0lERU5USUZJRVIgPSAnSUNDX1BST0ZJTEVcXDAnO1xudmFyIElDQ19DSFVOS19OVU1CRVJfT0ZGU0VUID0gQVBQX0lEX09GRlNFVCArIEFQUDJfSUNDX0lERU5USUZJRVIubGVuZ3RoO1xudmFyIElDQ19UT1RBTF9DSFVOS1NfT0ZGU0VUID0gSUNDX0NIVU5LX05VTUJFUl9PRkZTRVQgKyAxO1xudmFyIFNPRjBfTUFSS0VSID0gMHhmZmMwO1xudmFyIFNPRjJfTUFSS0VSID0gMHhmZmMyO1xudmFyIERIVF9NQVJLRVIgPSAweGZmYzQ7XG52YXIgRFFUX01BUktFUiA9IDB4ZmZkYjtcbnZhciBEUklfTUFSS0VSID0gMHhmZmRkO1xudmFyIFNPU19NQVJLRVIgPSAweGZmZGE7XG52YXIgQVBQMF9NQVJLRVIgPSAweGZmZTA7XG52YXIgQVBQMV9NQVJLRVIgPSAweGZmZTE7XG52YXIgQVBQMl9NQVJLRVIgPSAweGZmZTI7XG52YXIgQVBQMTNfTUFSS0VSID0gMHhmZmVkO1xudmFyIEFQUDE1X01BUktFUiA9IDB4ZmZlZjtcbnZhciBDT01NRU5UX01BUktFUiA9IDB4ZmZmZTtcbnZhciBBUFAxX0VYSUZfSURFTlRJRklFUiA9ICdFeGlmJztcbnZhciBBUFAxX1hNUF9JREVOVElGSUVSID0gJ2h0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9cXHgwMCc7XG52YXIgQVBQMV9YTVBfRVhURU5ERURfSURFTlRJRklFUiA9ICdodHRwOi8vbnMuYWRvYmUuY29tL3htcC9leHRlbnNpb24vXFx4MDAnO1xudmFyIEFQUDEzX0lQVENfSURFTlRJRklFUiA9ICdQaG90b3Nob3AgMy4wJztcblxuZnVuY3Rpb24gaXNKcGVnRmlsZShkYXRhVmlldykge1xuICByZXR1cm4gZGF0YVZpZXcuYnl0ZUxlbmd0aCA+PSBNSU5fSlBFR19EQVRBX0JVRkZFUl9MRU5HVEggJiYgZGF0YVZpZXcuZ2V0VWludDE2KDApID09PSBKUEVHX0lEO1xufVxuXG5mdW5jdGlvbiBmaW5kSnBlZ09mZnNldHMoZGF0YVZpZXcpIHtcbiAgdmFyIGFwcE1hcmtlclBvc2l0aW9uID0gSlBFR19JRF9TSVpFO1xuICB2YXIgZmllbGRMZW5ndGg7XG4gIHZhciBzb2YwRGF0YU9mZnNldDtcbiAgdmFyIHNvZjJEYXRhT2Zmc2V0O1xuICB2YXIgdGlmZkhlYWRlck9mZnNldDtcbiAgdmFyIGlwdGNEYXRhT2Zmc2V0O1xuICB2YXIgeG1wQ2h1bmtzO1xuICB2YXIgaWNjQ2h1bmtzO1xuXG4gIHdoaWxlIChhcHBNYXJrZXJQb3NpdGlvbiArIEFQUF9JRF9PRkZTRVQgKyA1IDw9IGRhdGFWaWV3LmJ5dGVMZW5ndGgpIHtcbiAgICBpZiAoX2NvbnN0YW50c19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXS5VU0VfRklMRSAmJiBpc1NPRjBNYXJrZXIoZGF0YVZpZXcsIGFwcE1hcmtlclBvc2l0aW9uKSkge1xuICAgICAgc29mMERhdGFPZmZzZXQgPSBhcHBNYXJrZXJQb3NpdGlvbiArIEFQUF9NQVJLRVJfU0laRTtcbiAgICB9IGVsc2UgaWYgKF9jb25zdGFudHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0uVVNFX0ZJTEUgJiYgaXNTT0YyTWFya2VyKGRhdGFWaWV3LCBhcHBNYXJrZXJQb3NpdGlvbikpIHtcbiAgICAgIHNvZjJEYXRhT2Zmc2V0ID0gYXBwTWFya2VyUG9zaXRpb24gKyBBUFBfTUFSS0VSX1NJWkU7XG4gICAgfSBlbHNlIGlmIChfY29uc3RhbnRzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLlVTRV9FWElGICYmIGlzQXBwMUV4aWZNYXJrZXIoZGF0YVZpZXcsIGFwcE1hcmtlclBvc2l0aW9uKSkge1xuICAgICAgZmllbGRMZW5ndGggPSBkYXRhVmlldy5nZXRVaW50MTYoYXBwTWFya2VyUG9zaXRpb24gKyBBUFBfTUFSS0VSX1NJWkUpO1xuICAgICAgdGlmZkhlYWRlck9mZnNldCA9IGFwcE1hcmtlclBvc2l0aW9uICsgVElGRl9IRUFERVJfT0ZGU0VUO1xuICAgIH0gZWxzZSBpZiAoX2NvbnN0YW50c19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXS5VU0VfWE1QICYmIGlzQXBwMVhtcE1hcmtlcihkYXRhVmlldywgYXBwTWFya2VyUG9zaXRpb24pKSB7XG4gICAgICBpZiAoIXhtcENodW5rcykge1xuICAgICAgICB4bXBDaHVua3MgPSBbXTtcbiAgICAgIH1cblxuICAgICAgZmllbGRMZW5ndGggPSBkYXRhVmlldy5nZXRVaW50MTYoYXBwTWFya2VyUG9zaXRpb24gKyBBUFBfTUFSS0VSX1NJWkUpO1xuICAgICAgeG1wQ2h1bmtzLnB1c2goZ2V0WG1wQ2h1bmtEZXRhaWxzKGFwcE1hcmtlclBvc2l0aW9uLCBmaWVsZExlbmd0aCkpO1xuICAgIH0gZWxzZSBpZiAoX2NvbnN0YW50c19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXS5VU0VfWE1QICYmIGlzQXBwMUV4dGVuZGVkWG1wTWFya2VyKGRhdGFWaWV3LCBhcHBNYXJrZXJQb3NpdGlvbikpIHtcbiAgICAgIGlmICgheG1wQ2h1bmtzKSB7XG4gICAgICAgIHhtcENodW5rcyA9IFtdO1xuICAgICAgfVxuXG4gICAgICBmaWVsZExlbmd0aCA9IGRhdGFWaWV3LmdldFVpbnQxNihhcHBNYXJrZXJQb3NpdGlvbiArIEFQUF9NQVJLRVJfU0laRSk7XG4gICAgICB4bXBDaHVua3MucHVzaChnZXRFeHRlbmRlZFhtcENodW5rRGV0YWlscyhhcHBNYXJrZXJQb3NpdGlvbiwgZmllbGRMZW5ndGgpKTtcbiAgICB9IGVsc2UgaWYgKF9jb25zdGFudHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0uVVNFX0lQVEMgJiYgaXNBcHAxM1Bob3Rvc2hvcE1hcmtlcihkYXRhVmlldywgYXBwTWFya2VyUG9zaXRpb24pKSB7XG4gICAgICBmaWVsZExlbmd0aCA9IGRhdGFWaWV3LmdldFVpbnQxNihhcHBNYXJrZXJQb3NpdGlvbiArIEFQUF9NQVJLRVJfU0laRSk7XG4gICAgICBpcHRjRGF0YU9mZnNldCA9IGFwcE1hcmtlclBvc2l0aW9uICsgSVBUQ19EQVRBX09GRlNFVDtcbiAgICB9IGVsc2UgaWYgKF9jb25zdGFudHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0uVVNFX0lDQyAmJiBpc0FwcDJJQ0NNYXJrZXIoZGF0YVZpZXcsIGFwcE1hcmtlclBvc2l0aW9uKSkge1xuICAgICAgZmllbGRMZW5ndGggPSBkYXRhVmlldy5nZXRVaW50MTYoYXBwTWFya2VyUG9zaXRpb24gKyBBUFBfTUFSS0VSX1NJWkUpO1xuICAgICAgdmFyIGljY0RhdGFPZmZzZXQgPSBhcHBNYXJrZXJQb3NpdGlvbiArIEFQUDJfSUNDX0RBVEFfT0ZGU0VUO1xuICAgICAgdmFyIGljY0RhdGFMZW5ndGggPSBmaWVsZExlbmd0aCAtIChBUFAyX0lDQ19EQVRBX09GRlNFVCAtIEFQUF9NQVJLRVJfU0laRSk7XG4gICAgICB2YXIgaWNjQ2h1bmtOdW1iZXIgPSBkYXRhVmlldy5nZXRVaW50OChhcHBNYXJrZXJQb3NpdGlvbiArIElDQ19DSFVOS19OVU1CRVJfT0ZGU0VUKTtcbiAgICAgIHZhciBpY2NDaHVua3NUb3RhbCA9IGRhdGFWaWV3LmdldFVpbnQ4KGFwcE1hcmtlclBvc2l0aW9uICsgSUNDX1RPVEFMX0NIVU5LU19PRkZTRVQpO1xuXG4gICAgICBpZiAoIWljY0NodW5rcykge1xuICAgICAgICBpY2NDaHVua3MgPSBbXTtcbiAgICAgIH1cblxuICAgICAgaWNjQ2h1bmtzLnB1c2goe1xuICAgICAgICBvZmZzZXQ6IGljY0RhdGFPZmZzZXQsXG4gICAgICAgIGxlbmd0aDogaWNjRGF0YUxlbmd0aCxcbiAgICAgICAgY2h1bmtOdW1iZXI6IGljY0NodW5rTnVtYmVyLFxuICAgICAgICBjaHVua3NUb3RhbDogaWNjQ2h1bmtzVG90YWxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaXNBcHBNYXJrZXIoZGF0YVZpZXcsIGFwcE1hcmtlclBvc2l0aW9uKSkge1xuICAgICAgZmllbGRMZW5ndGggPSBkYXRhVmlldy5nZXRVaW50MTYoYXBwTWFya2VyUG9zaXRpb24gKyBBUFBfTUFSS0VSX1NJWkUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBhcHBNYXJrZXJQb3NpdGlvbiArPSBBUFBfTUFSS0VSX1NJWkUgKyBmaWVsZExlbmd0aDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaGFzQXBwTWFya2VyczogYXBwTWFya2VyUG9zaXRpb24gPiBKUEVHX0lEX1NJWkUsXG4gICAgZmlsZURhdGFPZmZzZXQ6IHNvZjBEYXRhT2Zmc2V0IHx8IHNvZjJEYXRhT2Zmc2V0LFxuICAgIHRpZmZIZWFkZXJPZmZzZXQ6IHRpZmZIZWFkZXJPZmZzZXQsXG4gICAgaXB0Y0RhdGFPZmZzZXQ6IGlwdGNEYXRhT2Zmc2V0LFxuICAgIHhtcENodW5rczogeG1wQ2h1bmtzLFxuICAgIGljY0NodW5rczogaWNjQ2h1bmtzXG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzU09GME1hcmtlcihkYXRhVmlldywgYXBwTWFya2VyUG9zaXRpb24pIHtcbiAgcmV0dXJuIGRhdGFWaWV3LmdldFVpbnQxNihhcHBNYXJrZXJQb3NpdGlvbikgPT09IFNPRjBfTUFSS0VSO1xufVxuXG5mdW5jdGlvbiBpc1NPRjJNYXJrZXIoZGF0YVZpZXcsIGFwcE1hcmtlclBvc2l0aW9uKSB7XG4gIHJldHVybiBkYXRhVmlldy5nZXRVaW50MTYoYXBwTWFya2VyUG9zaXRpb24pID09PSBTT0YyX01BUktFUjtcbn1cblxuZnVuY3Rpb24gaXNBcHAySUNDTWFya2VyKGRhdGFWaWV3LCBhcHBNYXJrZXJQb3NpdGlvbikge1xuICB2YXIgbWFya2VySWRMZW5ndGggPSBBUFAyX0lDQ19JREVOVElGSUVSLmxlbmd0aDtcbiAgcmV0dXJuIGRhdGFWaWV3LmdldFVpbnQxNihhcHBNYXJrZXJQb3NpdGlvbikgPT09IEFQUDJfTUFSS0VSICYmIE9iamVjdChfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImdldFN0cmluZ0Zyb21EYXRhVmlld1wiXSkoZGF0YVZpZXcsIGFwcE1hcmtlclBvc2l0aW9uICsgQVBQX0lEX09GRlNFVCwgbWFya2VySWRMZW5ndGgpID09PSBBUFAyX0lDQ19JREVOVElGSUVSO1xufVxuXG5mdW5jdGlvbiBpc0FwcDFFeGlmTWFya2VyKGRhdGFWaWV3LCBhcHBNYXJrZXJQb3NpdGlvbikge1xuICB2YXIgbWFya2VySWRMZW5ndGggPSBBUFAxX0VYSUZfSURFTlRJRklFUi5sZW5ndGg7XG4gIHJldHVybiBkYXRhVmlldy5nZXRVaW50MTYoYXBwTWFya2VyUG9zaXRpb24pID09PSBBUFAxX01BUktFUiAmJiBPYmplY3QoX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJnZXRTdHJpbmdGcm9tRGF0YVZpZXdcIl0pKGRhdGFWaWV3LCBhcHBNYXJrZXJQb3NpdGlvbiArIEFQUF9JRF9PRkZTRVQsIG1hcmtlcklkTGVuZ3RoKSA9PT0gQVBQMV9FWElGX0lERU5USUZJRVIgJiYgZGF0YVZpZXcuZ2V0VWludDgoYXBwTWFya2VyUG9zaXRpb24gKyBBUFBfSURfT0ZGU0VUICsgbWFya2VySWRMZW5ndGgpID09PSAweDAwO1xufVxuXG5mdW5jdGlvbiBpc0FwcDFYbXBNYXJrZXIoZGF0YVZpZXcsIGFwcE1hcmtlclBvc2l0aW9uKSB7XG4gIHJldHVybiBkYXRhVmlldy5nZXRVaW50MTYoYXBwTWFya2VyUG9zaXRpb24pID09PSBBUFAxX01BUktFUiAmJiBpc1htcElkZW50aWZpZXIoZGF0YVZpZXcsIGFwcE1hcmtlclBvc2l0aW9uKTtcbn1cblxuZnVuY3Rpb24gaXNYbXBJZGVudGlmaWVyKGRhdGFWaWV3LCBhcHBNYXJrZXJQb3NpdGlvbikge1xuICB2YXIgbWFya2VySWRMZW5ndGggPSBBUFAxX1hNUF9JREVOVElGSUVSLmxlbmd0aDtcbiAgcmV0dXJuIE9iamVjdChfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImdldFN0cmluZ0Zyb21EYXRhVmlld1wiXSkoZGF0YVZpZXcsIGFwcE1hcmtlclBvc2l0aW9uICsgQVBQX0lEX09GRlNFVCwgbWFya2VySWRMZW5ndGgpID09PSBBUFAxX1hNUF9JREVOVElGSUVSO1xufVxuXG5mdW5jdGlvbiBpc0FwcDFFeHRlbmRlZFhtcE1hcmtlcihkYXRhVmlldywgYXBwTWFya2VyUG9zaXRpb24pIHtcbiAgcmV0dXJuIGRhdGFWaWV3LmdldFVpbnQxNihhcHBNYXJrZXJQb3NpdGlvbikgPT09IEFQUDFfTUFSS0VSICYmIGlzRXh0ZW5kZWRYbXBJZGVudGlmaWVyKGRhdGFWaWV3LCBhcHBNYXJrZXJQb3NpdGlvbik7XG59XG5cbmZ1bmN0aW9uIGlzRXh0ZW5kZWRYbXBJZGVudGlmaWVyKGRhdGFWaWV3LCBhcHBNYXJrZXJQb3NpdGlvbikge1xuICB2YXIgbWFya2VySWRMZW5ndGggPSBBUFAxX1hNUF9FWFRFTkRFRF9JREVOVElGSUVSLmxlbmd0aDtcbiAgcmV0dXJuIE9iamVjdChfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImdldFN0cmluZ0Zyb21EYXRhVmlld1wiXSkoZGF0YVZpZXcsIGFwcE1hcmtlclBvc2l0aW9uICsgQVBQX0lEX09GRlNFVCwgbWFya2VySWRMZW5ndGgpID09PSBBUFAxX1hNUF9FWFRFTkRFRF9JREVOVElGSUVSO1xufVxuXG5mdW5jdGlvbiBnZXRYbXBDaHVua0RldGFpbHMoYXBwTWFya2VyUG9zaXRpb24sIGZpZWxkTGVuZ3RoKSB7XG4gIHJldHVybiB7XG4gICAgZGF0YU9mZnNldDogYXBwTWFya2VyUG9zaXRpb24gKyBYTVBfREFUQV9PRkZTRVQsXG4gICAgbGVuZ3RoOiBmaWVsZExlbmd0aCAtIChYTVBfREFUQV9PRkZTRVQgLSBBUFBfTUFSS0VSX1NJWkUpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEV4dGVuZGVkWG1wQ2h1bmtEZXRhaWxzKGFwcE1hcmtlclBvc2l0aW9uLCBmaWVsZExlbmd0aCkge1xuICByZXR1cm4ge1xuICAgIGRhdGFPZmZzZXQ6IGFwcE1hcmtlclBvc2l0aW9uICsgWE1QX0VYVEVOREVEX0RBVEFfT0ZGU0VULFxuICAgIGxlbmd0aDogZmllbGRMZW5ndGggLSAoWE1QX0VYVEVOREVEX0RBVEFfT0ZGU0VUIC0gQVBQX01BUktFUl9TSVpFKVxuICB9O1xufVxuXG5mdW5jdGlvbiBpc0FwcDEzUGhvdG9zaG9wTWFya2VyKGRhdGFWaWV3LCBhcHBNYXJrZXJQb3NpdGlvbikge1xuICB2YXIgbWFya2VySWRMZW5ndGggPSBBUFAxM19JUFRDX0lERU5USUZJRVIubGVuZ3RoO1xuICByZXR1cm4gZGF0YVZpZXcuZ2V0VWludDE2KGFwcE1hcmtlclBvc2l0aW9uKSA9PT0gQVBQMTNfTUFSS0VSICYmIE9iamVjdChfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImdldFN0cmluZ0Zyb21EYXRhVmlld1wiXSkoZGF0YVZpZXcsIGFwcE1hcmtlclBvc2l0aW9uICsgQVBQX0lEX09GRlNFVCwgbWFya2VySWRMZW5ndGgpID09PSBBUFAxM19JUFRDX0lERU5USUZJRVIgJiYgZGF0YVZpZXcuZ2V0VWludDgoYXBwTWFya2VyUG9zaXRpb24gKyBBUFBfSURfT0ZGU0VUICsgbWFya2VySWRMZW5ndGgpID09PSAweDAwO1xufVxuXG5mdW5jdGlvbiBpc0FwcE1hcmtlcihkYXRhVmlldywgYXBwTWFya2VyUG9zaXRpb24pIHtcbiAgdmFyIGFwcE1hcmtlciA9IGRhdGFWaWV3LmdldFVpbnQxNihhcHBNYXJrZXJQb3NpdGlvbik7XG4gIHJldHVybiBhcHBNYXJrZXIgPj0gQVBQMF9NQVJLRVIgJiYgYXBwTWFya2VyIDw9IEFQUDE1X01BUktFUiB8fCBhcHBNYXJrZXIgPT09IENPTU1FTlRfTUFSS0VSIHx8IGFwcE1hcmtlciA9PT0gU09GMF9NQVJLRVIgfHwgYXBwTWFya2VyID09PSBTT0YyX01BUktFUiB8fCBhcHBNYXJrZXIgPT09IERIVF9NQVJLRVIgfHwgYXBwTWFya2VyID09PSBEUVRfTUFSS0VSIHx8IGFwcE1hcmtlciA9PT0gRFJJX01BUktFUiB8fCBhcHBNYXJrZXIgPT09IFNPU19NQVJLRVI7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2ltYWdlLWhlYWRlci1wbmcuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9pbWFnZS1oZWFkZXItcG5nLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMuanMgKi8gXCIuL3NyYy91dGlscy5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29uc3RhbnRzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnN0YW50cy5qcyAqLyBcIi4vc3JjL2NvbnN0YW50cy5qc1wiKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwczovL21vemlsbGEub3JnL01QTC8yLjAvLiAqL1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICBpc1BuZ0ZpbGU6IGlzUG5nRmlsZSxcbiAgZmluZFBuZ09mZnNldHM6IGZpbmRQbmdPZmZzZXRzXG59KTtcbnZhciBQTkdfSUQgPSAnXFx4ODlcXHg1MFxceDRlXFx4NDdcXHgwZFxceDBhXFx4MWFcXHgwYSc7XG52YXIgUE5HX0NIVU5LX0xFTkdUSF9TSVpFID0gNDtcbnZhciBQTkdfQ0hVTktfVFlQRV9TSVpFID0gNDtcbnZhciBQTkdfQ0hVTktfTEVOR1RIX09GRlNFVCA9IDA7XG52YXIgUE5HX0NIVU5LX1RZUEVfT0ZGU0VUID0gUE5HX0NIVU5LX0xFTkdUSF9TSVpFO1xudmFyIFBOR19DSFVOS19EQVRBX09GRlNFVCA9IFBOR19DSFVOS19MRU5HVEhfU0laRSArIFBOR19DSFVOS19UWVBFX1NJWkU7XG52YXIgUE5HX1hNUF9QUkVGSVggPSAnWE1MOmNvbS5hZG9iZS54bXBcXHgwMCc7XG5cbmZ1bmN0aW9uIGlzUG5nRmlsZShkYXRhVmlldykge1xuICByZXR1cm4gT2JqZWN0KF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZ2V0U3RyaW5nRnJvbURhdGFWaWV3XCJdKShkYXRhVmlldywgMCwgUE5HX0lELmxlbmd0aCkgPT09IFBOR19JRDtcbn1cblxuZnVuY3Rpb24gZmluZFBuZ09mZnNldHMoZGF0YVZpZXcpIHtcbiAgdmFyIFBOR19DUkNfU0laRSA9IDQ7XG4gIHZhciBvZmZzZXRzID0ge1xuICAgIGhhc0FwcE1hcmtlcnM6IGZhbHNlXG4gIH07XG4gIHZhciBvZmZzZXQgPSBQTkdfSUQubGVuZ3RoO1xuXG4gIHdoaWxlIChvZmZzZXQgKyBQTkdfQ0hVTktfTEVOR1RIX1NJWkUgKyBQTkdfQ0hVTktfVFlQRV9TSVpFIDw9IGRhdGFWaWV3LmJ5dGVMZW5ndGgpIHtcbiAgICBpZiAoX2NvbnN0YW50c19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXS5VU0VfUE5HX0ZJTEUgJiYgaXNQbmdJbWFnZUhlYWRlckNodW5rKGRhdGFWaWV3LCBvZmZzZXQpKSB7XG4gICAgICBvZmZzZXRzLmhhc0FwcE1hcmtlcnMgPSB0cnVlO1xuICAgICAgb2Zmc2V0cy5wbmdIZWFkZXJPZmZzZXQgPSBvZmZzZXQgKyBQTkdfQ0hVTktfREFUQV9PRkZTRVQ7XG4gICAgfSBlbHNlIGlmIChfY29uc3RhbnRzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLlVTRV9YTVAgJiYgaXNQbmdYbXBDaHVuayhkYXRhVmlldywgb2Zmc2V0KSkge1xuICAgICAgdmFyIGRhdGFPZmZzZXQgPSBnZXRQbmdYbXBEYXRhT2Zmc2V0KGRhdGFWaWV3LCBvZmZzZXQpO1xuXG4gICAgICBpZiAoZGF0YU9mZnNldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9mZnNldHMuaGFzQXBwTWFya2VycyA9IHRydWU7XG4gICAgICAgIG9mZnNldHMueG1wQ2h1bmtzID0gW3tcbiAgICAgICAgICBkYXRhT2Zmc2V0OiBkYXRhT2Zmc2V0LFxuICAgICAgICAgIGxlbmd0aDogZGF0YVZpZXcuZ2V0VWludDMyKG9mZnNldCArIFBOR19DSFVOS19MRU5HVEhfT0ZGU0VUKSAtIChkYXRhT2Zmc2V0IC0gKG9mZnNldCArIFBOR19DSFVOS19EQVRBX09GRlNFVCkpXG4gICAgICAgIH1dO1xuICAgICAgfVxuICAgIH1cblxuICAgIG9mZnNldCArPSBkYXRhVmlldy5nZXRVaW50MzIob2Zmc2V0ICsgUE5HX0NIVU5LX0xFTkdUSF9PRkZTRVQpICsgUE5HX0NIVU5LX0xFTkdUSF9TSVpFICsgUE5HX0NIVU5LX1RZUEVfU0laRSArIFBOR19DUkNfU0laRTtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRzO1xufVxuXG5mdW5jdGlvbiBpc1BuZ0ltYWdlSGVhZGVyQ2h1bmsoZGF0YVZpZXcsIG9mZnNldCkge1xuICB2YXIgUE5HX0NIVU5LX1RZUEVfSU1BR0VfSEVBREVSID0gJ0lIRFInO1xuICByZXR1cm4gT2JqZWN0KF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZ2V0U3RyaW5nRnJvbURhdGFWaWV3XCJdKShkYXRhVmlldywgb2Zmc2V0ICsgUE5HX0NIVU5LX1RZUEVfT0ZGU0VULCBQTkdfQ0hVTktfVFlQRV9TSVpFKSA9PT0gUE5HX0NIVU5LX1RZUEVfSU1BR0VfSEVBREVSO1xufVxuXG5mdW5jdGlvbiBpc1BuZ1htcENodW5rKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgdmFyIFBOR19DSFVOS19UWVBFX0lOVEVSTkFUSU9OQUxfVEVYVCA9ICdpVFh0JztcbiAgcmV0dXJuIE9iamVjdChfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImdldFN0cmluZ0Zyb21EYXRhVmlld1wiXSkoZGF0YVZpZXcsIG9mZnNldCArIFBOR19DSFVOS19UWVBFX09GRlNFVCwgUE5HX0NIVU5LX1RZUEVfU0laRSkgPT09IFBOR19DSFVOS19UWVBFX0lOVEVSTkFUSU9OQUxfVEVYVCAmJiBPYmplY3QoX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJnZXRTdHJpbmdGcm9tRGF0YVZpZXdcIl0pKGRhdGFWaWV3LCBvZmZzZXQgKyBQTkdfQ0hVTktfREFUQV9PRkZTRVQsIFBOR19YTVBfUFJFRklYLmxlbmd0aCkgPT09IFBOR19YTVBfUFJFRklYO1xufVxuXG5mdW5jdGlvbiBnZXRQbmdYbXBEYXRhT2Zmc2V0KGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgdmFyIENPTVBSRVNTSU9OX0ZMQUdfU0laRSA9IDE7XG4gIHZhciBDT01QUkVTU0lPTl9NRVRIT0RfU0laRSA9IDE7XG4gIG9mZnNldCArPSBQTkdfQ0hVTktfREFUQV9PRkZTRVQgKyBQTkdfWE1QX1BSRUZJWC5sZW5ndGggKyBDT01QUkVTU0lPTl9GTEFHX1NJWkUgKyBDT01QUkVTU0lPTl9NRVRIT0RfU0laRTtcbiAgdmFyIG51bWJlck9mTnVsbFNlcGFyYXRvcnMgPSAwO1xuXG4gIHdoaWxlIChudW1iZXJPZk51bGxTZXBhcmF0b3JzIDwgMiAmJiBvZmZzZXQgPCBkYXRhVmlldy5ieXRlTGVuZ3RoKSB7XG4gICAgaWYgKGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCkgPT09IDB4MDApIHtcbiAgICAgIG51bWJlck9mTnVsbFNlcGFyYXRvcnMrKztcbiAgICB9XG5cbiAgICBvZmZzZXQrKztcbiAgfVxuXG4gIGlmIChudW1iZXJPZk51bGxTZXBhcmF0b3JzIDwgMikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0O1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9pbWFnZS1oZWFkZXItdGlmZi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9pbWFnZS1oZWFkZXItdGlmZi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ieXRlX29yZGVyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2J5dGUtb3JkZXIuanMgKi8gXCIuL3NyYy9ieXRlLW9yZGVyLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb25zdGFudHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29uc3RhbnRzLmpzICovIFwiLi9zcmMvY29uc3RhbnRzLmpzXCIpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uICovXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gIGlzVGlmZkZpbGU6IGlzVGlmZkZpbGUsXG4gIGZpbmRUaWZmT2Zmc2V0czogZmluZFRpZmZPZmZzZXRzXG59KTtcblxuZnVuY3Rpb24gaXNUaWZmRmlsZShkYXRhVmlldykge1xuICB2YXIgTUlOX1RJRkZfREFUQV9CVUZGRVJfTEVOR1RIID0gNDtcbiAgcmV0dXJuIGRhdGFWaWV3LmJ5dGVMZW5ndGggPj0gTUlOX1RJRkZfREFUQV9CVUZGRVJfTEVOR1RIICYmIGhhc1RpZmZNYXJrZXIoZGF0YVZpZXcpO1xufVxuXG5mdW5jdGlvbiBoYXNUaWZmTWFya2VyKGRhdGFWaWV3KSB7XG4gIHZhciBUSUZGX0lEID0gMHgyYTtcbiAgdmFyIFRJRkZfSURfT0ZGU0VUID0gMjtcbiAgdmFyIGxpdHRsZUVuZGlhbiA9IGRhdGFWaWV3LmdldFVpbnQxNigwKSA9PT0gX2J5dGVfb3JkZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0uTElUVExFX0VORElBTjtcbiAgcmV0dXJuIGRhdGFWaWV3LmdldFVpbnQxNihUSUZGX0lEX09GRlNFVCwgbGl0dGxlRW5kaWFuKSA9PT0gVElGRl9JRDtcbn1cblxuZnVuY3Rpb24gZmluZFRpZmZPZmZzZXRzKCkge1xuICB2YXIgVElGRl9GSUxFX0hFQURFUl9PRkZTRVQgPSAwO1xuXG4gIGlmIChfY29uc3RhbnRzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLlVTRV9FWElGKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhhc0FwcE1hcmtlcnM6IHRydWUsXG4gICAgICB0aWZmSGVhZGVyT2Zmc2V0OiBUSUZGX0ZJTEVfSEVBREVSX09GRlNFVFxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge307XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2ltYWdlLWhlYWRlci13ZWJwLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2ltYWdlLWhlYWRlci13ZWJwLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzLmpzICovIFwiLi9zcmMvdXRpbHMuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbnN0YW50c19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb25zdGFudHMuanMgKi8gXCIuL3NyYy9jb25zdGFudHMuanNcIik7XG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy4gKi9cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgaXNXZWJwRmlsZTogaXNXZWJwRmlsZSxcbiAgZmluZE9mZnNldHM6IGZpbmRPZmZzZXRzXG59KTtcblxuZnVuY3Rpb24gaXNXZWJwRmlsZShkYXRhVmlldykge1xuICB2YXIgUklGRl9JRF9PRkZTRVQgPSAwO1xuICB2YXIgUklGRl9JRCA9ICdSSUZGJztcbiAgdmFyIFdFQlBfTUFSS0VSX09GRlNFVCA9IDg7XG4gIHZhciBXRUJQX01BUktFUiA9ICdXRUJQJztcbiAgcmV0dXJuIE9iamVjdChfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImdldFN0cmluZ0Zyb21EYXRhVmlld1wiXSkoZGF0YVZpZXcsIFJJRkZfSURfT0ZGU0VULCBSSUZGX0lELmxlbmd0aCkgPT09IFJJRkZfSUQgJiYgT2JqZWN0KF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZ2V0U3RyaW5nRnJvbURhdGFWaWV3XCJdKShkYXRhVmlldywgV0VCUF9NQVJLRVJfT0ZGU0VULCBXRUJQX01BUktFUi5sZW5ndGgpID09PSBXRUJQX01BUktFUjtcbn1cblxuZnVuY3Rpb24gZmluZE9mZnNldHMoZGF0YVZpZXcpIHtcbiAgdmFyIFNVQl9DSFVOS19TVEFSVF9PRkZTRVQgPSAxMjtcbiAgdmFyIENIVU5LX1NJWkVfT0ZGU0VUID0gNDtcbiAgdmFyIEVYSUZfSURFTlRJRklFUiA9ICdFeGlmXFx4MDBcXHgwMCc7XG4gIHZhciBDSFVOS19IRUFERVJfU0laRSA9IDg7XG4gIHZhciBvZmZzZXQgPSBTVUJfQ0hVTktfU1RBUlRfT0ZGU0VUO1xuICB2YXIgaGFzQXBwTWFya2VycyA9IGZhbHNlO1xuICB2YXIgdGlmZkhlYWRlck9mZnNldDtcbiAgdmFyIHhtcENodW5rcztcbiAgdmFyIGljY0NodW5rcztcblxuICB3aGlsZSAob2Zmc2V0ICsgQ0hVTktfSEVBREVSX1NJWkUgPCBkYXRhVmlldy5ieXRlTGVuZ3RoKSB7XG4gICAgdmFyIGNodW5rSWQgPSBPYmplY3QoX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJnZXRTdHJpbmdGcm9tRGF0YVZpZXdcIl0pKGRhdGFWaWV3LCBvZmZzZXQsIDQpO1xuICAgIHZhciBjaHVua1NpemUgPSBkYXRhVmlldy5nZXRVaW50MzIob2Zmc2V0ICsgQ0hVTktfU0laRV9PRkZTRVQsIHRydWUpO1xuXG4gICAgaWYgKF9jb25zdGFudHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0uVVNFX0VYSUYgJiYgY2h1bmtJZCA9PT0gJ0VYSUYnKSB7XG4gICAgICBoYXNBcHBNYXJrZXJzID0gdHJ1ZTtcblxuICAgICAgaWYgKE9iamVjdChfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImdldFN0cmluZ0Zyb21EYXRhVmlld1wiXSkoZGF0YVZpZXcsIG9mZnNldCArIENIVU5LX0hFQURFUl9TSVpFLCBFWElGX0lERU5USUZJRVIubGVuZ3RoKSA9PT0gRVhJRl9JREVOVElGSUVSKSB7XG4gICAgICAgIHRpZmZIZWFkZXJPZmZzZXQgPSBvZmZzZXQgKyBDSFVOS19IRUFERVJfU0laRSArIEVYSUZfSURFTlRJRklFUi5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWZmSGVhZGVyT2Zmc2V0ID0gb2Zmc2V0ICsgQ0hVTktfSEVBREVSX1NJWkU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChfY29uc3RhbnRzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLlVTRV9YTVAgJiYgY2h1bmtJZCA9PT0gJ1hNUCAnKSB7XG4gICAgICBoYXNBcHBNYXJrZXJzID0gdHJ1ZTtcbiAgICAgIHhtcENodW5rcyA9IFt7XG4gICAgICAgIGRhdGFPZmZzZXQ6IG9mZnNldCArIENIVU5LX0hFQURFUl9TSVpFLFxuICAgICAgICBsZW5ndGg6IGNodW5rU2l6ZVxuICAgICAgfV07XG4gICAgfSBlbHNlIGlmIChfY29uc3RhbnRzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLlVTRV9JQ0MgJiYgY2h1bmtJZCA9PT0gJ0lDQ1AnKSB7XG4gICAgICBoYXNBcHBNYXJrZXJzID0gdHJ1ZTtcbiAgICAgIGljY0NodW5rcyA9IFt7XG4gICAgICAgIG9mZnNldDogb2Zmc2V0ICsgQ0hVTktfSEVBREVSX1NJWkUsXG4gICAgICAgIGxlbmd0aDogY2h1bmtTaXplLFxuICAgICAgICBjaHVua051bWJlcjogMSxcbiAgICAgICAgY2h1bmtzVG90YWw6IDFcbiAgICAgIH1dO1xuICAgIH1cblxuICAgIG9mZnNldCArPSBDSFVOS19IRUFERVJfU0laRSArIChjaHVua1NpemUgJSAyID09PSAwID8gY2h1bmtTaXplIDogY2h1bmtTaXplICsgMSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGhhc0FwcE1hcmtlcnM6IGhhc0FwcE1hcmtlcnMsXG4gICAgdGlmZkhlYWRlck9mZnNldDogdGlmZkhlYWRlck9mZnNldCxcbiAgICB4bXBDaHVua3M6IHhtcENodW5rcyxcbiAgICBpY2NDaHVua3M6IGljY0NodW5rc1xuICB9O1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9pbWFnZS1oZWFkZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2ltYWdlLWhlYWRlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29uc3RhbnRzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnN0YW50cy5qcyAqLyBcIi4vc3JjL2NvbnN0YW50cy5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaW1hZ2VfaGVhZGVyX3RpZmZfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW1hZ2UtaGVhZGVyLXRpZmYuanMgKi8gXCIuL3NyYy9pbWFnZS1oZWFkZXItdGlmZi5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaW1hZ2VfaGVhZGVyX2pwZWdfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW1hZ2UtaGVhZGVyLWpwZWcuanMgKi8gXCIuL3NyYy9pbWFnZS1oZWFkZXItanBlZy5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaW1hZ2VfaGVhZGVyX3BuZ19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbWFnZS1oZWFkZXItcG5nLmpzICovIFwiLi9zcmMvaW1hZ2UtaGVhZGVyLXBuZy5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaW1hZ2VfaGVhZGVyX2hlaWNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW1hZ2UtaGVhZGVyLWhlaWMuanMgKi8gXCIuL3NyYy9pbWFnZS1oZWFkZXItaGVpYy5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaW1hZ2VfaGVhZGVyX3dlYnBfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW1hZ2UtaGVhZGVyLXdlYnAuanMgKi8gXCIuL3NyYy9pbWFnZS1oZWFkZXItd2VicC5qc1wiKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwczovL21vemlsbGEub3JnL01QTC8yLjAvLiAqL1xuXG5cblxuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gIHBhcnNlQXBwTWFya2VyczogcGFyc2VBcHBNYXJrZXJzXG59KTtcblxuZnVuY3Rpb24gcGFyc2VBcHBNYXJrZXJzKGRhdGFWaWV3KSB7XG4gIGlmIChfY29uc3RhbnRzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdLlVTRV9USUZGICYmIF9pbWFnZV9oZWFkZXJfdGlmZl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXS5pc1RpZmZGaWxlKGRhdGFWaWV3KSkge1xuICAgIHJldHVybiBfaW1hZ2VfaGVhZGVyX3RpZmZfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0uZmluZFRpZmZPZmZzZXRzKCk7XG4gIH1cblxuICBpZiAoX2NvbnN0YW50c19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXS5VU0VfSlBFRyAmJiBfaW1hZ2VfaGVhZGVyX2pwZWdfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0uaXNKcGVnRmlsZShkYXRhVmlldykpIHtcbiAgICByZXR1cm4gX2ltYWdlX2hlYWRlcl9qcGVnX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdLmZpbmRKcGVnT2Zmc2V0cyhkYXRhVmlldyk7XG4gIH1cblxuICBpZiAoX2NvbnN0YW50c19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXS5VU0VfUE5HICYmIF9pbWFnZV9oZWFkZXJfcG5nX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdLmlzUG5nRmlsZShkYXRhVmlldykpIHtcbiAgICByZXR1cm4gX2ltYWdlX2hlYWRlcl9wbmdfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0uZmluZFBuZ09mZnNldHMoZGF0YVZpZXcpO1xuICB9XG5cbiAgaWYgKF9jb25zdGFudHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0uVVNFX0hFSUMgJiYgX2ltYWdlX2hlYWRlcl9oZWljX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJkZWZhdWx0XCJdLmlzSGVpY0ZpbGUoZGF0YVZpZXcpKSB7XG4gICAgcmV0dXJuIF9pbWFnZV9oZWFkZXJfaGVpY19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiZGVmYXVsdFwiXS5maW5kSGVpY09mZnNldHMoZGF0YVZpZXcpO1xuICB9XG5cbiAgaWYgKF9jb25zdGFudHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0uVVNFX1dFQlAgJiYgX2ltYWdlX2hlYWRlcl93ZWJwX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJkZWZhdWx0XCJdLmlzV2VicEZpbGUoZGF0YVZpZXcpKSB7XG4gICAgcmV0dXJuIF9pbWFnZV9oZWFkZXJfd2VicF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZGVmYXVsdFwiXS5maW5kT2Zmc2V0cyhkYXRhVmlldyk7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW1hZ2UgZm9ybWF0Jyk7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2lwdGMtdGFnLW5hbWVzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2lwdGMtdGFnLW5hbWVzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3RhZ19uYW1lc191dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90YWctbmFtZXMtdXRpbHMuanMgKi8gXCIuL3NyYy90YWctbmFtZXMtdXRpbHMuanNcIik7XG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy4gKi9cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICdpcHRjJzoge1xuICAgIDB4MDEwMDoge1xuICAgICAgJ25hbWUnOiAnTW9kZWwgVmVyc2lvbicsXG4gICAgICAnZGVzY3JpcHRpb24nOiBmdW5jdGlvbiBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKCh2YWx1ZVswXSA8PCA4KSArIHZhbHVlWzFdKS50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgMHgwMTA1OiB7XG4gICAgICAnbmFtZSc6ICdEZXN0aW5hdGlvbicsXG4gICAgICAncmVwZWF0YWJsZSc6IHRydWVcbiAgICB9LFxuICAgIDB4MDExNDoge1xuICAgICAgJ25hbWUnOiAnRmlsZSBGb3JtYXQnLFxuICAgICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICgodmFsdWVbMF0gPDwgOCkgKyB2YWx1ZVsxXSkudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIDB4MDExNjoge1xuICAgICAgJ25hbWUnOiAnRmlsZSBGb3JtYXQgVmVyc2lvbicsXG4gICAgICAnZGVzY3JpcHRpb24nOiBmdW5jdGlvbiBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKCh2YWx1ZVswXSA8PCA4KSArIHZhbHVlWzFdKS50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgMHgwMTFlOiAnU2VydmljZSBJZGVudGlmaWVyJyxcbiAgICAweDAxMjg6ICdFbnZlbG9wZSBOdW1iZXInLFxuICAgIDB4MDEzMjogJ1Byb2R1Y3QgSUQnLFxuICAgIDB4MDEzYzogJ0VudmVsb3BlIFByaW9yaXR5JyxcbiAgICAweDAxNDY6IHtcbiAgICAgICduYW1lJzogJ0RhdGUgU2VudCcsXG4gICAgICAnZGVzY3JpcHRpb24nOiBnZXRDcmVhdGlvbkRhdGVcbiAgICB9LFxuICAgIDB4MDE1MDoge1xuICAgICAgJ25hbWUnOiAnVGltZSBTZW50JyxcbiAgICAgICdkZXNjcmlwdGlvbic6IGdldENyZWF0aW9uVGltZVxuICAgIH0sXG4gICAgMHgwMTVhOiB7XG4gICAgICAnbmFtZSc6ICdDb2RlZCBDaGFyYWN0ZXIgU2V0JyxcbiAgICAgICdkZXNjcmlwdGlvbic6IGdldEVuY29kaW5nTmFtZSxcbiAgICAgICdlbmNvZGluZ19uYW1lJzogZ2V0RW5jb2RpbmdOYW1lXG4gICAgfSxcbiAgICAweDAxNjQ6ICdVTk8nLFxuICAgIDB4MDE3ODoge1xuICAgICAgJ25hbWUnOiAnQVJNIElkZW50aWZpZXInLFxuICAgICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICgodmFsdWVbMF0gPDwgOCkgKyB2YWx1ZVsxXSkudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIDB4MDE3YToge1xuICAgICAgJ25hbWUnOiAnQVJNIFZlcnNpb24nLFxuICAgICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICgodmFsdWVbMF0gPDwgOCkgKyB2YWx1ZVsxXSkudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIDB4MDIwMDoge1xuICAgICAgJ25hbWUnOiAnUmVjb3JkIFZlcnNpb24nLFxuICAgICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICgodmFsdWVbMF0gPDwgOCkgKyB2YWx1ZVsxXSkudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIDB4MDIwMzogJ09iamVjdCBUeXBlIFJlZmVyZW5jZScsXG4gICAgMHgwMjA0OiAnT2JqZWN0IEF0dHJpYnV0ZSBSZWZlcmVuY2UnLFxuICAgIDB4MDIwNTogJ09iamVjdCBOYW1lJyxcbiAgICAweDAyMDc6ICdFZGl0IFN0YXR1cycsXG4gICAgMHgwMjA4OiB7XG4gICAgICAnbmFtZSc6ICdFZGl0b3JpYWwgVXBkYXRlJyxcbiAgICAgICdkZXNjcmlwdGlvbic6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmIChPYmplY3QoX3RhZ19uYW1lc191dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZ2V0U3RyaW5nVmFsdWVcIl0pKHZhbHVlKSA9PT0gJzAxJykge1xuICAgICAgICAgIHJldHVybiAnQWRkaXRpb25hbCBMYW5ndWFnZSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJ1Vua25vd24nO1xuICAgICAgfVxuICAgIH0sXG4gICAgMHgwMjBhOiAnVXJnZW5jeScsXG4gICAgMHgwMjBjOiB7XG4gICAgICAnbmFtZSc6ICdTdWJqZWN0IFJlZmVyZW5jZScsXG4gICAgICAncmVwZWF0YWJsZSc6IHRydWUsXG4gICAgICAnZGVzY3JpcHRpb24nOiBmdW5jdGlvbiBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgcGFydHMgPSBPYmplY3QoX3RhZ19uYW1lc191dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZ2V0U3RyaW5nVmFsdWVcIl0pKHZhbHVlKS5zcGxpdCgnOicpO1xuICAgICAgICByZXR1cm4gcGFydHNbMl0gKyAocGFydHNbM10gPyAnLycgKyBwYXJ0c1szXSA6ICcnKSArIChwYXJ0c1s0XSA/ICcvJyArIHBhcnRzWzRdIDogJycpO1xuICAgICAgfVxuICAgIH0sXG4gICAgMHgwMjBmOiAnQ2F0ZWdvcnknLFxuICAgIDB4MDIxNDoge1xuICAgICAgJ25hbWUnOiAnU3VwcGxlbWVudGFsIENhdGVnb3J5JyxcbiAgICAgICdyZXBlYXRhYmxlJzogdHJ1ZVxuICAgIH0sXG4gICAgMHgwMjE2OiAnRml4dHVyZSBJZGVudGlmaWVyJyxcbiAgICAweDAyMTk6IHtcbiAgICAgICduYW1lJzogJ0tleXdvcmRzJyxcbiAgICAgICdyZXBlYXRhYmxlJzogdHJ1ZVxuICAgIH0sXG4gICAgMHgwMjFhOiB7XG4gICAgICAnbmFtZSc6ICdDb250ZW50IExvY2F0aW9uIENvZGUnLFxuICAgICAgJ3JlcGVhdGFibGUnOiB0cnVlXG4gICAgfSxcbiAgICAweDAyMWI6IHtcbiAgICAgICduYW1lJzogJ0NvbnRlbnQgTG9jYXRpb24gTmFtZScsXG4gICAgICAncmVwZWF0YWJsZSc6IHRydWVcbiAgICB9LFxuICAgIDB4MDIxZTogJ1JlbGVhc2UgRGF0ZScsXG4gICAgMHgwMjIzOiAnUmVsZWFzZSBUaW1lJyxcbiAgICAweDAyMjU6ICdFeHBpcmF0aW9uIERhdGUnLFxuICAgIDB4MDIyNjogJ0V4cGlyYXRpb24gVGltZScsXG4gICAgMHgwMjI4OiAnU3BlY2lhbCBJbnN0cnVjdGlvbnMnLFxuICAgIDB4MDIyYToge1xuICAgICAgJ25hbWUnOiAnQWN0aW9uIEFkdmlzZWQnLFxuICAgICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHN0cmluZyA9IE9iamVjdChfdGFnX25hbWVzX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJnZXRTdHJpbmdWYWx1ZVwiXSkodmFsdWUpO1xuXG4gICAgICAgIGlmIChzdHJpbmcgPT09ICcwMScpIHtcbiAgICAgICAgICByZXR1cm4gJ09iamVjdCBLaWxsJztcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpbmcgPT09ICcwMicpIHtcbiAgICAgICAgICByZXR1cm4gJ09iamVjdCBSZXBsYWNlJztcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpbmcgPT09ICcwMycpIHtcbiAgICAgICAgICByZXR1cm4gJ09iamVjdCBBcHBlbmQnO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmluZyA9PT0gJzA0Jykge1xuICAgICAgICAgIHJldHVybiAnT2JqZWN0IFJlZmVyZW5jZSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJ1Vua25vd24nO1xuICAgICAgfVxuICAgIH0sXG4gICAgMHgwMjJkOiB7XG4gICAgICAnbmFtZSc6ICdSZWZlcmVuY2UgU2VydmljZScsXG4gICAgICAncmVwZWF0YWJsZSc6IHRydWVcbiAgICB9LFxuICAgIDB4MDIyZjoge1xuICAgICAgJ25hbWUnOiAnUmVmZXJlbmNlIERhdGUnLFxuICAgICAgJ3JlcGVhdGFibGUnOiB0cnVlXG4gICAgfSxcbiAgICAweDAyMzI6IHtcbiAgICAgICduYW1lJzogJ1JlZmVyZW5jZSBOdW1iZXInLFxuICAgICAgJ3JlcGVhdGFibGUnOiB0cnVlXG4gICAgfSxcbiAgICAweDAyMzc6IHtcbiAgICAgICduYW1lJzogJ0RhdGUgQ3JlYXRlZCcsXG4gICAgICAnZGVzY3JpcHRpb24nOiBnZXRDcmVhdGlvbkRhdGVcbiAgICB9LFxuICAgIDB4MDIzYzoge1xuICAgICAgJ25hbWUnOiAnVGltZSBDcmVhdGVkJyxcbiAgICAgICdkZXNjcmlwdGlvbic6IGdldENyZWF0aW9uVGltZVxuICAgIH0sXG4gICAgMHgwMjNlOiB7XG4gICAgICAnbmFtZSc6ICdEaWdpdGFsIENyZWF0aW9uIERhdGUnLFxuICAgICAgJ2Rlc2NyaXB0aW9uJzogZ2V0Q3JlYXRpb25EYXRlXG4gICAgfSxcbiAgICAweDAyM2Y6IHtcbiAgICAgICduYW1lJzogJ0RpZ2l0YWwgQ3JlYXRpb24gVGltZScsXG4gICAgICAnZGVzY3JpcHRpb24nOiBnZXRDcmVhdGlvblRpbWVcbiAgICB9LFxuICAgIDB4MDI0MTogJ09yaWdpbmF0aW5nIFByb2dyYW0nLFxuICAgIDB4MDI0NjogJ1Byb2dyYW0gVmVyc2lvbicsXG4gICAgMHgwMjRiOiB7XG4gICAgICAnbmFtZSc6ICdPYmplY3QgQ3ljbGUnLFxuICAgICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHN0cmluZyA9IE9iamVjdChfdGFnX25hbWVzX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJnZXRTdHJpbmdWYWx1ZVwiXSkodmFsdWUpO1xuXG4gICAgICAgIGlmIChzdHJpbmcgPT09ICdhJykge1xuICAgICAgICAgIHJldHVybiAnbW9ybmluZyc7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyaW5nID09PSAncCcpIHtcbiAgICAgICAgICByZXR1cm4gJ2V2ZW5pbmcnO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmluZyA9PT0gJ2InKSB7XG4gICAgICAgICAgcmV0dXJuICdib3RoJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnVW5rbm93bic7XG4gICAgICB9XG4gICAgfSxcbiAgICAweDAyNTA6IHtcbiAgICAgICduYW1lJzogJ0J5LWxpbmUnLFxuICAgICAgJ3JlcGVhdGFibGUnOiB0cnVlXG4gICAgfSxcbiAgICAweDAyNTU6IHtcbiAgICAgICduYW1lJzogJ0J5LWxpbmUgVGl0bGUnLFxuICAgICAgJ3JlcGVhdGFibGUnOiB0cnVlXG4gICAgfSxcbiAgICAweDAyNWE6ICdDaXR5JyxcbiAgICAweDAyNWM6ICdTdWItbG9jYXRpb24nLFxuICAgIDB4MDI1ZjogJ1Byb3ZpbmNlL1N0YXRlJyxcbiAgICAweDAyNjQ6ICdDb3VudHJ5L1ByaW1hcnkgTG9jYXRpb24gQ29kZScsXG4gICAgMHgwMjY1OiAnQ291bnRyeS9QcmltYXJ5IExvY2F0aW9uIE5hbWUnLFxuICAgIDB4MDI2NzogJ09yaWdpbmFsIFRyYW5zbWlzc2lvbiBSZWZlcmVuY2UnLFxuICAgIDB4MDI2OTogJ0hlYWRsaW5lJyxcbiAgICAweDAyNmU6ICdDcmVkaXQnLFxuICAgIDB4MDI3MzogJ1NvdXJjZScsXG4gICAgMHgwMjc0OiAnQ29weXJpZ2h0IE5vdGljZScsXG4gICAgMHgwMjc2OiB7XG4gICAgICAnbmFtZSc6ICdDb250YWN0JyxcbiAgICAgICdyZXBlYXRhYmxlJzogdHJ1ZVxuICAgIH0sXG4gICAgMHgwMjc4OiAnQ2FwdGlvbi9BYnN0cmFjdCcsXG4gICAgMHgwMjdhOiB7XG4gICAgICAnbmFtZSc6ICdXcml0ZXIvRWRpdG9yJyxcbiAgICAgICdyZXBlYXRhYmxlJzogdHJ1ZVxuICAgIH0sXG4gICAgMHgwMjdkOiB7XG4gICAgICAnbmFtZSc6ICdSYXN0ZXJpemVkIENhcHRpb24nLFxuICAgICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgMHgwMjgyOiAnSW1hZ2UgVHlwZScsXG4gICAgMHgwMjgzOiB7XG4gICAgICAnbmFtZSc6ICdJbWFnZSBPcmllbnRhdGlvbicsXG4gICAgICAnZGVzY3JpcHRpb24nOiBmdW5jdGlvbiBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgc3RyaW5nID0gT2JqZWN0KF90YWdfbmFtZXNfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImdldFN0cmluZ1ZhbHVlXCJdKSh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKHN0cmluZyA9PT0gJ1AnKSB7XG4gICAgICAgICAgcmV0dXJuICdQb3J0cmFpdCc7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyaW5nID09PSAnTCcpIHtcbiAgICAgICAgICByZXR1cm4gJ0xhbmRzY2FwZSc7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyaW5nID09PSAnUycpIHtcbiAgICAgICAgICByZXR1cm4gJ1NxdWFyZSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJ1Vua25vd24nO1xuICAgICAgfVxuICAgIH0sXG4gICAgMHgwMjg3OiAnTGFuZ3VhZ2UgSWRlbnRpZmllcicsXG4gICAgMHgwMjk2OiB7XG4gICAgICAnbmFtZSc6ICdBdWRpbyBUeXBlJyxcbiAgICAgICdkZXNjcmlwdGlvbic6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBzdHJpbmdWYWx1ZSA9IE9iamVjdChfdGFnX25hbWVzX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJnZXRTdHJpbmdWYWx1ZVwiXSkodmFsdWUpO1xuICAgICAgICB2YXIgY2hhcmFjdGVyMCA9IHN0cmluZ1ZhbHVlLmNoYXJBdCgwKTtcbiAgICAgICAgdmFyIGNoYXJhY3RlcjEgPSBzdHJpbmdWYWx1ZS5jaGFyQXQoMSk7XG4gICAgICAgIHZhciBkZXNjcmlwdGlvbiA9ICcnO1xuXG4gICAgICAgIGlmIChjaGFyYWN0ZXIwID09PSAnMScpIHtcbiAgICAgICAgICBkZXNjcmlwdGlvbiArPSAnTW9ubyc7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhcmFjdGVyMCA9PT0gJzInKSB7XG4gICAgICAgICAgZGVzY3JpcHRpb24gKz0gJ1N0ZXJlbyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hhcmFjdGVyMSA9PT0gJ0EnKSB7XG4gICAgICAgICAgZGVzY3JpcHRpb24gKz0gJywgYWN0dWFsaXR5JztcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyYWN0ZXIxID09PSAnQycpIHtcbiAgICAgICAgICBkZXNjcmlwdGlvbiArPSAnLCBxdWVzdGlvbiBhbmQgYW5zd2VyIHNlc3Npb24nO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXJhY3RlcjEgPT09ICdNJykge1xuICAgICAgICAgIGRlc2NyaXB0aW9uICs9ICcsIG11c2ljLCB0cmFuc21pdHRlZCBieSBpdHNlbGYnO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXJhY3RlcjEgPT09ICdRJykge1xuICAgICAgICAgIGRlc2NyaXB0aW9uICs9ICcsIHJlc3BvbnNlIHRvIGEgcXVlc3Rpb24nO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXJhY3RlcjEgPT09ICdSJykge1xuICAgICAgICAgIGRlc2NyaXB0aW9uICs9ICcsIHJhdyBzb3VuZCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhcmFjdGVyMSA9PT0gJ1MnKSB7XG4gICAgICAgICAgZGVzY3JpcHRpb24gKz0gJywgc2NlbmVyJztcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyYWN0ZXIxID09PSAnVicpIHtcbiAgICAgICAgICBkZXNjcmlwdGlvbiArPSAnLCB2b2ljZXInO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXJhY3RlcjEgPT09ICdXJykge1xuICAgICAgICAgIGRlc2NyaXB0aW9uICs9ICcsIHdyYXAnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uICE9PSAnJykge1xuICAgICAgICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHJpbmdWYWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIDB4MDI5Nzoge1xuICAgICAgJ25hbWUnOiAnQXVkaW8gU2FtcGxpbmcgUmF0ZScsXG4gICAgICAnZGVzY3JpcHRpb24nOiBmdW5jdGlvbiBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoT2JqZWN0KF90YWdfbmFtZXNfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImdldFN0cmluZ1ZhbHVlXCJdKSh2YWx1ZSksIDEwKSArICcgSHonO1xuICAgICAgfVxuICAgIH0sXG4gICAgMHgwMjk4OiB7XG4gICAgICAnbmFtZSc6ICdBdWRpbyBTYW1wbGluZyBSZXNvbHV0aW9uJyxcbiAgICAgICdkZXNjcmlwdGlvbic6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBiaXRzID0gcGFyc2VJbnQoT2JqZWN0KF90YWdfbmFtZXNfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImdldFN0cmluZ1ZhbHVlXCJdKSh2YWx1ZSksIDEwKTtcbiAgICAgICAgcmV0dXJuIGJpdHMgKyAoYml0cyA9PT0gMSA/ICcgYml0JyA6ICcgYml0cycpO1xuICAgICAgfVxuICAgIH0sXG4gICAgMHgwMjk5OiB7XG4gICAgICAnbmFtZSc6ICdBdWRpbyBEdXJhdGlvbicsXG4gICAgICAnZGVzY3JpcHRpb24nOiBmdW5jdGlvbiBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBPYmplY3QoX3RhZ19uYW1lc191dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZ2V0U3RyaW5nVmFsdWVcIl0pKHZhbHVlKTtcblxuICAgICAgICBpZiAoZHVyYXRpb24ubGVuZ3RoID49IDYpIHtcbiAgICAgICAgICByZXR1cm4gZHVyYXRpb24uc3Vic3RyKDAsIDIpICsgJzonICsgZHVyYXRpb24uc3Vic3RyKDIsIDIpICsgJzonICsgZHVyYXRpb24uc3Vic3RyKDQsIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uO1xuICAgICAgfVxuICAgIH0sXG4gICAgMHgwMjlhOiAnQXVkaW8gT3V0Y3VlJyxcbiAgICAweDAyYmE6ICdTaG9ydCBEb2N1bWVudCBJRCcsXG4gICAgMHgwMmJiOiAnVW5pcXVlIERvY3VtZW50IElEJyxcbiAgICAweDAyYmM6ICdPd25lciBJRCcsXG4gICAgMHgwMmM4OiB7XG4gICAgICAnbmFtZSc6IGZ1bmN0aW9uIG5hbWUodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIHJldHVybiAnT2JqZWN0RGF0YSBQcmV2aWV3IEZpbGUgRm9ybWF0JztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnUmVjb3JkIDIgZGVzdGluYXRpb24nO1xuICAgICAgfSxcbiAgICAgICdkZXNjcmlwdGlvbic6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICB2YXIgaW50VmFsdWUgPSAodmFsdWVbMF0gPDwgOCkgKyB2YWx1ZVsxXTtcblxuICAgICAgICAgIGlmIChpbnRWYWx1ZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICdObyBPYmplY3REYXRhJztcbiAgICAgICAgICB9IGVsc2UgaWYgKGludFZhbHVlID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0lQVEMtTkFBIERpZ2l0YWwgTmV3c3Bob3RvIFBhcmFtZXRlciBSZWNvcmQnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW50VmFsdWUgPT09IDIpIHtcbiAgICAgICAgICAgIHJldHVybiAnSVBUQzc5MDEgUmVjb21tZW5kZWQgTWVzc2FnZSBGb3JtYXQnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW50VmFsdWUgPT09IDMpIHtcbiAgICAgICAgICAgIHJldHVybiAnVGFnZ2VkIEltYWdlIEZpbGUgRm9ybWF0IChBZG9iZS9BbGR1cyBJbWFnZSBkYXRhKSc7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbnRWYWx1ZSA9PT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuICdJbGx1c3RyYXRvciAoQWRvYmUgR3JhcGhpY3MgZGF0YSknO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW50VmFsdWUgPT09IDUpIHtcbiAgICAgICAgICAgIHJldHVybiAnQXBwbGVTaW5nbGUgKEFwcGxlIENvbXB1dGVyIEluYyknO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW50VmFsdWUgPT09IDYpIHtcbiAgICAgICAgICAgIHJldHVybiAnTkFBIDg5LTMgKEFOUEEgMTMxMiknO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW50VmFsdWUgPT09IDcpIHtcbiAgICAgICAgICAgIHJldHVybiAnTWFjQmluYXJ5IElJJztcbiAgICAgICAgICB9IGVsc2UgaWYgKGludFZhbHVlID09PSA4KSB7XG4gICAgICAgICAgICByZXR1cm4gJ0lQVEMgVW5zdHJ1Y3R1cmVkIENoYXJhY3RlciBPcmllbnRlZCBGaWxlIEZvcm1hdCAoVUNPRkYpJztcbiAgICAgICAgICB9IGVsc2UgaWYgKGludFZhbHVlID09PSA5KSB7XG4gICAgICAgICAgICByZXR1cm4gJ1VuaXRlZCBQcmVzcyBJbnRlcm5hdGlvbmFsIEFOUEEgMTMxMiB2YXJpYW50JztcbiAgICAgICAgICB9IGVsc2UgaWYgKGludFZhbHVlID09PSAxMCkge1xuICAgICAgICAgICAgcmV0dXJuICdVbml0ZWQgUHJlc3MgSW50ZXJuYXRpb25hbCBEb3duLUxvYWQgTWVzc2FnZSc7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbnRWYWx1ZSA9PT0gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiAnSlBFRyBGaWxlIEludGVyY2hhbmdlIChKRklGKSc7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbnRWYWx1ZSA9PT0gMTIpIHtcbiAgICAgICAgICAgIHJldHVybiAnUGhvdG8tQ0QgSW1hZ2UtUGFjIChFYXN0bWFuIEtvZGFrKSc7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbnRWYWx1ZSA9PT0gMTMpIHtcbiAgICAgICAgICAgIHJldHVybiAnTWljcm9zb2Z0IEJpdCBNYXBwZWQgR3JhcGhpY3MgRmlsZSBbKi5CTVBdJztcbiAgICAgICAgICB9IGVsc2UgaWYgKGludFZhbHVlID09PSAxNCkge1xuICAgICAgICAgICAgcmV0dXJuICdEaWdpdGFsIEF1ZGlvIEZpbGUgWyouV0FWXSAoTWljcm9zb2Z0ICYgQ3JlYXRpdmUgTGFicyknO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW50VmFsdWUgPT09IDE1KSB7XG4gICAgICAgICAgICByZXR1cm4gJ0F1ZGlvIHBsdXMgTW92aW5nIFZpZGVvIFsqLkFWSV0gKE1pY3Jvc29mdCknO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW50VmFsdWUgPT09IDE2KSB7XG4gICAgICAgICAgICByZXR1cm4gJ1BDIERPUy9XaW5kb3dzIEV4ZWN1dGFibGUgRmlsZXMgWyouQ09NXVsqLkVYRV0nO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW50VmFsdWUgPT09IDE3KSB7XG4gICAgICAgICAgICByZXR1cm4gJ0NvbXByZXNzZWQgQmluYXJ5IEZpbGUgWyouWklQXSAoUEtXYXJlIEluYyknO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW50VmFsdWUgPT09IDE4KSB7XG4gICAgICAgICAgICByZXR1cm4gJ0F1ZGlvIEludGVyY2hhbmdlIEZpbGUgRm9ybWF0IEFJRkYgKEFwcGxlIENvbXB1dGVyIEluYyknO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW50VmFsdWUgPT09IDE5KSB7XG4gICAgICAgICAgICByZXR1cm4gJ1JJRkYgV2F2ZSAoTWljcm9zb2Z0IENvcnBvcmF0aW9uKSc7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbnRWYWx1ZSA9PT0gMjApIHtcbiAgICAgICAgICAgIHJldHVybiAnRnJlZWhhbmQgKE1hY3JvbWVkaWEvQWxkdXMpJztcbiAgICAgICAgICB9IGVsc2UgaWYgKGludFZhbHVlID09PSAyMSkge1xuICAgICAgICAgICAgcmV0dXJuICdIeXBlcnRleHQgTWFya3VwIExhbmd1YWdlIFwiSFRNTFwiIChUaGUgSW50ZXJuZXQgU29jaWV0eSknO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW50VmFsdWUgPT09IDIyKSB7XG4gICAgICAgICAgICByZXR1cm4gJ01QRUcgMiBBdWRpbyBMYXllciAyIChNdXNpY29tKSwgSVNPL0lFQyc7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbnRWYWx1ZSA9PT0gMjMpIHtcbiAgICAgICAgICAgIHJldHVybiAnTVBFRyAyIEF1ZGlvIExheWVyIDMsIElTTy9JRUMnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW50VmFsdWUgPT09IDI0KSB7XG4gICAgICAgICAgICByZXR1cm4gJ1BvcnRhYmxlIERvY3VtZW50IEZpbGUgKCouUERGKSBBZG9iZSc7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbnRWYWx1ZSA9PT0gMjUpIHtcbiAgICAgICAgICAgIHJldHVybiAnTmV3cyBJbmR1c3RyeSBUZXh0IEZvcm1hdCAoTklURiknO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW50VmFsdWUgPT09IDI2KSB7XG4gICAgICAgICAgICByZXR1cm4gJ1RhcGUgQXJjaGl2ZSAoKi5UQVIpJztcbiAgICAgICAgICB9IGVsc2UgaWYgKGludFZhbHVlID09PSAyNykge1xuICAgICAgICAgICAgcmV0dXJuICdUaWRuaW5nYXJuYXMgVGVsZWdyYW1ieXLDpSBOSVRGIHZlcnNpb24gKFRUTklURiBEVEQpJztcbiAgICAgICAgICB9IGVsc2UgaWYgKGludFZhbHVlID09PSAyOCkge1xuICAgICAgICAgICAgcmV0dXJuICdSaXR6YXVzIEJ1cmVhdSBOSVRGIHZlcnNpb24gKFJCTklURiBEVEQpJztcbiAgICAgICAgICB9IGVsc2UgaWYgKGludFZhbHVlID09PSAyOSkge1xuICAgICAgICAgICAgcmV0dXJuICdDb3JlbCBEcmF3IFsqLkNEUl0nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBcIlVua25vd24gZm9ybWF0IFwiLmNvbmNhdChpbnRWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gT2JqZWN0KF90YWdfbmFtZXNfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImdldFN0cmluZ1ZhbHVlXCJdKSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICAweDAyYzk6IHtcbiAgICAgICduYW1lJzogJ09iamVjdERhdGEgUHJldmlldyBGaWxlIEZvcm1hdCBWZXJzaW9uJyxcbiAgICAgICdkZXNjcmlwdGlvbic6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKHZhbHVlLCB0YWdzKSB7XG4gICAgICAgIC8vIEZvcm1hdCBJRCwgVmVyc2lvbiBJRCwgVmVyc2lvbiBEZXNjcmlwdGlvblxuICAgICAgICB2YXIgZm9ybWF0VmVyc2lvbnMgPSB7XG4gICAgICAgICAgJzAwJzoge1xuICAgICAgICAgICAgJzAwJzogJzEnXG4gICAgICAgICAgfSxcbiAgICAgICAgICAnMDEnOiB7XG4gICAgICAgICAgICAnMDEnOiAnMScsXG4gICAgICAgICAgICAnMDInOiAnMicsXG4gICAgICAgICAgICAnMDMnOiAnMycsXG4gICAgICAgICAgICAnMDQnOiAnNCdcbiAgICAgICAgICB9LFxuICAgICAgICAgICcwMic6IHtcbiAgICAgICAgICAgICcwNCc6ICc0J1xuICAgICAgICAgIH0sXG4gICAgICAgICAgJzAzJzoge1xuICAgICAgICAgICAgJzAxJzogJzUuMCcsXG4gICAgICAgICAgICAnMDInOiAnNi4wJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgJzA0Jzoge1xuICAgICAgICAgICAgJzAxJzogJzEuNDAnXG4gICAgICAgICAgfSxcbiAgICAgICAgICAnMDUnOiB7XG4gICAgICAgICAgICAnMDEnOiAnMidcbiAgICAgICAgICB9LFxuICAgICAgICAgICcwNic6IHtcbiAgICAgICAgICAgICcwMSc6ICcxJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgJzExJzoge1xuICAgICAgICAgICAgJzAxJzogJzEuMDInXG4gICAgICAgICAgfSxcbiAgICAgICAgICAnMjAnOiB7XG4gICAgICAgICAgICAnMDEnOiAnMy4xJyxcbiAgICAgICAgICAgICcwMic6ICc0LjAnLFxuICAgICAgICAgICAgJzAzJzogJzUuMCcsXG4gICAgICAgICAgICAnMDQnOiAnNS41J1xuICAgICAgICAgIH0sXG4gICAgICAgICAgJzIxJzoge1xuICAgICAgICAgICAgJzAyJzogJzIuMCdcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdHJpbmdWYWx1ZSA9IE9iamVjdChfdGFnX25hbWVzX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJnZXRTdHJpbmdWYWx1ZVwiXSkodmFsdWUpO1xuXG4gICAgICAgIGlmICh0YWdzWydPYmplY3REYXRhIFByZXZpZXcgRmlsZSBGb3JtYXQnXSkge1xuICAgICAgICAgIHZhciBvYmplY3REYXRhUHJldmlld0ZpbGVGb3JtYXQgPSBPYmplY3QoX3RhZ19uYW1lc191dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZ2V0U3RyaW5nVmFsdWVcIl0pKHRhZ3NbJ09iamVjdERhdGEgUHJldmlldyBGaWxlIEZvcm1hdCddLnZhbHVlKTtcblxuICAgICAgICAgIGlmIChmb3JtYXRWZXJzaW9uc1tvYmplY3REYXRhUHJldmlld0ZpbGVGb3JtYXRdICYmIGZvcm1hdFZlcnNpb25zW29iamVjdERhdGFQcmV2aWV3RmlsZUZvcm1hdF1bc3RyaW5nVmFsdWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0VmVyc2lvbnNbb2JqZWN0RGF0YVByZXZpZXdGaWxlRm9ybWF0XVtzdHJpbmdWYWx1ZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgMHgwMmNhOiAnT2JqZWN0RGF0YSBQcmV2aWV3IERhdGEnLFxuICAgIDB4MDcwYToge1xuICAgICAgJ25hbWUnOiAnU2l6ZSBNb2RlJyxcbiAgICAgICdkZXNjcmlwdGlvbic6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVswXS50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgMHgwNzE0OiB7XG4gICAgICAnbmFtZSc6ICdNYXggU3ViZmlsZSBTaXplJyxcbiAgICAgICdkZXNjcmlwdGlvbic6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBuID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbiA9IChuIDw8IDgpICsgdmFsdWVbaV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbi50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgMHgwNzVhOiB7XG4gICAgICAnbmFtZSc6ICdPYmplY3REYXRhIFNpemUgQW5ub3VuY2VkJyxcbiAgICAgICdkZXNjcmlwdGlvbic6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBuID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbiA9IChuIDw8IDgpICsgdmFsdWVbaV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbi50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgMHgwNzVmOiB7XG4gICAgICAnbmFtZSc6ICdNYXhpbXVtIE9iamVjdERhdGEgU2l6ZScsXG4gICAgICAnZGVzY3JpcHRpb24nOiBmdW5jdGlvbiBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgbiA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG4gPSAobiA8PCA4KSArIHZhbHVlW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG4udG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBnZXRDcmVhdGlvbkRhdGUodmFsdWUpIHtcbiAgdmFyIGRhdGUgPSBPYmplY3QoX3RhZ19uYW1lc191dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZ2V0U3RyaW5nVmFsdWVcIl0pKHZhbHVlKTtcblxuICBpZiAoZGF0ZS5sZW5ndGggPj0gOCkge1xuICAgIHJldHVybiBkYXRlLnN1YnN0cigwLCA0KSArICctJyArIGRhdGUuc3Vic3RyKDQsIDIpICsgJy0nICsgZGF0ZS5zdWJzdHIoNiwgMik7XG4gIH1cblxuICByZXR1cm4gZGF0ZTtcbn1cblxuZnVuY3Rpb24gZ2V0Q3JlYXRpb25UaW1lKHZhbHVlKSB7XG4gIHZhciB0aW1lID0gT2JqZWN0KF90YWdfbmFtZXNfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImdldFN0cmluZ1ZhbHVlXCJdKSh2YWx1ZSk7XG4gIHZhciBwYXJzZWRUaW1lID0gdGltZTtcblxuICBpZiAodGltZS5sZW5ndGggPj0gNikge1xuICAgIHBhcnNlZFRpbWUgPSB0aW1lLnN1YnN0cigwLCAyKSArICc6JyArIHRpbWUuc3Vic3RyKDIsIDIpICsgJzonICsgdGltZS5zdWJzdHIoNCwgMik7XG5cbiAgICBpZiAodGltZS5sZW5ndGggPT09IDExKSB7XG4gICAgICBwYXJzZWRUaW1lICs9IHRpbWUuc3Vic3RyKDYsIDEpICsgdGltZS5zdWJzdHIoNywgMikgKyAnOicgKyB0aW1lLnN1YnN0cig5LCAyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFyc2VkVGltZTtcbn1cblxuZnVuY3Rpb24gZ2V0RW5jb2RpbmdOYW1lKHZhbHVlKSB7XG4gIHZhciBzdHJpbmcgPSBPYmplY3QoX3RhZ19uYW1lc191dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZ2V0U3RyaW5nVmFsdWVcIl0pKHZhbHVlKTtcblxuICBpZiAoc3RyaW5nID09PSAnXFx4MWIlRycpIHtcbiAgICByZXR1cm4gJ1VURi04JztcbiAgfSBlbHNlIGlmIChzdHJpbmcgPT09ICdcXHgxYiU1Jykge1xuICAgIHJldHVybiAnV2luZG93cy0xMjUyJztcbiAgfSBlbHNlIGlmIChzdHJpbmcgPT09ICdcXHgxYiUvRycpIHtcbiAgICByZXR1cm4gJ1VURi04IExldmVsIDEnO1xuICB9IGVsc2UgaWYgKHN0cmluZyA9PT0gJ1xceDFiJS9IJykge1xuICAgIHJldHVybiAnVVRGLTggTGV2ZWwgMic7XG4gIH0gZWxzZSBpZiAoc3RyaW5nID09PSAnXFx4MWIlL0knKSB7XG4gICAgcmV0dXJuICdVVEYtOCBMZXZlbCAzJztcbiAgfSBlbHNlIGlmIChzdHJpbmcgPT09ICdcXHgxQi9BJykge1xuICAgIHJldHVybiAnSVNPLTg4NTktMSc7XG4gIH0gZWxzZSBpZiAoc3RyaW5nID09PSAnXFx4MUIvQicpIHtcbiAgICByZXR1cm4gJ0lTTy04ODU5LTInO1xuICB9IGVsc2UgaWYgKHN0cmluZyA9PT0gJ1xceDFCL0MnKSB7XG4gICAgcmV0dXJuICdJU08tODg1OS0zJztcbiAgfSBlbHNlIGlmIChzdHJpbmcgPT09ICdcXHgxQi9EJykge1xuICAgIHJldHVybiAnSVNPLTg4NTktNCc7XG4gIH0gZWxzZSBpZiAoc3RyaW5nID09PSAnXFx4MUIvQCcpIHtcbiAgICByZXR1cm4gJ0lTTy04ODU5LTUnO1xuICB9IGVsc2UgaWYgKHN0cmluZyA9PT0gJ1xceDFCL0cnKSB7XG4gICAgcmV0dXJuICdJU08tODg1OS02JztcbiAgfSBlbHNlIGlmIChzdHJpbmcgPT09ICdcXHgxQi9GJykge1xuICAgIHJldHVybiAnSVNPLTg4NTktNyc7XG4gIH0gZWxzZSBpZiAoc3RyaW5nID09PSAnXFx4MUIvSCcpIHtcbiAgICByZXR1cm4gJ0lTTy04ODU5LTgnO1xuICB9XG5cbiAgcmV0dXJuICdVbmtub3duJztcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvaXB0Yy10YWdzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9pcHRjLXRhZ3MuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2lwdGNfdGFnX25hbWVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lwdGMtdGFnLW5hbWVzLmpzICovIFwiLi9zcmMvaXB0Yy10YWctbmFtZXMuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3RhZ19kZWNvZGVyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RhZy1kZWNvZGVyLmpzICovIFwiLi9zcmMvdGFnLWRlY29kZXIuanNcIik7XG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy4gKi9cblxuXG52YXIgQllURVNfOEJJTSA9IDB4Mzg0MjQ5NGQ7XG52YXIgQllURVNfOEJJTV9TSVpFID0gNDtcbnZhciBSRVNPVVJDRV9CTE9DS19IRUFERVJfU0laRSA9IEJZVEVTXzhCSU1fU0laRSArIDg7XG52YXIgTkFBX1JFU09VUkNFX0JMT0NLX1RZUEUgPSAweDA0MDQ7XG52YXIgVEFHX0hFQURFUl9TSVpFID0gNTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICByZWFkOiByZWFkXG59KTtcblxuZnVuY3Rpb24gcmVhZChkYXRhVmlldywgZGF0YU9mZnNldCkge1xuICB0cnkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFWaWV3KSkge1xuICAgICAgcmV0dXJuIHBhcnNlVGFncyhuZXcgRGF0YVZpZXcoVWludDhBcnJheS5mcm9tKGRhdGFWaWV3KS5idWZmZXIpLCB7XG4gICAgICAgIHNpemU6IGRhdGFWaWV3Lmxlbmd0aFxuICAgICAgfSwgMCk7XG4gICAgfVxuXG4gICAgdmFyIF9nZXROYWFSZXNvdXJjZUJsb2NrID0gZ2V0TmFhUmVzb3VyY2VCbG9jayhkYXRhVmlldywgZGF0YU9mZnNldCksXG4gICAgICAgIG5hYUJsb2NrID0gX2dldE5hYVJlc291cmNlQmxvY2submFhQmxvY2ssXG4gICAgICAgIG5ld0RhdGFPZmZzZXQgPSBfZ2V0TmFhUmVzb3VyY2VCbG9jay5kYXRhT2Zmc2V0O1xuXG4gICAgcmV0dXJuIHBhcnNlVGFncyhkYXRhVmlldywgbmFhQmxvY2ssIG5ld0RhdGFPZmZzZXQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7fTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXROYWFSZXNvdXJjZUJsb2NrKGRhdGFWaWV3LCBkYXRhT2Zmc2V0KSB7XG4gIHdoaWxlIChkYXRhT2Zmc2V0ICsgUkVTT1VSQ0VfQkxPQ0tfSEVBREVSX1NJWkUgPD0gZGF0YVZpZXcuYnl0ZUxlbmd0aCkge1xuICAgIHZhciByZXNvdXJjZUJsb2NrID0gZ2V0UmVzb3VyY2VCbG9jayhkYXRhVmlldywgZGF0YU9mZnNldCk7XG5cbiAgICBpZiAoaXNOYWFSZXNvdXJjZUJsb2NrKHJlc291cmNlQmxvY2spKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYWFCbG9jazogcmVzb3VyY2VCbG9jayxcbiAgICAgICAgZGF0YU9mZnNldDogZGF0YU9mZnNldCArIFJFU09VUkNFX0JMT0NLX0hFQURFUl9TSVpFXG4gICAgICB9O1xuICAgIH1cblxuICAgIGRhdGFPZmZzZXQgKz0gUkVTT1VSQ0VfQkxPQ0tfSEVBREVSX1NJWkUgKyByZXNvdXJjZUJsb2NrLnNpemUgKyBnZXRCbG9ja1BhZGRpbmcocmVzb3VyY2VCbG9jayk7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ05vIElQVEMgTkFBIHJlc291cmNlIGJsb2NrLicpO1xufVxuXG5mdW5jdGlvbiBnZXRSZXNvdXJjZUJsb2NrKGRhdGFWaWV3LCBkYXRhT2Zmc2V0KSB7XG4gIHZhciBSRVNPVVJDRV9CTE9DS19TSVpFX09GRlNFVCA9IDEwO1xuXG4gIGlmIChkYXRhVmlldy5nZXRVaW50MzIoZGF0YU9mZnNldCwgZmFsc2UpICE9PSBCWVRFU184QklNKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYW4gSVBUQyByZXNvdXJjZSBibG9jay4nKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogZGF0YVZpZXcuZ2V0VWludDE2KGRhdGFPZmZzZXQgKyBCWVRFU184QklNX1NJWkUpLFxuICAgIHNpemU6IGRhdGFWaWV3LmdldFVpbnQxNihkYXRhT2Zmc2V0ICsgUkVTT1VSQ0VfQkxPQ0tfU0laRV9PRkZTRVQpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzTmFhUmVzb3VyY2VCbG9jayhyZXNvdXJjZUJsb2NrKSB7XG4gIHJldHVybiByZXNvdXJjZUJsb2NrLnR5cGUgPT09IE5BQV9SRVNPVVJDRV9CTE9DS19UWVBFO1xufVxuXG5mdW5jdGlvbiBnZXRCbG9ja1BhZGRpbmcocmVzb3VyY2VCbG9jaykge1xuICBpZiAocmVzb3VyY2VCbG9jay5zaXplICUgMiAhPT0gMCkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVGFncyhkYXRhVmlldywgbmFhQmxvY2ssIGRhdGFPZmZzZXQpIHtcbiAgdmFyIHRhZ3MgPSB7fTtcbiAgdmFyIGVuY29kaW5nID0gdW5kZWZpbmVkO1xuICB2YXIgZW5kT2ZCbG9ja09mZnNldCA9IGRhdGFPZmZzZXQgKyBuYWFCbG9ja1snc2l6ZSddO1xuXG4gIHdoaWxlIChkYXRhT2Zmc2V0IDwgZW5kT2ZCbG9ja09mZnNldCAmJiBkYXRhT2Zmc2V0IDwgZGF0YVZpZXcuYnl0ZUxlbmd0aCkge1xuICAgIHZhciBfcmVhZFRhZyA9IHJlYWRUYWcoZGF0YVZpZXcsIGRhdGFPZmZzZXQsIHRhZ3MsIGVuY29kaW5nKSxcbiAgICAgICAgdGFnID0gX3JlYWRUYWcudGFnLFxuICAgICAgICB0YWdTaXplID0gX3JlYWRUYWcudGFnU2l6ZTtcblxuICAgIGlmICh0YWcgPT09IG51bGwpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmICgnZW5jb2RpbmcnIGluIHRhZykge1xuICAgICAgZW5jb2RpbmcgPSB0YWcuZW5jb2Rpbmc7XG4gICAgfVxuXG4gICAgaWYgKHRhZ3NbdGFnLm5hbWVdID09PSB1bmRlZmluZWQgfHwgdGFnWydyZXBlYXRhYmxlJ10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFnc1t0YWcubmFtZV0gPSB7XG4gICAgICAgIGlkOiB0YWcuaWQsXG4gICAgICAgIHZhbHVlOiB0YWcudmFsdWUsXG4gICAgICAgIGRlc2NyaXB0aW9uOiB0YWcuZGVzY3JpcHRpb25cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghKHRhZ3NbdGFnLm5hbWVdIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgIHRhZ3NbdGFnLm5hbWVdID0gW3tcbiAgICAgICAgICBpZDogdGFnc1t0YWcubmFtZV0uaWQsXG4gICAgICAgICAgdmFsdWU6IHRhZ3NbdGFnLm5hbWVdLnZhbHVlLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiB0YWdzW3RhZy5uYW1lXS5kZXNjcmlwdGlvblxuICAgICAgICB9XTtcbiAgICAgIH1cblxuICAgICAgdGFnc1t0YWcubmFtZV0ucHVzaCh7XG4gICAgICAgIGlkOiB0YWcuaWQsXG4gICAgICAgIHZhbHVlOiB0YWcudmFsdWUsXG4gICAgICAgIGRlc2NyaXB0aW9uOiB0YWcuZGVzY3JpcHRpb25cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGRhdGFPZmZzZXQgKz0gVEFHX0hFQURFUl9TSVpFICsgdGFnU2l6ZTtcbiAgfVxuXG4gIHJldHVybiB0YWdzO1xufVxuXG5mdW5jdGlvbiByZWFkVGFnKGRhdGFWaWV3LCBkYXRhT2Zmc2V0LCB0YWdzLCBlbmNvZGluZykge1xuICB2YXIgVEFHX0NPREVfT0ZGU0VUID0gMTtcbiAgdmFyIFRBR19TSVpFX09GRlNFVCA9IDM7XG5cbiAgaWYgKGxlYWRCeXRlSXNNaXNzaW5nKGRhdGFWaWV3LCBkYXRhT2Zmc2V0KSkge1xuICAgIHJldHVybiB7XG4gICAgICB0YWc6IG51bGwsXG4gICAgICB0YWdTaXplOiAwXG4gICAgfTtcbiAgfVxuXG4gIHZhciB0YWdDb2RlID0gZGF0YVZpZXcuZ2V0VWludDE2KGRhdGFPZmZzZXQgKyBUQUdfQ09ERV9PRkZTRVQpO1xuICB2YXIgdGFnU2l6ZSA9IGRhdGFWaWV3LmdldFVpbnQxNihkYXRhT2Zmc2V0ICsgVEFHX1NJWkVfT0ZGU0VUKTtcbiAgdmFyIHRhZ1ZhbHVlID0gZ2V0VGFnVmFsdWUoZGF0YVZpZXcsIGRhdGFPZmZzZXQgKyBUQUdfSEVBREVSX1NJWkUsIHRhZ1NpemUpO1xuICB2YXIgdGFnID0ge1xuICAgIGlkOiB0YWdDb2RlLFxuICAgIG5hbWU6IGdldFRhZ05hbWUoX2lwdGNfdGFnX25hbWVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdWydpcHRjJ11bdGFnQ29kZV0sIHRhZ0NvZGUsIHRhZ1ZhbHVlKSxcbiAgICB2YWx1ZTogdGFnVmFsdWUsXG4gICAgZGVzY3JpcHRpb246IGdldFRhZ0Rlc2NyaXB0aW9uKF9pcHRjX3RhZ19uYW1lc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXVsnaXB0YyddW3RhZ0NvZGVdLCB0YWdWYWx1ZSwgdGFncywgZW5jb2RpbmcpXG4gIH07XG5cbiAgaWYgKHRhZ0lzUmVwZWF0YWJsZSh0YWdDb2RlKSkge1xuICAgIHRhZ1sncmVwZWF0YWJsZSddID0gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0YWdDb250YWluc0VuY29kaW5nKHRhZ0NvZGUpKSB7XG4gICAgdGFnWydlbmNvZGluZyddID0gX2lwdGNfdGFnX25hbWVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdWydpcHRjJ11bdGFnQ29kZV1bJ2VuY29kaW5nX25hbWUnXSh0YWdWYWx1ZSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRhZzogdGFnLFxuICAgIHRhZ1NpemU6IHRhZ1NpemVcbiAgfTtcbn1cblxuZnVuY3Rpb24gbGVhZEJ5dGVJc01pc3NpbmcoZGF0YVZpZXcsIGRhdGFPZmZzZXQpIHtcbiAgdmFyIFRBR19MRUFEX0JZVEUgPSAweDFjO1xuICByZXR1cm4gZGF0YVZpZXcuZ2V0VWludDgoZGF0YU9mZnNldCkgIT09IFRBR19MRUFEX0JZVEU7XG59XG5cbmZ1bmN0aW9uIGdldFRhZ1ZhbHVlKGRhdGFWaWV3LCBvZmZzZXQsIHNpemUpIHtcbiAgdmFyIHZhbHVlID0gW107XG5cbiAgZm9yICh2YXIgdmFsdWVJbmRleCA9IDA7IHZhbHVlSW5kZXggPCBzaXplOyB2YWx1ZUluZGV4KyspIHtcbiAgICB2YWx1ZS5wdXNoKGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIHZhbHVlSW5kZXgpKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0VGFnTmFtZSh0YWcsIHRhZ0NvZGUsIHRhZ1ZhbHVlKSB7XG4gIGlmICghdGFnKSB7XG4gICAgcmV0dXJuIFwidW5kZWZpbmVkLVwiLmNvbmNhdCh0YWdDb2RlKTtcbiAgfVxuXG4gIGlmICh0YWdJc05hbWUodGFnKSkge1xuICAgIHJldHVybiB0YWc7XG4gIH1cblxuICBpZiAoaGFzRHluYW1pY05hbWUodGFnKSkge1xuICAgIHJldHVybiB0YWdbJ25hbWUnXSh0YWdWYWx1ZSk7XG4gIH1cblxuICByZXR1cm4gdGFnWyduYW1lJ107XG59XG5cbmZ1bmN0aW9uIHRhZ0lzTmFtZSh0YWcpIHtcbiAgcmV0dXJuIHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnO1xufVxuXG5mdW5jdGlvbiBoYXNEeW5hbWljTmFtZSh0YWcpIHtcbiAgcmV0dXJuIHR5cGVvZiB0YWdbJ25hbWUnXSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gZ2V0VGFnRGVzY3JpcHRpb24odGFnLCB0YWdWYWx1ZSwgdGFncywgZW5jb2RpbmcpIHtcbiAgaWYgKGhhc0Rlc2NyaXB0aW9uUHJvcGVydHkodGFnKSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGFnWydkZXNjcmlwdGlvbiddKHRhZ1ZhbHVlLCB0YWdzKTtcbiAgICB9IGNhdGNoIChlcnJvcikgey8vIEZhbGwgdGhyb3VnaCB0byBuZXh0IGhhbmRsZXIuXG4gICAgfVxuICB9XG5cbiAgaWYgKHRhZ1ZhbHVlSXNUZXh0KHRhZywgdGFnVmFsdWUpKSB7XG4gICAgcmV0dXJuIF90YWdfZGVjb2Rlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXS5kZWNvZGUoZW5jb2RpbmcsIHRhZ1ZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiB0YWdWYWx1ZTtcbn1cblxuZnVuY3Rpb24gdGFnVmFsdWVJc1RleHQodGFnLCB0YWdWYWx1ZSkge1xuICByZXR1cm4gdGFnICYmIHRhZ1ZhbHVlIGluc3RhbmNlb2YgQXJyYXk7XG59XG5cbmZ1bmN0aW9uIGhhc0Rlc2NyaXB0aW9uUHJvcGVydHkodGFnKSB7XG4gIHJldHVybiB0YWcgJiYgdGFnWydkZXNjcmlwdGlvbiddICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHRhZ0lzUmVwZWF0YWJsZSh0YWdDb2RlKSB7XG4gIHJldHVybiBfaXB0Y190YWdfbmFtZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl1bJ2lwdGMnXVt0YWdDb2RlXSAmJiBfaXB0Y190YWdfbmFtZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl1bJ2lwdGMnXVt0YWdDb2RlXVsncmVwZWF0YWJsZSddO1xufVxuXG5mdW5jdGlvbiB0YWdDb250YWluc0VuY29kaW5nKHRhZ0NvZGUpIHtcbiAgcmV0dXJuIF9pcHRjX3RhZ19uYW1lc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXVsnaXB0YyddW3RhZ0NvZGVdICYmIF9pcHRjX3RhZ19uYW1lc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXVsnaXB0YyddW3RhZ0NvZGVdWydlbmNvZGluZ19uYW1lJ10gIT09IHVuZGVmaW5lZDtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvcG5nLWZpbGUtdGFncy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3BuZy1maWxlLXRhZ3MuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90eXBlcy5qcyAqLyBcIi4vc3JjL3R5cGVzLmpzXCIpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uICovXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICByZWFkOiByZWFkXG59KTtcblxuZnVuY3Rpb24gcmVhZChkYXRhVmlldywgZmlsZURhdGFPZmZzZXQpIHtcbiAgcmV0dXJuIHtcbiAgICAnSW1hZ2UgV2lkdGgnOiBnZXRJbWFnZVdpZHRoKGRhdGFWaWV3LCBmaWxlRGF0YU9mZnNldCksXG4gICAgJ0ltYWdlIEhlaWdodCc6IGdldEltYWdlSGVpZ2h0KGRhdGFWaWV3LCBmaWxlRGF0YU9mZnNldCksXG4gICAgJ0JpdCBEZXB0aCc6IGdldEJpdERlcHRoKGRhdGFWaWV3LCBmaWxlRGF0YU9mZnNldCksXG4gICAgJ0NvbG9yIFR5cGUnOiBnZXRDb2xvclR5cGUoZGF0YVZpZXcsIGZpbGVEYXRhT2Zmc2V0KSxcbiAgICAnQ29tcHJlc3Npb24nOiBnZXRDb21wcmVzc2lvbihkYXRhVmlldywgZmlsZURhdGFPZmZzZXQpLFxuICAgICdGaWx0ZXInOiBnZXRGaWx0ZXIoZGF0YVZpZXcsIGZpbGVEYXRhT2Zmc2V0KSxcbiAgICAnSW50ZXJsYWNlJzogZ2V0SW50ZXJsYWNlKGRhdGFWaWV3LCBmaWxlRGF0YU9mZnNldClcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0SW1hZ2VXaWR0aChkYXRhVmlldywgZmlsZURhdGFPZmZzZXQpIHtcbiAgdmFyIE9GRlNFVCA9IDA7XG4gIHZhciBTSVpFID0gNDtcblxuICBpZiAoZmlsZURhdGFPZmZzZXQgKyBPRkZTRVQgKyBTSVpFID4gZGF0YVZpZXcuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgdmFsdWUgPSBfdHlwZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0uZ2V0TG9uZ0F0KGRhdGFWaWV3LCBmaWxlRGF0YU9mZnNldCk7XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGRlc2NyaXB0aW9uOiBcIlwiLmNvbmNhdCh2YWx1ZSwgXCJweFwiKVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRJbWFnZUhlaWdodChkYXRhVmlldywgZmlsZURhdGFPZmZzZXQpIHtcbiAgdmFyIE9GRlNFVCA9IDQ7XG4gIHZhciBTSVpFID0gNDtcblxuICBpZiAoZmlsZURhdGFPZmZzZXQgKyBPRkZTRVQgKyBTSVpFID4gZGF0YVZpZXcuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgdmFsdWUgPSBfdHlwZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0uZ2V0TG9uZ0F0KGRhdGFWaWV3LCBmaWxlRGF0YU9mZnNldCArIE9GRlNFVCk7XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGRlc2NyaXB0aW9uOiBcIlwiLmNvbmNhdCh2YWx1ZSwgXCJweFwiKVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRCaXREZXB0aChkYXRhVmlldywgZmlsZURhdGFPZmZzZXQpIHtcbiAgdmFyIE9GRlNFVCA9IDg7XG4gIHZhciBTSVpFID0gMTtcblxuICBpZiAoZmlsZURhdGFPZmZzZXQgKyBPRkZTRVQgKyBTSVpFID4gZGF0YVZpZXcuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgdmFsdWUgPSBfdHlwZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0uZ2V0Qnl0ZUF0KGRhdGFWaWV3LCBmaWxlRGF0YU9mZnNldCArIE9GRlNFVCk7XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGRlc2NyaXB0aW9uOiBcIlwiLmNvbmNhdCh2YWx1ZSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29sb3JUeXBlKGRhdGFWaWV3LCBmaWxlRGF0YU9mZnNldCkge1xuICB2YXIgT0ZGU0VUID0gOTtcbiAgdmFyIFNJWkUgPSAxO1xuICB2YXIgQ09MT1JfVFlQRVMgPSB7XG4gICAgMDogJ0dyYXlzY2FsZScsXG4gICAgMjogJ1JHQicsXG4gICAgMzogJ1BhbGV0dGUnLFxuICAgIDQ6ICdHcmF5c2NhbGUgd2l0aCBBbHBoYScsXG4gICAgNjogJ1JHQiB3aXRoIEFscGhhJ1xuICB9O1xuXG4gIGlmIChmaWxlRGF0YU9mZnNldCArIE9GRlNFVCArIFNJWkUgPiBkYXRhVmlldy5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciB2YWx1ZSA9IF90eXBlc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXS5nZXRCeXRlQXQoZGF0YVZpZXcsIGZpbGVEYXRhT2Zmc2V0ICsgT0ZGU0VUKTtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgZGVzY3JpcHRpb246IENPTE9SX1RZUEVTW3ZhbHVlXSB8fCAnVW5rbm93bidcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcHJlc3Npb24oZGF0YVZpZXcsIGZpbGVEYXRhT2Zmc2V0KSB7XG4gIHZhciBPRkZTRVQgPSAxMDtcbiAgdmFyIFNJWkUgPSAxO1xuXG4gIGlmIChmaWxlRGF0YU9mZnNldCArIE9GRlNFVCArIFNJWkUgPiBkYXRhVmlldy5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciB2YWx1ZSA9IF90eXBlc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXS5nZXRCeXRlQXQoZGF0YVZpZXcsIGZpbGVEYXRhT2Zmc2V0ICsgT0ZGU0VUKTtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgZGVzY3JpcHRpb246IHZhbHVlID09PSAwID8gJ0RlZmxhdGUvSW5mbGF0ZScgOiAnVW5rbm93bidcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0RmlsdGVyKGRhdGFWaWV3LCBmaWxlRGF0YU9mZnNldCkge1xuICB2YXIgT0ZGU0VUID0gMTE7XG4gIHZhciBTSVpFID0gMTtcblxuICBpZiAoZmlsZURhdGFPZmZzZXQgKyBPRkZTRVQgKyBTSVpFID4gZGF0YVZpZXcuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgdmFsdWUgPSBfdHlwZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0uZ2V0Qnl0ZUF0KGRhdGFWaWV3LCBmaWxlRGF0YU9mZnNldCArIE9GRlNFVCk7XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGRlc2NyaXB0aW9uOiB2YWx1ZSA9PT0gMCA/ICdBZGFwdGl2ZScgOiAnVW5rbm93bidcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0SW50ZXJsYWNlKGRhdGFWaWV3LCBmaWxlRGF0YU9mZnNldCkge1xuICB2YXIgT0ZGU0VUID0gMTI7XG4gIHZhciBTSVpFID0gMTtcbiAgdmFyIElOVEVSTEFDRV9UWVBFUyA9IHtcbiAgICAwOiAnTm9uaW50ZXJsYWNlZCcsXG4gICAgMTogJ0FkYW03IEludGVybGFjZSdcbiAgfTtcblxuICBpZiAoZmlsZURhdGFPZmZzZXQgKyBPRkZTRVQgKyBTSVpFID4gZGF0YVZpZXcuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgdmFsdWUgPSBfdHlwZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0uZ2V0Qnl0ZUF0KGRhdGFWaWV3LCBmaWxlRGF0YU9mZnNldCArIE9GRlNFVCk7XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGRlc2NyaXB0aW9uOiBJTlRFUkxBQ0VfVFlQRVNbdmFsdWVdIHx8ICdVbmtub3duJ1xuICB9O1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90YWctZGVjb2Rlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90YWctZGVjb2Rlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90ZXh0X2RlY29kZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdGV4dC1kZWNvZGVyLmpzICovIFwiLi9zcmMvdGV4dC1kZWNvZGVyLmpzXCIpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uICovXG5cbnZhciBUQUdfSEVBREVSX1NJWkUgPSA1O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gIGRlY29kZTogZGVjb2RlLFxuICBUQUdfSEVBREVSX1NJWkU6IFRBR19IRUFERVJfU0laRVxufSk7XG5cbmZ1bmN0aW9uIGRlY29kZShlbmNvZGluZywgdGFnVmFsdWUpIHtcbiAgdmFyIERlY29kZXIgPSBfdGV4dF9kZWNvZGVyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdLmdldCgpO1xuXG4gIGlmICh0eXBlb2YgRGVjb2RlciAhPT0gJ3VuZGVmaW5lZCcgJiYgZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IERlY29kZXIoZW5jb2RpbmcpLmRlY29kZShVaW50OEFycmF5LmZyb20odGFnVmFsdWUpKTtcbiAgICB9IGNhdGNoIChlcnJvcikgey8vIFBhc3MgdGhyb3VnaCBhbmQgZmFsbCBiYWNrIHRvIEFTQ0lJIGRlY29kaW5nLlxuICAgIH1cbiAgfVxuXG4gIHZhciBzdHJpbmdWYWx1ZSA9IHRhZ1ZhbHVlLm1hcChmdW5jdGlvbiAoY2hhckNvZGUpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gIH0pLmpvaW4oJycpO1xuICByZXR1cm4gZGVjb2RlQXNjaWlWYWx1ZShzdHJpbmdWYWx1ZSk7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUFzY2lpVmFsdWUoYXNjaWlWYWx1ZSkge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKGFzY2lpVmFsdWUpKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gYXNjaWlWYWx1ZTtcbiAgfVxufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90YWctbmFtZXMtMHRoLWlmZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90YWctbmFtZXMtMHRoLWlmZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90YWdfbmFtZXNfY29tbW9uX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RhZy1uYW1lcy1jb21tb24uanMgKi8gXCIuL3NyYy90YWctbmFtZXMtY29tbW9uLmpzXCIpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uICovXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICAweDAwMGI6ICdQcm9jZXNzaW5nU29mdHdhcmUnLFxuICAweDAwZmU6IHtcbiAgICBuYW1lOiAnU3ViZmlsZVR5cGUnLFxuICAgIGRlc2NyaXB0aW9uOiBmdW5jdGlvbiBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgMHgwOiAnRnVsbC1yZXNvbHV0aW9uIGltYWdlJyxcbiAgICAgICAgMHgxOiAnUmVkdWNlZC1yZXNvbHV0aW9uIGltYWdlJyxcbiAgICAgICAgMHgyOiAnU2luZ2xlIHBhZ2Ugb2YgbXVsdGktcGFnZSBpbWFnZScsXG4gICAgICAgIDB4MzogJ1NpbmdsZSBwYWdlIG9mIG11bHRpLXBhZ2UgcmVkdWNlZC1yZXNvbHV0aW9uIGltYWdlJyxcbiAgICAgICAgMHg0OiAnVHJhbnNwYXJlbmN5IG1hc2snLFxuICAgICAgICAweDU6ICdUcmFuc3BhcmVuY3kgbWFzayBvZiByZWR1Y2VkLXJlc29sdXRpb24gaW1hZ2UnLFxuICAgICAgICAweDY6ICdUcmFuc3BhcmVuY3kgbWFzayBvZiBtdWx0aS1wYWdlIGltYWdlJyxcbiAgICAgICAgMHg3OiAnVHJhbnNwYXJlbmN5IG1hc2sgb2YgcmVkdWNlZC1yZXNvbHV0aW9uIG11bHRpLXBhZ2UgaW1hZ2UnLFxuICAgICAgICAweDEwMDAxOiAnQWx0ZXJuYXRlIHJlZHVjZWQtcmVzb2x1dGlvbiBpbWFnZScsXG4gICAgICAgIDB4ZmZmZmZmZmY6ICdJbnZhbGlkJ1xuICAgICAgfVt2YWx1ZV0gfHwgJ1Vua25vd24nO1xuICAgIH1cbiAgfSxcbiAgMHgwMGZmOiB7XG4gICAgbmFtZTogJ09sZFN1YmZpbGVUeXBlJyxcbiAgICBkZXNjcmlwdGlvbjogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIDA6ICdGdWxsLXJlc29sdXRpb24gaW1hZ2UnLFxuICAgICAgICAxOiAnUmVkdWNlZC1yZXNvbHV0aW9uIGltYWdlJyxcbiAgICAgICAgMjogJ1NpbmdsZSBwYWdlIG9mIG11bHRpLXBhZ2UgaW1hZ2UnXG4gICAgICB9W3ZhbHVlXSB8fCAnVW5rbm93bic7XG4gICAgfVxuICB9LFxuICAweDAxMDA6ICdJbWFnZVdpZHRoJyxcbiAgMHgwMTAxOiAnSW1hZ2VMZW5ndGgnLFxuICAweDAxMDI6ICdCaXRzUGVyU2FtcGxlJyxcbiAgMHgwMTAzOiAnQ29tcHJlc3Npb24nLFxuICAweDAxMDY6ICdQaG90b21ldHJpY0ludGVycHJldGF0aW9uJyxcbiAgMHgwMTA3OiB7XG4gICAgbmFtZTogJ1RocmVzaG9sZGluZycsXG4gICAgZGVzY3JpcHRpb246IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAxOiAnTm8gZGl0aGVyaW5nIG9yIGhhbGZ0b25pbmcnLFxuICAgICAgICAyOiAnT3JkZXJlZCBkaXRoZXIgb3IgaGFsZnRvbicsXG4gICAgICAgIDM6ICdSYW5kb21pemVkIGRpdGhlcidcbiAgICAgIH1bdmFsdWVdIHx8ICdVbmtub3duJztcbiAgICB9XG4gIH0sXG4gIDB4MDEwODogJ0NlbGxXaWR0aCcsXG4gIDB4MDEwOTogJ0NlbGxMZW5ndGgnLFxuICAweDAxMGE6IHtcbiAgICBuYW1lOiAnRmlsbE9yZGVyJyxcbiAgICBkZXNjcmlwdGlvbjogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIDE6ICdOb3JtYWwnLFxuICAgICAgICAyOiAnUmV2ZXJzZWQnXG4gICAgICB9W3ZhbHVlXSB8fCAnVW5rbm93bic7XG4gICAgfVxuICB9LFxuICAweDAxMGQ6ICdEb2N1bWVudE5hbWUnLFxuICAweDAxMGU6ICdJbWFnZURlc2NyaXB0aW9uJyxcbiAgMHgwMTBmOiAnTWFrZScsXG4gIDB4MDExMDogJ01vZGVsJyxcbiAgMHgwMTExOiAnU3RyaXBPZmZzZXRzJyxcbiAgMHgwMTEyOiB7XG4gICAgbmFtZTogJ09yaWVudGF0aW9uJyxcbiAgICBkZXNjcmlwdGlvbjogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gJ3RvcC1sZWZ0JztcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlID09PSAyKSB7XG4gICAgICAgIHJldHVybiAndG9wLXJpZ2h0JztcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlID09PSAzKSB7XG4gICAgICAgIHJldHVybiAnYm90dG9tLXJpZ2h0JztcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlID09PSA0KSB7XG4gICAgICAgIHJldHVybiAnYm90dG9tLWxlZnQnO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUgPT09IDUpIHtcbiAgICAgICAgcmV0dXJuICdsZWZ0LXRvcCc7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gNikge1xuICAgICAgICByZXR1cm4gJ3JpZ2h0LXRvcCc7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gNykge1xuICAgICAgICByZXR1cm4gJ3JpZ2h0LWJvdHRvbSc7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gOCkge1xuICAgICAgICByZXR1cm4gJ2xlZnQtYm90dG9tJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICdVbmRlZmluZWQnO1xuICAgIH1cbiAgfSxcbiAgMHgwMTE1OiAnU2FtcGxlc1BlclBpeGVsJyxcbiAgMHgwMTE2OiAnUm93c1BlclN0cmlwJyxcbiAgMHgwMTE3OiAnU3RyaXBCeXRlQ291bnRzJyxcbiAgMHgwMTE4OiAnTWluU2FtcGxlVmFsdWUnLFxuICAweDAxMTk6ICdNYXhTYW1wbGVWYWx1ZScsXG4gIDB4MDExYToge1xuICAgICduYW1lJzogJ1hSZXNvbHV0aW9uJyxcbiAgICAnZGVzY3JpcHRpb24nOiBmdW5jdGlvbiBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuICcnICsgTWF0aC5yb3VuZCh2YWx1ZVswXSAvIHZhbHVlWzFdKTtcbiAgICB9XG4gIH0sXG4gIDB4MDExYjoge1xuICAgICduYW1lJzogJ1lSZXNvbHV0aW9uJyxcbiAgICAnZGVzY3JpcHRpb24nOiBmdW5jdGlvbiBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuICcnICsgTWF0aC5yb3VuZCh2YWx1ZVswXSAvIHZhbHVlWzFdKTtcbiAgICB9XG4gIH0sXG4gIDB4MDExYzogJ1BsYW5hckNvbmZpZ3VyYXRpb24nLFxuICAweDAxMWQ6ICdQYWdlTmFtZScsXG4gIDB4MDExZToge1xuICAgICduYW1lJzogJ1hQb3NpdGlvbicsXG4gICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiAnJyArIE1hdGgucm91bmQodmFsdWVbMF0gLyB2YWx1ZVsxXSk7XG4gICAgfVxuICB9LFxuICAweDAxMWY6IHtcbiAgICAnbmFtZSc6ICdZUG9zaXRpb24nLFxuICAgICdkZXNjcmlwdGlvbic6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gJycgKyBNYXRoLnJvdW5kKHZhbHVlWzBdIC8gdmFsdWVbMV0pO1xuICAgIH1cbiAgfSxcbiAgMHgwMTIyOiB7XG4gICAgbmFtZTogJ0dyYXlSZXNwb25zZVVuaXQnLFxuICAgIGRlc2NyaXB0aW9uOiBmdW5jdGlvbiBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgMTogJzAuMScsXG4gICAgICAgIDI6ICcwLjAwMScsXG4gICAgICAgIDM6ICcwLjAwMDEnLFxuICAgICAgICA0OiAnMWUtMDUnLFxuICAgICAgICA1OiAnMWUtMDYnXG4gICAgICB9W3ZhbHVlXSB8fCAnVW5rbm93bic7XG4gICAgfVxuICB9LFxuICAweDAxMjg6IHtcbiAgICBuYW1lOiAnUmVzb2x1dGlvblVuaXQnLFxuICAgIGRlc2NyaXB0aW9uOiBmdW5jdGlvbiBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSAyKSB7XG4gICAgICAgIHJldHVybiAnaW5jaGVzJztcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlID09PSAzKSB7XG4gICAgICAgIHJldHVybiAnY2VudGltZXRlcnMnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ1Vua25vd24nO1xuICAgIH1cbiAgfSxcbiAgMHgwMTI5OiAnUGFnZU51bWJlcicsXG4gIDB4MDEyZDogJ1RyYW5zZmVyRnVuY3Rpb24nLFxuICAweDAxMzE6ICdTb2Z0d2FyZScsXG4gIDB4MDEzMjogJ0RhdGVUaW1lJyxcbiAgMHgwMTNiOiAnQXJ0aXN0JyxcbiAgMHgwMTNjOiAnSG9zdENvbXB1dGVyJyxcbiAgMHgwMTNkOiAnUHJlZGljdG9yJyxcbiAgMHgwMTNlOiB7XG4gICAgJ25hbWUnOiAnV2hpdGVQb2ludCcsXG4gICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWVzKSB7XG4gICAgICByZXR1cm4gdmFsdWVzLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHZhbHVlWzBdLCBcIi9cIikuY29uY2F0KHZhbHVlWzFdKTtcbiAgICAgIH0pLmpvaW4oJywgJyk7XG4gICAgfVxuICB9LFxuICAweDAxM2Y6IHtcbiAgICAnbmFtZSc6ICdQcmltYXJ5Q2hyb21hdGljaXRpZXMnLFxuICAgICdkZXNjcmlwdGlvbic6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKHZhbHVlcykge1xuICAgICAgcmV0dXJuIHZhbHVlcy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh2YWx1ZVswXSwgXCIvXCIpLmNvbmNhdCh2YWx1ZVsxXSk7XG4gICAgICB9KS5qb2luKCcsICcpO1xuICAgIH1cbiAgfSxcbiAgMHgwMTQxOiAnSGFsZnRvbmVIaW50cycsXG4gIDB4MDE0MjogJ1RpbGVXaWR0aCcsXG4gIDB4MDE0MzogJ1RpbGVMZW5ndGgnLFxuICAweDAxNGE6ICdBMTAwRGF0YU9mZnNldCcsXG4gIDB4MDE0Yzoge1xuICAgIG5hbWU6ICdJbmtTZXQnLFxuICAgIGRlc2NyaXB0aW9uOiBmdW5jdGlvbiBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgMTogJ0NNWUsnLFxuICAgICAgICAyOiAnTm90IENNWUsnXG4gICAgICB9W3ZhbHVlXSB8fCAnVW5rbm93bic7XG4gICAgfVxuICB9LFxuICAweDAxNTE6ICdUYXJnZXRQcmludGVyJyxcbiAgMHgwMTUyOiB7XG4gICAgbmFtZTogJ0V4dHJhU2FtcGxlcycsXG4gICAgZGVzY3JpcHRpb246IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAwOiAnVW5zcGVjaWZpZWQnLFxuICAgICAgICAxOiAnQXNzb2NpYXRlZCBBbHBoYScsXG4gICAgICAgIDI6ICdVbmFzc29jaWF0ZWQgQWxwaGEnXG4gICAgICB9W3ZhbHVlXSB8fCAnVW5rbm93bic7XG4gICAgfVxuICB9LFxuICAweDAxNTM6IHtcbiAgICBuYW1lOiAnU2FtcGxlRm9ybWF0JyxcbiAgICBkZXNjcmlwdGlvbjogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIHZhciBmb3JtYXRzID0ge1xuICAgICAgICAxOiAnVW5zaWduZWQnLFxuICAgICAgICAyOiAnU2lnbmVkJyxcbiAgICAgICAgMzogJ0Zsb2F0JyxcbiAgICAgICAgNDogJ1VuZGVmaW5lZCcsXG4gICAgICAgIDU6ICdDb21wbGV4IGludCcsXG4gICAgICAgIDY6ICdDb21wbGV4IGZsb2F0J1xuICAgICAgfTtcblxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gJ1Vua25vd24nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uIChzYW1wbGUpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHNbc2FtcGxlXSB8fCAnVW5rbm93bic7XG4gICAgICB9KS5qb2luKCcsICcpO1xuICAgIH1cbiAgfSxcbiAgMHgwMjAxOiAnSlBFR0ludGVyY2hhbmdlRm9ybWF0JyxcbiAgMHgwMjAyOiAnSlBFR0ludGVyY2hhbmdlRm9ybWF0TGVuZ3RoJyxcbiAgMHgwMjExOiB7XG4gICAgJ25hbWUnOiAnWUNiQ3JDb2VmZmljaWVudHMnLFxuICAgICdkZXNjcmlwdGlvbic6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKHZhbHVlcykge1xuICAgICAgcmV0dXJuIHZhbHVlcy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAnJyArIHZhbHVlWzBdIC8gdmFsdWVbMV07XG4gICAgICB9KS5qb2luKCcvJyk7XG4gICAgfVxuICB9LFxuICAweDAyMTI6ICdZQ2JDclN1YlNhbXBsaW5nJyxcbiAgMHgwMjEzOiB7XG4gICAgbmFtZTogJ1lDYkNyUG9zaXRpb25pbmcnLFxuICAgIGRlc2NyaXB0aW9uOiBmdW5jdGlvbiBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSAxKSB7XG4gICAgICAgIHJldHVybiAnY2VudGVyZWQnO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuICdjby1zaXRlZCc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAndW5kZWZpbmVkICcgKyB2YWx1ZTtcbiAgICB9XG4gIH0sXG4gIDB4MDIxNDoge1xuICAgICduYW1lJzogJ1JlZmVyZW5jZUJsYWNrV2hpdGUnLFxuICAgICdkZXNjcmlwdGlvbic6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKHZhbHVlcykge1xuICAgICAgcmV0dXJuIHZhbHVlcy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAnJyArIHZhbHVlWzBdIC8gdmFsdWVbMV07XG4gICAgICB9KS5qb2luKCcsICcpO1xuICAgIH1cbiAgfSxcbiAgMHgwMmJjOiAnQXBwbGljYXRpb25Ob3RlcycsXG4gIDB4NDc0NjogJ1JhdGluZycsXG4gIDB4NDc0OTogJ1JhdGluZ1BlcmNlbnQnLFxuICAweDgyOTg6IHtcbiAgICBuYW1lOiAnQ29weXJpZ2h0JyxcbiAgICBkZXNjcmlwdGlvbjogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5qb2luKCc7ICcpO1xuICAgIH1cbiAgfSxcbiAgMHg4MzBlOiAnUGl4ZWxTY2FsZScsXG4gIDB4ODNiYjogJ0lQVEMtTkFBJyxcbiAgMHg4NDgwOiAnSW50ZXJncmFwaE1hdHJpeCcsXG4gIDB4ODQ4MjogJ01vZGVsVGllUG9pbnQnLFxuICAweDg1NDY6ICdTRU1JbmZvJyxcbiAgMHg4NWQ4OiAnTW9kZWxUcmFuc2Zvcm0nLFxuICAweDg2NDk6ICdQaG90b3Nob3BTZXR0aW5ncycsXG4gIDB4ODc2OTogJ0V4aWYgSUZEIFBvaW50ZXInLFxuICAweDg3NzM6ICdJQ0NfUHJvZmlsZScsXG4gIDB4ODdhZjogJ0dlb1RpZmZEaXJlY3RvcnknLFxuICAweDg3YjA6ICdHZW9UaWZmRG91YmxlUGFyYW1zJyxcbiAgMHg4N2IxOiAnR2VvVGlmZkFzY2lpUGFyYW1zJyxcbiAgMHg4ODI1OiAnR1BTIEluZm8gSUZEIFBvaW50ZXInLFxuICAweDljOWI6ICdYUFRpdGxlJyxcbiAgMHg5YzljOiAnWFBDb21tZW50JyxcbiAgMHg5YzlkOiAnWFBBdXRob3InLFxuICAweDljOWU6ICdYUEtleXdvcmRzJyxcbiAgMHg5YzlmOiAnWFBTdWJqZWN0JyxcbiAgMHhhNDgwOiAnR0RBTE1ldGFkYXRhJyxcbiAgMHhhNDgxOiAnR0RBTE5vRGF0YScsXG4gIDB4YzRhNTogJ1ByaW50SU0nLFxuICAweGM2MTM6ICdETkdCYWNrd2FyZFZlcnNpb24nLFxuICAweGM2MTQ6ICdVbmlxdWVDYW1lcmFNb2RlbCcsXG4gIDB4YzYxNTogJ0xvY2FsaXplZENhbWVyYU1vZGVsJyxcbiAgMHhjNjIxOiAnQ29sb3JNYXRyaXgxJyxcbiAgMHhjNjIyOiAnQ29sb3JNYXRyaXgyJyxcbiAgMHhjNjIzOiAnQ2FtZXJhQ2FsaWJyYXRpb24xJyxcbiAgMHhjNjI0OiAnQ2FtZXJhQ2FsaWJyYXRpb24yJyxcbiAgMHhjNjI1OiAnUmVkdWN0aW9uTWF0cml4MScsXG4gIDB4YzYyNjogJ1JlZHVjdGlvbk1hdHJpeDInLFxuICAweGM2Mjc6ICdBbmFsb2dCYWxhbmNlJyxcbiAgMHhjNjI4OiAnQXNTaG90TmV1dHJhbCcsXG4gIDB4YzYyOTogJ0FzU2hvdFdoaXRlWFknLFxuICAweGM2MmE6ICdCYXNlbGluZUV4cG9zdXJlJyxcbiAgMHhjNjJiOiAnQmFzZWxpbmVOb2lzZScsXG4gIDB4YzYyYzogJ0Jhc2VsaW5lU2hhcnBuZXNzJyxcbiAgMHhjNjJlOiAnTGluZWFyUmVzcG9uc2VMaW1pdCcsXG4gIDB4YzYyZjogJ0NhbWVyYVNlcmlhbE51bWJlcicsXG4gIDB4YzYzMDogJ0ROR0xlbnNJbmZvJyxcbiAgMHhjNjMzOiAnU2hhZG93U2NhbGUnLFxuICAweGM2MzU6IHtcbiAgICBuYW1lOiAnTWFrZXJOb3RlU2FmZXR5JyxcbiAgICBkZXNjcmlwdGlvbjogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIDA6ICdVbnNhZmUnLFxuICAgICAgICAxOiAnU2FmZSdcbiAgICAgIH1bdmFsdWVdIHx8ICdVbmtub3duJztcbiAgICB9XG4gIH0sXG4gIDB4YzY1YToge1xuICAgIG5hbWU6ICdDYWxpYnJhdGlvbklsbHVtaW5hbnQxJyxcbiAgICBkZXNjcmlwdGlvbjogX3RhZ19uYW1lc19jb21tb25fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl1bJ0xpZ2h0U291cmNlJ11cbiAgfSxcbiAgMHhjNjViOiB7XG4gICAgbmFtZTogJ0NhbGlicmF0aW9uSWxsdW1pbmFudDInLFxuICAgIGRlc2NyaXB0aW9uOiBfdGFnX25hbWVzX2NvbW1vbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXVsnTGlnaHRTb3VyY2UnXVxuICB9LFxuICAweGM2NWQ6ICdSYXdEYXRhVW5pcXVlSUQnLFxuICAweGM2OGI6ICdPcmlnaW5hbFJhd0ZpbGVOYW1lJyxcbiAgMHhjNjhjOiAnT3JpZ2luYWxSYXdGaWxlRGF0YScsXG4gIDB4YzY4ZjogJ0FzU2hvdElDQ1Byb2ZpbGUnLFxuICAweGM2OTA6ICdBc1Nob3RQcmVQcm9maWxlTWF0cml4JyxcbiAgMHhjNjkxOiAnQ3VycmVudElDQ1Byb2ZpbGUnLFxuICAweGM2OTI6ICdDdXJyZW50UHJlUHJvZmlsZU1hdHJpeCcsXG4gIDB4YzZiZjogJ0NvbG9yaW1ldHJpY1JlZmVyZW5jZScsXG4gIDB4YzZjNTogJ1NSYXdUeXBlJyxcbiAgMHhjNmQyOiAnUGFuYXNvbmljVGl0bGUnLFxuICAweGM2ZDM6ICdQYW5hc29uaWNUaXRsZTInLFxuICAweGM2ZjM6ICdDYW1lcmFDYWxpYnJhdGlvblNpZycsXG4gIDB4YzZmNDogJ1Byb2ZpbGVDYWxpYnJhdGlvblNpZycsXG4gIDB4YzZmNTogJ1Byb2ZpbGVJRkQnLFxuICAweGM2ZjY6ICdBc1Nob3RQcm9maWxlTmFtZScsXG4gIDB4YzZmODogJ1Byb2ZpbGVOYW1lJyxcbiAgMHhjNmY5OiAnUHJvZmlsZUh1ZVNhdE1hcERpbXMnLFxuICAweGM2ZmE6ICdQcm9maWxlSHVlU2F0TWFwRGF0YTEnLFxuICAweGM2ZmI6ICdQcm9maWxlSHVlU2F0TWFwRGF0YTInLFxuICAweGM2ZmM6ICdQcm9maWxlVG9uZUN1cnZlJyxcbiAgMHhjNmZkOiB7XG4gICAgbmFtZTogJ1Byb2ZpbGVFbWJlZFBvbGljeScsXG4gICAgZGVzY3JpcHRpb246IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAwOiAnQWxsb3cgQ29weWluZycsXG4gICAgICAgIDE6ICdFbWJlZCBpZiBVc2VkJyxcbiAgICAgICAgMjogJ05ldmVyIEVtYmVkJyxcbiAgICAgICAgMzogJ05vIFJlc3RyaWN0aW9ucydcbiAgICAgIH1bdmFsdWVdIHx8ICdVbmtub3duJztcbiAgICB9XG4gIH0sXG4gIDB4YzZmZTogJ1Byb2ZpbGVDb3B5cmlnaHQnLFxuICAweGM3MTQ6ICdGb3J3YXJkTWF0cml4MScsXG4gIDB4YzcxNTogJ0ZvcndhcmRNYXRyaXgyJyxcbiAgMHhjNzE2OiAnUHJldmlld0FwcGxpY2F0aW9uTmFtZScsXG4gIDB4YzcxNzogJ1ByZXZpZXdBcHBsaWNhdGlvblZlcnNpb24nLFxuICAweGM3MTg6ICdQcmV2aWV3U2V0dGluZ3NOYW1lJyxcbiAgMHhjNzE5OiAnUHJldmlld1NldHRpbmdzRGlnZXN0JyxcbiAgMHhjNzFhOiB7XG4gICAgbmFtZTogJ1ByZXZpZXdDb2xvclNwYWNlJyxcbiAgICBkZXNjcmlwdGlvbjogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIDE6ICdHcmF5IEdhbW1hIDIuMicsXG4gICAgICAgIDI6ICdzUkdCJyxcbiAgICAgICAgMzogJ0Fkb2JlIFJHQicsXG4gICAgICAgIDQ6ICdQcm9QaG90byBSR0InXG4gICAgICB9W3ZhbHVlXSB8fCAnVW5rbm93bic7XG4gICAgfVxuICB9LFxuICAweGM3MWI6ICdQcmV2aWV3RGF0ZVRpbWUnLFxuICAweGM3MWM6ICdSYXdJbWFnZURpZ2VzdCcsXG4gIDB4YzcxZDogJ09yaWdpbmFsUmF3RmlsZURpZ2VzdCcsXG4gIDB4YzcyNTogJ1Byb2ZpbGVMb29rVGFibGVEaW1zJyxcbiAgMHhjNzI2OiAnUHJvZmlsZUxvb2tUYWJsZURhdGEnLFxuICAweGM3NjM6ICdUaW1lQ29kZXMnLFxuICAweGM3NjQ6ICdGcmFtZVJhdGUnLFxuICAweGM3NzI6ICdUU3RvcCcsXG4gIDB4Yzc4OTogJ1JlZWxOYW1lJyxcbiAgMHhjNzkxOiAnT3JpZ2luYWxEZWZhdWx0RmluYWxTaXplJyxcbiAgMHhjNzkyOiAnT3JpZ2luYWxCZXN0UXVhbGl0eVNpemUnLFxuICAweGM3OTM6ICdPcmlnaW5hbERlZmF1bHRDcm9wU2l6ZScsXG4gIDB4YzdhMTogJ0NhbWVyYUxhYmVsJyxcbiAgMHhjN2EzOiB7XG4gICAgbmFtZTogJ1Byb2ZpbGVIdWVTYXRNYXBFbmNvZGluZycsXG4gICAgZGVzY3JpcHRpb246IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAwOiAnTGluZWFyJyxcbiAgICAgICAgMTogJ3NSR0InXG4gICAgICB9W3ZhbHVlXSB8fCAnVW5rbm93bic7XG4gICAgfVxuICB9LFxuICAweGM3YTQ6IHtcbiAgICBuYW1lOiAnUHJvZmlsZUxvb2tUYWJsZUVuY29kaW5nJyxcbiAgICBkZXNjcmlwdGlvbjogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIDA6ICdMaW5lYXInLFxuICAgICAgICAxOiAnc1JHQidcbiAgICAgIH1bdmFsdWVdIHx8ICdVbmtub3duJztcbiAgICB9XG4gIH0sXG4gIDB4YzdhNTogJ0Jhc2VsaW5lRXhwb3N1cmVPZmZzZXQnLFxuICAweGM3YTY6IHtcbiAgICBuYW1lOiAnRGVmYXVsdEJsYWNrUmVuZGVyJyxcbiAgICBkZXNjcmlwdGlvbjogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIDA6ICdBdXRvJyxcbiAgICAgICAgMTogJ05vbmUnXG4gICAgICB9W3ZhbHVlXSB8fCAnVW5rbm93bic7XG4gICAgfVxuICB9LFxuICAweGM3YTc6ICdOZXdSYXdJbWFnZURpZ2VzdCcsXG4gIDB4YzdhODogJ1Jhd1RvUHJldmlld0dhaW4nXG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdGFnLW5hbWVzLWNvbW1vbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3RhZy1uYW1lcy1jb21tb24uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgJ0xpZ2h0U291cmNlJzogZnVuY3Rpb24gTGlnaHRTb3VyY2UodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IDEpIHtcbiAgICAgIHJldHVybiAnRGF5bGlnaHQnO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDIpIHtcbiAgICAgIHJldHVybiAnRmx1b3Jlc2NlbnQnO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDMpIHtcbiAgICAgIHJldHVybiAnVHVuZ3N0ZW4gKGluY2FuZGVzY2VudCBsaWdodCknO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDQpIHtcbiAgICAgIHJldHVybiAnRmxhc2gnO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDkpIHtcbiAgICAgIHJldHVybiAnRmluZSB3ZWF0aGVyJztcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAxMCkge1xuICAgICAgcmV0dXJuICdDbG91ZHkgd2VhdGhlcic7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMTEpIHtcbiAgICAgIHJldHVybiAnU2hhZGUnO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDEyKSB7XG4gICAgICByZXR1cm4gJ0RheWxpZ2h0IGZsdW9yZXNjZW50IChEIDU3MDAg4oCTIDcxMDBLKSc7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMTMpIHtcbiAgICAgIHJldHVybiAnRGF5IHdoaXRlIGZsdW9yZXNjZW50IChOIDQ2MDAg4oCTIDU0MDBLKSc7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMTQpIHtcbiAgICAgIHJldHVybiAnQ29vbCB3aGl0ZSBmbHVvcmVzY2VudCAoVyAzOTAwIOKAkyA0NTAwSyknO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDE1KSB7XG4gICAgICByZXR1cm4gJ1doaXRlIGZsdW9yZXNjZW50IChXVyAzMjAwIOKAkyAzNzAwSyknO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDE3KSB7XG4gICAgICByZXR1cm4gJ1N0YW5kYXJkIGxpZ2h0IEEnO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDE4KSB7XG4gICAgICByZXR1cm4gJ1N0YW5kYXJkIGxpZ2h0IEInO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDE5KSB7XG4gICAgICByZXR1cm4gJ1N0YW5kYXJkIGxpZ2h0IEMnO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDIwKSB7XG4gICAgICByZXR1cm4gJ0Q1NSc7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMjEpIHtcbiAgICAgIHJldHVybiAnRDY1JztcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAyMikge1xuICAgICAgcmV0dXJuICdENzUnO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDIzKSB7XG4gICAgICByZXR1cm4gJ0Q1MCc7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMjQpIHtcbiAgICAgIHJldHVybiAnSVNPIHN0dWRpbyB0dW5nc3Rlbic7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMjU1KSB7XG4gICAgICByZXR1cm4gJ090aGVyIGxpZ2h0IHNvdXJjZSc7XG4gICAgfVxuXG4gICAgcmV0dXJuICdVbmtub3duJztcbiAgfVxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3RhZy1uYW1lcy1leGlmLWlmZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdGFnLW5hbWVzLWV4aWYtaWZkLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90YWdfbmFtZXNfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdGFnLW5hbWVzLXV0aWxzLmpzICovIFwiLi9zcmMvdGFnLW5hbWVzLXV0aWxzLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90YWdfbmFtZXNfY29tbW9uX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RhZy1uYW1lcy1jb21tb24uanMgKi8gXCIuL3NyYy90YWctbmFtZXMtY29tbW9uLmpzXCIpO1xuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG4pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpKSByZXR1cm47IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cblxuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uICovXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gIDB4ODI5YToge1xuICAgICduYW1lJzogJ0V4cG9zdXJlVGltZScsXG4gICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZVswXSAhPT0gMCkge1xuICAgICAgICByZXR1cm4gXCIxL1wiLmNvbmNhdChNYXRoLnJvdW5kKHZhbHVlWzFdIC8gdmFsdWVbMF0pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwiMC9cIi5jb25jYXQodmFsdWVbMV0pO1xuICAgIH1cbiAgfSxcbiAgMHg4MjlkOiB7XG4gICAgJ25hbWUnOiAnRk51bWJlcicsXG4gICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBcImYvXCIuY29uY2F0KHZhbHVlWzBdIC8gdmFsdWVbMV0pO1xuICAgIH1cbiAgfSxcbiAgMHg4ODIyOiB7XG4gICAgJ25hbWUnOiAnRXhwb3N1cmVQcm9ncmFtJyxcbiAgICAnZGVzY3JpcHRpb24nOiBmdW5jdGlvbiBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnVW5kZWZpbmVkJztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuICdNYW51YWwnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMikge1xuICAgICAgICByZXR1cm4gJ05vcm1hbCBwcm9ncmFtJztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDMpIHtcbiAgICAgICAgcmV0dXJuICdBcGVydHVyZSBwcmlvcml0eSc7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSA0KSB7XG4gICAgICAgIHJldHVybiAnU2h1dHRlciBwcmlvcml0eSc7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSA1KSB7XG4gICAgICAgIHJldHVybiAnQ3JlYXRpdmUgcHJvZ3JhbSc7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSA2KSB7XG4gICAgICAgIHJldHVybiAnQWN0aW9uIHByb2dyYW0nO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gNykge1xuICAgICAgICByZXR1cm4gJ1BvcnRyYWl0IG1vZGUnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gOCkge1xuICAgICAgICByZXR1cm4gJ0xhbmRzY2FwZSBtb2RlJztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDkpIHtcbiAgICAgICAgcmV0dXJuICdCdWxiJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICdVbmtub3duJztcbiAgICB9XG4gIH0sXG4gIDB4ODgyNDogJ1NwZWN0cmFsU2Vuc2l0aXZpdHknLFxuICAweDg4Mjc6ICdJU09TcGVlZFJhdGluZ3MnLFxuICAweDg4Mjg6IHtcbiAgICAnbmFtZSc6ICdPRUNGJyxcbiAgICAnZGVzY3JpcHRpb24nOiBmdW5jdGlvbiBkZXNjcmlwdGlvbigpIHtcbiAgICAgIHJldHVybiAnW1JhdyBPRUNGIHRhYmxlIGRhdGFdJztcbiAgICB9XG4gIH0sXG4gIDB4ODgyYTogJ1RpbWVab25lT2Zmc2V0JyxcbiAgMHg4ODJiOiAnU2VsZlRpbWVyTW9kZScsXG4gIDB4ODgzMDoge1xuICAgIG5hbWU6ICdTZW5zaXRpdml0eVR5cGUnLFxuICAgIGRlc2NyaXB0aW9uOiBmdW5jdGlvbiBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgMTogJ1N0YW5kYXJkIE91dHB1dCBTZW5zaXRpdml0eScsXG4gICAgICAgIDI6ICdSZWNvbW1lbmRlZCBFeHBvc3VyZSBJbmRleCcsXG4gICAgICAgIDM6ICdJU08gU3BlZWQnLFxuICAgICAgICA0OiAnU3RhbmRhcmQgT3V0cHV0IFNlbnNpdGl2aXR5IGFuZCBSZWNvbW1lbmRlZCBFeHBvc3VyZSBJbmRleCcsXG4gICAgICAgIDU6ICdTdGFuZGFyZCBPdXRwdXQgU2Vuc2l0aXZpdHkgYW5kIElTTyBTcGVlZCcsXG4gICAgICAgIDY6ICdSZWNvbW1lbmRlZCBFeHBvc3VyZSBJbmRleCBhbmQgSVNPIFNwZWVkJyxcbiAgICAgICAgNzogJ1N0YW5kYXJkIE91dHB1dCBTZW5zaXRpdml0eSwgUmVjb21tZW5kZWQgRXhwb3N1cmUgSW5kZXggYW5kIElTTyBTcGVlZCdcbiAgICAgIH1bdmFsdWVdIHx8ICdVbmtub3duJztcbiAgICB9XG4gIH0sXG4gIDB4ODgzMTogJ1N0YW5kYXJkT3V0cHV0U2Vuc2l0aXZpdHknLFxuICAweDg4MzI6ICdSZWNvbW1lbmRlZEV4cG9zdXJlSW5kZXgnLFxuICAweDg4MzM6ICdJU09TcGVlZCcsXG4gIDB4ODgzNDogJ0lTT1NwZWVkTGF0aXR1ZGV5eXknLFxuICAweDg4MzU6ICdJU09TcGVlZExhdGl0dWRlenp6JyxcbiAgMHg5MDAwOiB7XG4gICAgJ25hbWUnOiAnRXhpZlZlcnNpb24nLFxuICAgICdkZXNjcmlwdGlvbic6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gT2JqZWN0KF90YWdfbmFtZXNfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImdldFN0cmluZ1ZhbHVlXCJdKSh2YWx1ZSk7XG4gICAgfVxuICB9LFxuICAweDkwMDM6ICdEYXRlVGltZU9yaWdpbmFsJyxcbiAgMHg5MDA0OiAnRGF0ZVRpbWVEaWdpdGl6ZWQnLFxuICAweDkwMDk6ICdHb29nbGVQbHVzVXBsb2FkQ29kZScsXG4gIDB4OTAxMDogJ09mZnNldFRpbWUnLFxuICAweDkwMTE6ICdPZmZzZXRUaW1lT3JpZ2luYWwnLFxuICAweDkwMTI6ICdPZmZzZXRUaW1lRGlnaXRpemVkJyxcbiAgMHg5MTAxOiB7XG4gICAgJ25hbWUnOiAnQ29tcG9uZW50c0NvbmZpZ3VyYXRpb24nLFxuICAgICdkZXNjcmlwdGlvbic6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uIChjaGFyYWN0ZXIpIHtcbiAgICAgICAgaWYgKGNoYXJhY3RlciA9PT0gMHgzMSkge1xuICAgICAgICAgIHJldHVybiAnWSc7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhcmFjdGVyID09PSAweDMyKSB7XG4gICAgICAgICAgcmV0dXJuICdDYic7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhcmFjdGVyID09PSAweDMzKSB7XG4gICAgICAgICAgcmV0dXJuICdDcic7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhcmFjdGVyID09PSAweDM0KSB7XG4gICAgICAgICAgcmV0dXJuICdSJztcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPT09IDB4MzUpIHtcbiAgICAgICAgICByZXR1cm4gJ0cnO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXJhY3RlciA9PT0gMHgzNikge1xuICAgICAgICAgIHJldHVybiAnQic7XG4gICAgICAgIH1cbiAgICAgIH0pLmpvaW4oJycpO1xuICAgIH1cbiAgfSxcbiAgMHg5MTAyOiAnQ29tcHJlc3NlZEJpdHNQZXJQaXhlbCcsXG4gIDB4OTIwMToge1xuICAgICduYW1lJzogJ1NodXR0ZXJTcGVlZFZhbHVlJyxcbiAgICAnZGVzY3JpcHRpb24nOiBmdW5jdGlvbiBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIFwiMS9cIi5jb25jYXQoTWF0aC5yb3VuZChNYXRoLnBvdygyLCB2YWx1ZVswXSAvIHZhbHVlWzFdKSkpO1xuICAgIH1cbiAgfSxcbiAgMHg5MjAyOiB7XG4gICAgJ25hbWUnOiAnQXBlcnR1cmVWYWx1ZScsXG4gICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBNYXRoLnBvdyhNYXRoLnNxcnQoMiksIHZhbHVlWzBdIC8gdmFsdWVbMV0pLnRvRml4ZWQoMik7XG4gICAgfVxuICB9LFxuICAweDkyMDM6ICdCcmlnaHRuZXNzVmFsdWUnLFxuICAweDkyMDQ6ICdFeHBvc3VyZUJpYXNWYWx1ZScsXG4gIDB4OTIwNToge1xuICAgICduYW1lJzogJ01heEFwZXJ0dXJlVmFsdWUnLFxuICAgICdkZXNjcmlwdGlvbic6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gTWF0aC5wb3coTWF0aC5zcXJ0KDIpLCB2YWx1ZVswXSAvIHZhbHVlWzFdKS50b0ZpeGVkKDIpO1xuICAgIH1cbiAgfSxcbiAgMHg5MjA2OiB7XG4gICAgJ25hbWUnOiAnU3ViamVjdERpc3RhbmNlJyxcbiAgICAnZGVzY3JpcHRpb24nOiBmdW5jdGlvbiBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlWzBdIC8gdmFsdWVbMV0gKyAnIG0nO1xuICAgIH1cbiAgfSxcbiAgMHg5MjA3OiB7XG4gICAgJ25hbWUnOiAnTWV0ZXJpbmdNb2RlJyxcbiAgICAnZGVzY3JpcHRpb24nOiBmdW5jdGlvbiBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSAxKSB7XG4gICAgICAgIHJldHVybiAnQXZlcmFnZSc7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAyKSB7XG4gICAgICAgIHJldHVybiAnQ2VudGVyV2VpZ2h0ZWRBdmVyYWdlJztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDMpIHtcbiAgICAgICAgcmV0dXJuICdTcG90JztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDQpIHtcbiAgICAgICAgcmV0dXJuICdNdWx0aVNwb3QnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gNSkge1xuICAgICAgICByZXR1cm4gJ1BhdHRlcm4nO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gNikge1xuICAgICAgICByZXR1cm4gJ1BhcnRpYWwnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMjU1KSB7XG4gICAgICAgIHJldHVybiAnT3RoZXInO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ1Vua25vd24nO1xuICAgIH1cbiAgfSxcbiAgMHg5MjA4OiB7XG4gICAgJ25hbWUnOiAnTGlnaHRTb3VyY2UnLFxuICAgIGRlc2NyaXB0aW9uOiBfdGFnX25hbWVzX2NvbW1vbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXVsnTGlnaHRTb3VyY2UnXVxuICB9LFxuICAweDkyMDk6IHtcbiAgICAnbmFtZSc6ICdGbGFzaCcsXG4gICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gMHgwMCkge1xuICAgICAgICByZXR1cm4gJ0ZsYXNoIGRpZCBub3QgZmlyZSc7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAweDAxKSB7XG4gICAgICAgIHJldHVybiAnRmxhc2ggZmlyZWQnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMHgwNSkge1xuICAgICAgICByZXR1cm4gJ1N0cm9iZSByZXR1cm4gbGlnaHQgbm90IGRldGVjdGVkJztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDB4MDcpIHtcbiAgICAgICAgcmV0dXJuICdTdHJvYmUgcmV0dXJuIGxpZ2h0IGRldGVjdGVkJztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDB4MDkpIHtcbiAgICAgICAgcmV0dXJuICdGbGFzaCBmaXJlZCwgY29tcHVsc29yeSBmbGFzaCBtb2RlJztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDB4MGQpIHtcbiAgICAgICAgcmV0dXJuICdGbGFzaCBmaXJlZCwgY29tcHVsc29yeSBmbGFzaCBtb2RlLCByZXR1cm4gbGlnaHQgbm90IGRldGVjdGVkJztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDB4MGYpIHtcbiAgICAgICAgcmV0dXJuICdGbGFzaCBmaXJlZCwgY29tcHVsc29yeSBmbGFzaCBtb2RlLCByZXR1cm4gbGlnaHQgZGV0ZWN0ZWQnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMHgxMCkge1xuICAgICAgICByZXR1cm4gJ0ZsYXNoIGRpZCBub3QgZmlyZSwgY29tcHVsc29yeSBmbGFzaCBtb2RlJztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDB4MTgpIHtcbiAgICAgICAgcmV0dXJuICdGbGFzaCBkaWQgbm90IGZpcmUsIGF1dG8gbW9kZSc7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAweDE5KSB7XG4gICAgICAgIHJldHVybiAnRmxhc2ggZmlyZWQsIGF1dG8gbW9kZSc7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAweDFkKSB7XG4gICAgICAgIHJldHVybiAnRmxhc2ggZmlyZWQsIGF1dG8gbW9kZSwgcmV0dXJuIGxpZ2h0IG5vdCBkZXRlY3RlZCc7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAweDFmKSB7XG4gICAgICAgIHJldHVybiAnRmxhc2ggZmlyZWQsIGF1dG8gbW9kZSwgcmV0dXJuIGxpZ2h0IGRldGVjdGVkJztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDB4MjApIHtcbiAgICAgICAgcmV0dXJuICdObyBmbGFzaCBmdW5jdGlvbic7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAweDQxKSB7XG4gICAgICAgIHJldHVybiAnRmxhc2ggZmlyZWQsIHJlZC1leWUgcmVkdWN0aW9uIG1vZGUnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMHg0NSkge1xuICAgICAgICByZXR1cm4gJ0ZsYXNoIGZpcmVkLCByZWQtZXllIHJlZHVjdGlvbiBtb2RlLCByZXR1cm4gbGlnaHQgbm90IGRldGVjdGVkJztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDB4NDcpIHtcbiAgICAgICAgcmV0dXJuICdGbGFzaCBmaXJlZCwgcmVkLWV5ZSByZWR1Y3Rpb24gbW9kZSwgcmV0dXJuIGxpZ2h0IGRldGVjdGVkJztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDB4NDkpIHtcbiAgICAgICAgcmV0dXJuICdGbGFzaCBmaXJlZCwgY29tcHVsc29yeSBmbGFzaCBtb2RlLCByZWQtZXllIHJlZHVjdGlvbiBtb2RlJztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDB4NGQpIHtcbiAgICAgICAgcmV0dXJuICdGbGFzaCBmaXJlZCwgY29tcHVsc29yeSBmbGFzaCBtb2RlLCByZWQtZXllIHJlZHVjdGlvbiBtb2RlLCByZXR1cm4gbGlnaHQgbm90IGRldGVjdGVkJztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDB4NGYpIHtcbiAgICAgICAgcmV0dXJuICdGbGFzaCBmaXJlZCwgY29tcHVsc29yeSBmbGFzaCBtb2RlLCByZWQtZXllIHJlZHVjdGlvbiBtb2RlLCByZXR1cm4gbGlnaHQgZGV0ZWN0ZWQnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMHg1OSkge1xuICAgICAgICByZXR1cm4gJ0ZsYXNoIGZpcmVkLCBhdXRvIG1vZGUsIHJlZC1leWUgcmVkdWN0aW9uIG1vZGUnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMHg1ZCkge1xuICAgICAgICByZXR1cm4gJ0ZsYXNoIGZpcmVkLCBhdXRvIG1vZGUsIHJldHVybiBsaWdodCBub3QgZGV0ZWN0ZWQsIHJlZC1leWUgcmVkdWN0aW9uIG1vZGUnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMHg1Zikge1xuICAgICAgICByZXR1cm4gJ0ZsYXNoIGZpcmVkLCBhdXRvIG1vZGUsIHJldHVybiBsaWdodCBkZXRlY3RlZCwgcmVkLWV5ZSByZWR1Y3Rpb24gbW9kZSc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnVW5rbm93bic7XG4gICAgfVxuICB9LFxuICAweDkyMGE6IHtcbiAgICAnbmFtZSc6ICdGb2NhbExlbmd0aCcsXG4gICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZVswXSAvIHZhbHVlWzFdICsgJyBtbSc7XG4gICAgfVxuICB9LFxuICAweDkyMTE6ICdJbWFnZU51bWJlcicsXG4gIDB4OTIxMjoge1xuICAgIG5hbWU6ICdTZWN1cml0eUNsYXNzaWZpY2F0aW9uJyxcbiAgICBkZXNjcmlwdGlvbjogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdDJzogJ0NvbmZpZGVudGlhbCcsXG4gICAgICAgICdSJzogJ1Jlc3RyaWN0ZWQnLFxuICAgICAgICAnUyc6ICdTZWNyZXQnLFxuICAgICAgICAnVCc6ICdUb3AgU2VjcmV0JyxcbiAgICAgICAgJ1UnOiAnVW5jbGFzc2lmaWVkJ1xuICAgICAgfVt2YWx1ZV0gfHwgJ1Vua25vd24nO1xuICAgIH1cbiAgfSxcbiAgMHg5MjEzOiAnSW1hZ2VIaXN0b3J5JyxcbiAgMHg5MjE0OiB7XG4gICAgJ25hbWUnOiAnU3ViamVjdEFyZWEnLFxuICAgICdkZXNjcmlwdGlvbic6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHJldHVybiBcIkxvY2F0aW9uOyBYOiBcIi5jb25jYXQodmFsdWVbMF0sIFwiLCBZOiBcIikuY29uY2F0KHZhbHVlWzFdKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIHJldHVybiBcIkNpcmNsZTsgWDogXCIuY29uY2F0KHZhbHVlWzBdLCBcIiwgWTogXCIpLmNvbmNhdCh2YWx1ZVsxXSwgXCIsIGRpYW1ldGVyOiBcIikuY29uY2F0KHZhbHVlWzJdKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHJldHVybiBcIlJlY3RhbmdsZTsgWDogXCIuY29uY2F0KHZhbHVlWzBdLCBcIiwgWTogXCIpLmNvbmNhdCh2YWx1ZVsxXSwgXCIsIHdpZHRoOiBcIikuY29uY2F0KHZhbHVlWzJdLCBcIiwgaGVpZ2h0OiBcIikuY29uY2F0KHZhbHVlWzNdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICdVbmtub3duJztcbiAgICB9XG4gIH0sXG4gIDB4OTI3Yzoge1xuICAgICduYW1lJzogJ01ha2VyTm90ZScsXG4gICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24oKSB7XG4gICAgICByZXR1cm4gJ1tSYXcgbWFrZXIgbm90ZSBkYXRhXSc7XG4gICAgfVxuICB9LFxuICAweDkyODY6IHtcbiAgICAnbmFtZSc6ICdVc2VyQ29tbWVudCcsXG4gICAgJ2Rlc2NyaXB0aW9uJzogX3RhZ19uYW1lc191dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZ2V0RW5jb2RlZFN0cmluZ1wiXVxuICB9LFxuICAweDkyOTA6ICdTdWJTZWNUaW1lJyxcbiAgMHg5MjkxOiAnU3ViU2VjVGltZU9yaWdpbmFsJyxcbiAgMHg5MjkyOiAnU3ViU2VjVGltZURpZ2l0aXplZCcsXG4gIDB4OTQwMDoge1xuICAgICduYW1lJzogJ0FtYmllbnRUZW1wZXJhdHVyZScsXG4gICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZVswXSAvIHZhbHVlWzFdICsgJyDCsEMnO1xuICAgIH1cbiAgfSxcbiAgMHg5NDAxOiB7XG4gICAgJ25hbWUnOiAnSHVtaWRpdHknLFxuICAgICdkZXNjcmlwdGlvbic6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWVbMF0gLyB2YWx1ZVsxXSArICcgJSc7XG4gICAgfVxuICB9LFxuICAweDk0MDI6IHtcbiAgICAnbmFtZSc6ICdQcmVzc3VyZScsXG4gICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZVswXSAvIHZhbHVlWzFdICsgJyBoUGEnO1xuICAgIH1cbiAgfSxcbiAgMHg5NDAzOiB7XG4gICAgJ25hbWUnOiAnV2F0ZXJEZXB0aCcsXG4gICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZVswXSAvIHZhbHVlWzFdICsgJyBtJztcbiAgICB9XG4gIH0sXG4gIDB4OTQwNDoge1xuICAgICduYW1lJzogJ0FjY2VsZXJhdGlvbicsXG4gICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZVswXSAvIHZhbHVlWzFdICsgJyBtR2FsJztcbiAgICB9XG4gIH0sXG4gIDB4OTQwNToge1xuICAgICduYW1lJzogJ0NhbWVyYUVsZXZhdGlvbkFuZ2xlJyxcbiAgICAnZGVzY3JpcHRpb24nOiBmdW5jdGlvbiBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlWzBdIC8gdmFsdWVbMV0gKyAnIMKwJztcbiAgICB9XG4gIH0sXG4gIDB4YTAwMDoge1xuICAgICduYW1lJzogJ0ZsYXNocGl4VmVyc2lvbicsXG4gICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5tYXAoZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgICAgIH0pLmpvaW4oJycpO1xuICAgIH1cbiAgfSxcbiAgMHhhMDAxOiB7XG4gICAgJ25hbWUnOiAnQ29sb3JTcGFjZScsXG4gICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gJ3NSR0InO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMHhmZmZmKSB7XG4gICAgICAgIHJldHVybiAnVW5jYWxpYnJhdGVkJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICdVbmtub3duJztcbiAgICB9XG4gIH0sXG4gIDB4YTAwMjogJ1BpeGVsWERpbWVuc2lvbicsXG4gIDB4YTAwMzogJ1BpeGVsWURpbWVuc2lvbicsXG4gIDB4YTAwNDogJ1JlbGF0ZWRTb3VuZEZpbGUnLFxuICAweGEwMDU6ICdJbnRlcm9wZXJhYmlsaXR5IElGRCBQb2ludGVyJyxcbiAgMHhhMjBiOiAnRmxhc2hFbmVyZ3knLFxuICAweGEyMGM6IHtcbiAgICAnbmFtZSc6ICdTcGF0aWFsRnJlcXVlbmN5UmVzcG9uc2UnLFxuICAgICdkZXNjcmlwdGlvbic6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKCkge1xuICAgICAgcmV0dXJuICdbUmF3IFNGUiB0YWJsZSBkYXRhXSc7XG4gICAgfVxuICB9LFxuICAweGEyMGU6ICdGb2NhbFBsYW5lWFJlc29sdXRpb24nLFxuICAweGEyMGY6ICdGb2NhbFBsYW5lWVJlc29sdXRpb24nLFxuICAweGEyMTA6IHtcbiAgICAnbmFtZSc6ICdGb2NhbFBsYW5lUmVzb2x1dGlvblVuaXQnLFxuICAgICdkZXNjcmlwdGlvbic6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuICdpbmNoZXMnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMykge1xuICAgICAgICByZXR1cm4gJ2NlbnRpbWV0ZXJzJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICdVbmtub3duJztcbiAgICB9XG4gIH0sXG4gIDB4YTIxNDoge1xuICAgICduYW1lJzogJ1N1YmplY3RMb2NhdGlvbicsXG4gICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24oX3JlZikge1xuICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgICAgeCA9IF9yZWYyWzBdLFxuICAgICAgICAgIHkgPSBfcmVmMlsxXTtcblxuICAgICAgcmV0dXJuIFwiWDogXCIuY29uY2F0KHgsIFwiLCBZOiBcIikuY29uY2F0KHkpO1xuICAgIH1cbiAgfSxcbiAgMHhhMjE1OiAnRXhwb3N1cmVJbmRleCcsXG4gIDB4YTIxNzoge1xuICAgICduYW1lJzogJ1NlbnNpbmdNZXRob2QnLFxuICAgICdkZXNjcmlwdGlvbic6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuICdVbmRlZmluZWQnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMikge1xuICAgICAgICByZXR1cm4gJ09uZS1jaGlwIGNvbG9yIGFyZWEgc2Vuc29yJztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDMpIHtcbiAgICAgICAgcmV0dXJuICdUd28tY2hpcCBjb2xvciBhcmVhIHNlbnNvcic7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSA0KSB7XG4gICAgICAgIHJldHVybiAnVGhyZWUtY2hpcCBjb2xvciBhcmVhIHNlbnNvcic7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSA1KSB7XG4gICAgICAgIHJldHVybiAnQ29sb3Igc2VxdWVudGlhbCBhcmVhIHNlbnNvcic7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSA3KSB7XG4gICAgICAgIHJldHVybiAnVHJpbGluZWFyIHNlbnNvcic7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSA4KSB7XG4gICAgICAgIHJldHVybiAnQ29sb3Igc2VxdWVudGlhbCBsaW5lYXIgc2Vuc29yJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICdVbmtub3duJztcbiAgICB9XG4gIH0sXG4gIDB4YTMwMDoge1xuICAgICduYW1lJzogJ0ZpbGVTb3VyY2UnLFxuICAgICdkZXNjcmlwdGlvbic6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09IDMpIHtcbiAgICAgICAgcmV0dXJuICdEU0MnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ1Vua25vd24nO1xuICAgIH1cbiAgfSxcbiAgMHhhMzAxOiB7XG4gICAgJ25hbWUnOiAnU2NlbmVUeXBlJyxcbiAgICAnZGVzY3JpcHRpb24nOiBmdW5jdGlvbiBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSAxKSB7XG4gICAgICAgIHJldHVybiAnQSBkaXJlY3RseSBwaG90b2dyYXBoZWQgaW1hZ2UnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ1Vua25vd24nO1xuICAgIH1cbiAgfSxcbiAgMHhhMzAyOiB7XG4gICAgJ25hbWUnOiAnQ0ZBUGF0dGVybicsXG4gICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24oKSB7XG4gICAgICByZXR1cm4gJ1tSYXcgQ0ZBIHBhdHRlcm4gdGFibGUgZGF0YV0nO1xuICAgIH1cbiAgfSxcbiAgMHhhNDAxOiB7XG4gICAgJ25hbWUnOiAnQ3VzdG9tUmVuZGVyZWQnLFxuICAgICdkZXNjcmlwdGlvbic6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuICdOb3JtYWwgcHJvY2Vzcyc7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAxKSB7XG4gICAgICAgIHJldHVybiAnQ3VzdG9tIHByb2Nlc3MnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ1Vua25vd24nO1xuICAgIH1cbiAgfSxcbiAgMHhhNDAyOiB7XG4gICAgJ25hbWUnOiAnRXhwb3N1cmVNb2RlJyxcbiAgICAnZGVzY3JpcHRpb24nOiBmdW5jdGlvbiBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnQXV0byBleHBvc3VyZSc7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAxKSB7XG4gICAgICAgIHJldHVybiAnTWFudWFsIGV4cG9zdXJlJztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuICdBdXRvIGJyYWNrZXQnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ1Vua25vd24nO1xuICAgIH1cbiAgfSxcbiAgMHhhNDAzOiB7XG4gICAgJ25hbWUnOiAnV2hpdGVCYWxhbmNlJyxcbiAgICAnZGVzY3JpcHRpb24nOiBmdW5jdGlvbiBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnQXV0byB3aGl0ZSBiYWxhbmNlJztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuICdNYW51YWwgd2hpdGUgYmFsYW5jZSc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnVW5rbm93bic7XG4gICAgfVxuICB9LFxuICAweGE0MDQ6IHtcbiAgICAnbmFtZSc6ICdEaWdpdGFsWm9vbVJhdGlvJyxcbiAgICAnZGVzY3JpcHRpb24nOiBmdW5jdGlvbiBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlWzBdID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnRGlnaXRhbCB6b29tIHdhcyBub3QgdXNlZCc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnJyArIHZhbHVlWzBdIC8gdmFsdWVbMV07XG4gICAgfVxuICB9LFxuICAweGE0MDU6IHtcbiAgICAnbmFtZSc6ICdGb2NhbExlbmd0aEluMzVtbUZpbG0nLFxuICAgICdkZXNjcmlwdGlvbic6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuICdVbmtub3duJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfSxcbiAgMHhhNDA2OiB7XG4gICAgJ25hbWUnOiAnU2NlbmVDYXB0dXJlVHlwZScsXG4gICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJ1N0YW5kYXJkJztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuICdMYW5kc2NhcGUnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMikge1xuICAgICAgICByZXR1cm4gJ1BvcnRyYWl0JztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDMpIHtcbiAgICAgICAgcmV0dXJuICdOaWdodCBzY2VuZSc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnVW5rbm93bic7XG4gICAgfVxuICB9LFxuICAweGE0MDc6IHtcbiAgICAnbmFtZSc6ICdHYWluQ29udHJvbCcsXG4gICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJ05vbmUnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gJ0xvdyBnYWluIHVwJztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuICdIaWdoIGdhaW4gdXAnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMykge1xuICAgICAgICByZXR1cm4gJ0xvdyBnYWluIGRvd24nO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gNCkge1xuICAgICAgICByZXR1cm4gJ0hpZ2ggZ2FpbiBkb3duJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICdVbmtub3duJztcbiAgICB9XG4gIH0sXG4gIDB4YTQwODoge1xuICAgICduYW1lJzogJ0NvbnRyYXN0JyxcbiAgICAnZGVzY3JpcHRpb24nOiBmdW5jdGlvbiBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnTm9ybWFsJztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuICdTb2Z0JztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuICdIYXJkJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICdVbmtub3duJztcbiAgICB9XG4gIH0sXG4gIDB4YTQwOToge1xuICAgICduYW1lJzogJ1NhdHVyYXRpb24nLFxuICAgICdkZXNjcmlwdGlvbic6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuICdOb3JtYWwnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gJ0xvdyBzYXR1cmF0aW9uJztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuICdIaWdoIHNhdHVyYXRpb24nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ1Vua25vd24nO1xuICAgIH1cbiAgfSxcbiAgMHhhNDBhOiB7XG4gICAgJ25hbWUnOiAnU2hhcnBuZXNzJyxcbiAgICAnZGVzY3JpcHRpb24nOiBmdW5jdGlvbiBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnTm9ybWFsJztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuICdTb2Z0JztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuICdIYXJkJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICdVbmtub3duJztcbiAgICB9XG4gIH0sXG4gIDB4YTQwYjoge1xuICAgICduYW1lJzogJ0RldmljZVNldHRpbmdEZXNjcmlwdGlvbicsXG4gICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24oKSB7XG4gICAgICByZXR1cm4gJ1tSYXcgZGV2aWNlIHNldHRpbmdzIHRhYmxlIGRhdGFdJztcbiAgICB9XG4gIH0sXG4gIDB4YTQwYzoge1xuICAgICduYW1lJzogJ1N1YmplY3REaXN0YW5jZVJhbmdlJyxcbiAgICAnZGVzY3JpcHRpb24nOiBmdW5jdGlvbiBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSAxKSB7XG4gICAgICAgIHJldHVybiAnTWFjcm8nO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMikge1xuICAgICAgICByZXR1cm4gJ0Nsb3NlIHZpZXcnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMykge1xuICAgICAgICByZXR1cm4gJ0Rpc3RhbnQgdmlldyc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnVW5rbm93bic7XG4gICAgfVxuICB9LFxuICAweGE0MjA6ICdJbWFnZVVuaXF1ZUlEJyxcbiAgMHhhNDMwOiAnQ2FtZXJhT3duZXJOYW1lJyxcbiAgMHhhNDMxOiAnQm9keVNlcmlhbE51bWJlcicsXG4gIDB4YTQzMjoge1xuICAgICduYW1lJzogJ0xlbnNTcGVjaWZpY2F0aW9uJyxcbiAgICAnZGVzY3JpcHRpb24nOiBmdW5jdGlvbiBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGZvY2FsTGVuZ3RocyA9IFwiXCIuY29uY2F0KHZhbHVlWzBdWzBdIC8gdmFsdWVbMF1bMV0sIFwiLVwiKS5jb25jYXQodmFsdWVbMV1bMF0gLyB2YWx1ZVsxXVsxXSwgXCIgbW1cIik7XG5cbiAgICAgIGlmICh2YWx1ZVszXVsxXSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoZm9jYWxMZW5ndGhzLCBcIiBmLz9cIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdChmb2NhbExlbmd0aHMsIFwiIGYvXCIpLmNvbmNhdCgxIC8gKHZhbHVlWzJdWzFdIC8gdmFsdWVbMl1bMV0gLyAodmFsdWVbM11bMF0gLyB2YWx1ZVszXVsxXSkpKTtcbiAgICB9XG4gIH0sXG4gIDB4YTQzMzogJ0xlbnNNYWtlJyxcbiAgMHhhNDM0OiAnTGVuc01vZGVsJyxcbiAgMHhhNDM1OiAnTGVuc1NlcmlhbE51bWJlcicsXG4gIDB4YTQ2MDoge1xuICAgIG5hbWU6ICdDb21wb3NpdGVJbWFnZScsXG4gICAgZGVzY3JpcHRpb246IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAxOiAnTm90IGEgQ29tcG9zaXRlIEltYWdlJyxcbiAgICAgICAgMjogJ0dlbmVyYWwgQ29tcG9zaXRlIEltYWdlJyxcbiAgICAgICAgMzogJ0NvbXBvc2l0ZSBJbWFnZSBDYXB0dXJlZCBXaGlsZSBTaG9vdGluZydcbiAgICAgIH1bdmFsdWVdIHx8ICdVbmtub3duJztcbiAgICB9XG4gIH0sXG4gIDB4YTQ2MTogJ1NvdXJjZUltYWdlTnVtYmVyT2ZDb21wb3NpdGVJbWFnZScsXG4gIDB4YTQ2MjogJ1NvdXJjZUV4cG9zdXJlVGltZXNPZkNvbXBvc2l0ZUltYWdlJyxcbiAgMHhhNTAwOiAnR2FtbWEnLFxuICAweGVhMWM6ICdQYWRkaW5nJyxcbiAgMHhlYTFkOiAnT2Zmc2V0U2NoZW1hJyxcbiAgMHhmZGU4OiAnT3duZXJOYW1lJyxcbiAgMHhmZGU5OiAnU2VyaWFsTnVtYmVyJyxcbiAgMHhmZGVhOiAnTGVucycsXG4gIDB4ZmU0YzogJ1Jhd0ZpbGUnLFxuICAweGZlNGQ6ICdDb252ZXJ0ZXInLFxuICAweGZlNGU6ICdXaGl0ZUJhbGFuY2UnLFxuICAweGZlNTE6ICdFeHBvc3VyZScsXG4gIDB4ZmU1MjogJ1NoYWRvd3MnLFxuICAweGZlNTM6ICdCcmlnaHRuZXNzJyxcbiAgMHhmZTU0OiAnQ29udHJhc3QnLFxuICAweGZlNTU6ICdTYXR1cmF0aW9uJyxcbiAgMHhmZTU2OiAnU2hhcnBuZXNzJyxcbiAgMHhmZTU3OiAnU21vb3RobmVzcycsXG4gIDB4ZmU1ODogJ01vaXJlRmlsdGVyJ1xufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3RhZy1uYW1lcy1ncHMtaWZkLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3RhZy1uYW1lcy1ncHMtaWZkLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3RhZ19uYW1lc191dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90YWctbmFtZXMtdXRpbHMuanMgKi8gXCIuL3NyYy90YWctbmFtZXMtdXRpbHMuanNcIik7XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obik7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy4gKi9cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gIDB4MDAwMDoge1xuICAgICduYW1lJzogJ0dQU1ZlcnNpb25JRCcsXG4gICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZVswXSA9PT0gMiAmJiB2YWx1ZVsxXSA9PT0gMiAmJiB2YWx1ZVsyXSA9PT0gMCAmJiB2YWx1ZVszXSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJ1ZlcnNpb24gMi4yJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICdVbmtub3duJztcbiAgICB9XG4gIH0sXG4gIDB4MDAwMToge1xuICAgICduYW1lJzogJ0dQU0xhdGl0dWRlUmVmJyxcbiAgICAnZGVzY3JpcHRpb24nOiBmdW5jdGlvbiBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIHJlZiA9IHZhbHVlLmpvaW4oJycpO1xuXG4gICAgICBpZiAocmVmID09PSAnTicpIHtcbiAgICAgICAgcmV0dXJuICdOb3J0aCBsYXRpdHVkZSc7XG4gICAgICB9IGVsc2UgaWYgKHJlZiA9PT0gJ1MnKSB7XG4gICAgICAgIHJldHVybiAnU291dGggbGF0aXR1ZGUnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ1Vua25vd24nO1xuICAgIH1cbiAgfSxcbiAgMHgwMDAyOiB7XG4gICAgJ25hbWUnOiAnR1BTTGF0aXR1ZGUnLFxuICAgICdkZXNjcmlwdGlvbic6IF90YWdfbmFtZXNfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImdldENhbGN1bGF0ZWRHcHNWYWx1ZVwiXVxuICB9LFxuICAweDAwMDM6IHtcbiAgICAnbmFtZSc6ICdHUFNMb25naXR1ZGVSZWYnLFxuICAgICdkZXNjcmlwdGlvbic6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgcmVmID0gdmFsdWUuam9pbignJyk7XG5cbiAgICAgIGlmIChyZWYgPT09ICdFJykge1xuICAgICAgICByZXR1cm4gJ0Vhc3QgbG9uZ2l0dWRlJztcbiAgICAgIH0gZWxzZSBpZiAocmVmID09PSAnVycpIHtcbiAgICAgICAgcmV0dXJuICdXZXN0IGxvbmdpdHVkZSc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnVW5rbm93bic7XG4gICAgfVxuICB9LFxuICAweDAwMDQ6IHtcbiAgICAnbmFtZSc6ICdHUFNMb25naXR1ZGUnLFxuICAgICdkZXNjcmlwdGlvbic6IF90YWdfbmFtZXNfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImdldENhbGN1bGF0ZWRHcHNWYWx1ZVwiXVxuICB9LFxuICAweDAwMDU6IHtcbiAgICAnbmFtZSc6ICdHUFNBbHRpdHVkZVJlZicsXG4gICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJ1NlYSBsZXZlbCc7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAxKSB7XG4gICAgICAgIHJldHVybiAnU2VhIGxldmVsIHJlZmVyZW5jZSAobmVnYXRpdmUgdmFsdWUpJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICdVbmtub3duJztcbiAgICB9XG4gIH0sXG4gIDB4MDAwNjoge1xuICAgICduYW1lJzogJ0dQU0FsdGl0dWRlJyxcbiAgICAnZGVzY3JpcHRpb24nOiBmdW5jdGlvbiBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlWzBdIC8gdmFsdWVbMV0gKyAnIG0nO1xuICAgIH1cbiAgfSxcbiAgMHgwMDA3OiB7XG4gICAgJ25hbWUnOiAnR1BTVGltZVN0YW1wJyxcbiAgICAnZGVzY3JpcHRpb24nOiBmdW5jdGlvbiBkZXNjcmlwdGlvbih2YWx1ZXMpIHtcbiAgICAgIHJldHVybiB2YWx1ZXMubWFwKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICAgICAgbnVtZXJhdG9yID0gX3JlZjJbMF0sXG4gICAgICAgICAgICBkZW5vbWluYXRvciA9IF9yZWYyWzFdO1xuXG4gICAgICAgIHZhciBudW0gPSBudW1lcmF0b3IgLyBkZW5vbWluYXRvcjtcblxuICAgICAgICBpZiAoL15cXGQoXFwufCQpLy50ZXN0KFwiXCIuY29uY2F0KG51bSkpKSB7XG4gICAgICAgICAgcmV0dXJuIFwiMFwiLmNvbmNhdChudW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICAgIH0pLmpvaW4oJzonKTtcbiAgICB9XG4gIH0sXG4gIDB4MDAwODogJ0dQU1NhdGVsbGl0ZXMnLFxuICAweDAwMDk6IHtcbiAgICAnbmFtZSc6ICdHUFNTdGF0dXMnLFxuICAgICdkZXNjcmlwdGlvbic6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgc3RhdHVzID0gdmFsdWUuam9pbignJyk7XG5cbiAgICAgIGlmIChzdGF0dXMgPT09ICdBJykge1xuICAgICAgICByZXR1cm4gJ01lYXN1cmVtZW50IGluIHByb2dyZXNzJztcbiAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSAnVicpIHtcbiAgICAgICAgcmV0dXJuICdNZWFzdXJlbWVudCBJbnRlcm9wZXJhYmlsaXR5JztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICdVbmtub3duJztcbiAgICB9XG4gIH0sXG4gIDB4MDAwYToge1xuICAgICduYW1lJzogJ0dQU01lYXN1cmVNb2RlJyxcbiAgICAnZGVzY3JpcHRpb24nOiBmdW5jdGlvbiBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIG1vZGUgPSB2YWx1ZS5qb2luKCcnKTtcblxuICAgICAgaWYgKG1vZGUgPT09ICcyJykge1xuICAgICAgICByZXR1cm4gJzItZGltZW5zaW9uYWwgbWVhc3VyZW1lbnQnO1xuICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnMycpIHtcbiAgICAgICAgcmV0dXJuICczLWRpbWVuc2lvbmFsIG1lYXN1cmVtZW50JztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICdVbmtub3duJztcbiAgICB9XG4gIH0sXG4gIDB4MDAwYjogJ0dQU0RPUCcsXG4gIDB4MDAwYzoge1xuICAgICduYW1lJzogJ0dQU1NwZWVkUmVmJyxcbiAgICAnZGVzY3JpcHRpb24nOiBmdW5jdGlvbiBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIHJlZiA9IHZhbHVlLmpvaW4oJycpO1xuXG4gICAgICBpZiAocmVmID09PSAnSycpIHtcbiAgICAgICAgcmV0dXJuICdLaWxvbWV0ZXJzIHBlciBob3VyJztcbiAgICAgIH0gZWxzZSBpZiAocmVmID09PSAnTScpIHtcbiAgICAgICAgcmV0dXJuICdNaWxlcyBwZXIgaG91cic7XG4gICAgICB9IGVsc2UgaWYgKHJlZiA9PT0gJ04nKSB7XG4gICAgICAgIHJldHVybiAnS25vdHMnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ1Vua25vd24nO1xuICAgIH1cbiAgfSxcbiAgMHgwMDBkOiAnR1BTU3BlZWQnLFxuICAweDAwMGU6IHtcbiAgICAnbmFtZSc6ICdHUFNUcmFja1JlZicsXG4gICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIHZhciByZWYgPSB2YWx1ZS5qb2luKCcnKTtcblxuICAgICAgaWYgKHJlZiA9PT0gJ1QnKSB7XG4gICAgICAgIHJldHVybiAnVHJ1ZSBkaXJlY3Rpb24nO1xuICAgICAgfSBlbHNlIGlmIChyZWYgPT09ICdNJykge1xuICAgICAgICByZXR1cm4gJ01hZ25ldGljIGRpcmVjdGlvbic7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnVW5rbm93bic7XG4gICAgfVxuICB9LFxuICAweDAwMGY6ICdHUFNUcmFjaycsXG4gIDB4MDAxMDoge1xuICAgICduYW1lJzogJ0dQU0ltZ0RpcmVjdGlvblJlZicsXG4gICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIHZhciByZWYgPSB2YWx1ZS5qb2luKCcnKTtcblxuICAgICAgaWYgKHJlZiA9PT0gJ1QnKSB7XG4gICAgICAgIHJldHVybiAnVHJ1ZSBkaXJlY3Rpb24nO1xuICAgICAgfSBlbHNlIGlmIChyZWYgPT09ICdNJykge1xuICAgICAgICByZXR1cm4gJ01hZ25ldGljIGRpcmVjdGlvbic7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnVW5rbm93bic7XG4gICAgfVxuICB9LFxuICAweDAwMTE6ICdHUFNJbWdEaXJlY3Rpb24nLFxuICAweDAwMTI6ICdHUFNNYXBEYXR1bScsXG4gIDB4MDAxMzoge1xuICAgICduYW1lJzogJ0dQU0Rlc3RMYXRpdHVkZVJlZicsXG4gICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIHZhciByZWYgPSB2YWx1ZS5qb2luKCcnKTtcblxuICAgICAgaWYgKHJlZiA9PT0gJ04nKSB7XG4gICAgICAgIHJldHVybiAnTm9ydGggbGF0aXR1ZGUnO1xuICAgICAgfSBlbHNlIGlmIChyZWYgPT09ICdTJykge1xuICAgICAgICByZXR1cm4gJ1NvdXRoIGxhdGl0dWRlJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICdVbmtub3duJztcbiAgICB9XG4gIH0sXG4gIDB4MDAxNDoge1xuICAgICduYW1lJzogJ0dQU0Rlc3RMYXRpdHVkZScsXG4gICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZVswXVswXSAvIHZhbHVlWzBdWzFdICsgdmFsdWVbMV1bMF0gLyB2YWx1ZVsxXVsxXSAvIDYwICsgdmFsdWVbMl1bMF0gLyB2YWx1ZVsyXVsxXSAvIDM2MDA7XG4gICAgfVxuICB9LFxuICAweDAwMTU6IHtcbiAgICAnbmFtZSc6ICdHUFNEZXN0TG9uZ2l0dWRlUmVmJyxcbiAgICAnZGVzY3JpcHRpb24nOiBmdW5jdGlvbiBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIHJlZiA9IHZhbHVlLmpvaW4oJycpO1xuXG4gICAgICBpZiAocmVmID09PSAnRScpIHtcbiAgICAgICAgcmV0dXJuICdFYXN0IGxvbmdpdHVkZSc7XG4gICAgICB9IGVsc2UgaWYgKHJlZiA9PT0gJ1cnKSB7XG4gICAgICAgIHJldHVybiAnV2VzdCBsb25naXR1ZGUnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ1Vua25vd24nO1xuICAgIH1cbiAgfSxcbiAgMHgwMDE2OiB7XG4gICAgJ25hbWUnOiAnR1BTRGVzdExvbmdpdHVkZScsXG4gICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZVswXVswXSAvIHZhbHVlWzBdWzFdICsgdmFsdWVbMV1bMF0gLyB2YWx1ZVsxXVsxXSAvIDYwICsgdmFsdWVbMl1bMF0gLyB2YWx1ZVsyXVsxXSAvIDM2MDA7XG4gICAgfVxuICB9LFxuICAweDAwMTc6IHtcbiAgICAnbmFtZSc6ICdHUFNEZXN0QmVhcmluZ1JlZicsXG4gICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIHZhciByZWYgPSB2YWx1ZS5qb2luKCcnKTtcblxuICAgICAgaWYgKHJlZiA9PT0gJ1QnKSB7XG4gICAgICAgIHJldHVybiAnVHJ1ZSBkaXJlY3Rpb24nO1xuICAgICAgfSBlbHNlIGlmIChyZWYgPT09ICdNJykge1xuICAgICAgICByZXR1cm4gJ01hZ25ldGljIGRpcmVjdGlvbic7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnVW5rbm93bic7XG4gICAgfVxuICB9LFxuICAweDAwMTg6ICdHUFNEZXN0QmVhcmluZycsXG4gIDB4MDAxOToge1xuICAgICduYW1lJzogJ0dQU0Rlc3REaXN0YW5jZVJlZicsXG4gICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIHZhciByZWYgPSB2YWx1ZS5qb2luKCcnKTtcblxuICAgICAgaWYgKHJlZiA9PT0gJ0snKSB7XG4gICAgICAgIHJldHVybiAnS2lsb21ldGVycyc7XG4gICAgICB9IGVsc2UgaWYgKHJlZiA9PT0gJ00nKSB7XG4gICAgICAgIHJldHVybiAnTWlsZXMnO1xuICAgICAgfSBlbHNlIGlmIChyZWYgPT09ICdOJykge1xuICAgICAgICByZXR1cm4gJ0tub3RzJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICdVbmtub3duJztcbiAgICB9XG4gIH0sXG4gIDB4MDAxYTogJ0dQU0Rlc3REaXN0YW5jZScsXG4gIDB4MDAxYjoge1xuICAgICduYW1lJzogJ0dQU1Byb2Nlc3NpbmdNZXRob2QnLFxuICAgICdkZXNjcmlwdGlvbic6IF90YWdfbmFtZXNfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImdldEVuY29kZWRTdHJpbmdcIl1cbiAgfSxcbiAgMHgwMDFjOiB7XG4gICAgJ25hbWUnOiAnR1BTQXJlYUluZm9ybWF0aW9uJyxcbiAgICAnZGVzY3JpcHRpb24nOiBfdGFnX25hbWVzX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJnZXRFbmNvZGVkU3RyaW5nXCJdXG4gIH0sXG4gIDB4MDAxZDogJ0dQU0RhdGVTdGFtcCcsXG4gIDB4MDAxZToge1xuICAgICduYW1lJzogJ0dQU0RpZmZlcmVudGlhbCcsXG4gICAgJ2Rlc2NyaXB0aW9uJzogZnVuY3Rpb24gZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJ01lYXN1cmVtZW50IHdpdGhvdXQgZGlmZmVyZW50aWFsIGNvcnJlY3Rpb24nO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gJ0RpZmZlcmVudGlhbCBjb3JyZWN0aW9uIGFwcGxpZWQnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ1Vua25vd24nO1xuICAgIH1cbiAgfSxcbiAgMHgwMDFmOiAnR1BTSFBvc2l0aW9uaW5nRXJyb3InXG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdGFnLW5hbWVzLWludGVyb3BlcmFiaWxpdHktaWZkLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90YWctbmFtZXMtaW50ZXJvcGVyYWJpbGl0eS1pZmQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3RhZ19uYW1lc191dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90YWctbmFtZXMtdXRpbHMuanMgKi8gXCIuL3NyYy90YWctbmFtZXMtdXRpbHMuanNcIik7XG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy4gKi9cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gIDB4MDAwMTogJ0ludGVyb3BlcmFiaWxpdHlJbmRleCcsXG4gIDB4MDAwMjoge1xuICAgIG5hbWU6ICdJbnRlcm9wZXJhYmlsaXR5VmVyc2lvbicsXG4gICAgZGVzY3JpcHRpb246IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gT2JqZWN0KF90YWdfbmFtZXNfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImdldFN0cmluZ1ZhbHVlXCJdKSh2YWx1ZSk7XG4gICAgfVxuICB9LFxuICAweDEwMDA6ICdSZWxhdGVkSW1hZ2VGaWxlRm9ybWF0JyxcbiAgMHgxMDAxOiAnUmVsYXRlZEltYWdlV2lkdGgnLFxuICAweDEwMDI6ICdSZWxhdGVkSW1hZ2VIZWlnaHQnXG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdGFnLW5hbWVzLXV0aWxzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90YWctbmFtZXMtdXRpbHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGdldFN0cmluZ1ZhbHVlLCBnZXRFbmNvZGVkU3RyaW5nLCBnZXRDYWxjdWxhdGVkR3BzVmFsdWUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZ2V0U3RyaW5nVmFsdWVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRTdHJpbmdWYWx1ZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZ2V0RW5jb2RlZFN0cmluZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldEVuY29kZWRTdHJpbmc7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdldENhbGN1bGF0ZWRHcHNWYWx1ZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldENhbGN1bGF0ZWRHcHNWYWx1ZTsgfSk7XG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy4gKi9cbmZ1bmN0aW9uIGdldFN0cmluZ1ZhbHVlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5tYXAoZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICB9KS5qb2luKCcnKTtcbn1cbmZ1bmN0aW9uIGdldEVuY29kZWRTdHJpbmcodmFsdWUpIHtcbiAgaWYgKHZhbHVlLmxlbmd0aCA+PSA4KSB7XG4gICAgdmFyIGVuY29kaW5nID0gZ2V0U3RyaW5nVmFsdWUodmFsdWUuc2xpY2UoMCwgOCkpO1xuXG4gICAgaWYgKGVuY29kaW5nID09PSAnQVNDSUlcXHgwMFxceDAwXFx4MDAnKSB7XG4gICAgICByZXR1cm4gZ2V0U3RyaW5nVmFsdWUodmFsdWUuc2xpY2UoOCkpO1xuICAgIH0gZWxzZSBpZiAoZW5jb2RpbmcgPT09ICdKSVNcXHgwMFxceDAwXFx4MDBcXHgwMFxceDAwJykge1xuICAgICAgcmV0dXJuICdbSklTIGVuY29kZWQgdGV4dF0nO1xuICAgIH0gZWxzZSBpZiAoZW5jb2RpbmcgPT09ICdVTklDT0RFXFx4MDAnKSB7XG4gICAgICByZXR1cm4gJ1tVbmljb2RlIGVuY29kZWQgdGV4dF0nO1xuICAgIH0gZWxzZSBpZiAoZW5jb2RpbmcgPT09ICdcXHgwMFxceDAwXFx4MDBcXHgwMFxceDAwXFx4MDBcXHgwMFxceDAwJykge1xuICAgICAgcmV0dXJuICdbVW5kZWZpbmVkIGVuY29kaW5nXSc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICdVbmRlZmluZWQnO1xufVxuZnVuY3Rpb24gZ2V0Q2FsY3VsYXRlZEdwc1ZhbHVlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZVswXVswXSAvIHZhbHVlWzBdWzFdICsgdmFsdWVbMV1bMF0gLyB2YWx1ZVsxXVsxXSAvIDYwICsgdmFsdWVbMl1bMF0gLyB2YWx1ZVsyXVsxXSAvIDM2MDA7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3RhZy1uYW1lcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdGFnLW5hbWVzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlscy5qcyAqLyBcIi4vc3JjL3V0aWxzLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90YWdfbmFtZXNfMHRoX2lmZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90YWctbmFtZXMtMHRoLWlmZC5qcyAqLyBcIi4vc3JjL3RhZy1uYW1lcy0wdGgtaWZkLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90YWdfbmFtZXNfZXhpZl9pZmRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdGFnLW5hbWVzLWV4aWYtaWZkLmpzICovIFwiLi9zcmMvdGFnLW5hbWVzLWV4aWYtaWZkLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90YWdfbmFtZXNfZ3BzX2lmZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90YWctbmFtZXMtZ3BzLWlmZC5qcyAqLyBcIi4vc3JjL3RhZy1uYW1lcy1ncHMtaWZkLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90YWdfbmFtZXNfaW50ZXJvcGVyYWJpbGl0eV9pZmRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdGFnLW5hbWVzLWludGVyb3BlcmFiaWxpdHktaWZkLmpzICovIFwiLi9zcmMvdGFnLW5hbWVzLWludGVyb3BlcmFiaWxpdHktaWZkLmpzXCIpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uICovXG5cblxuXG5cblxudmFyIHRhZ05hbWVzMHRoRXhpZklmZHMgPSBPYmplY3QoX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJvYmplY3RBc3NpZ25cIl0pKHt9LCBfdGFnX25hbWVzXzB0aF9pZmRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0sIF90YWdfbmFtZXNfZXhpZl9pZmRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0pO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICcwdGgnOiB0YWdOYW1lczB0aEV4aWZJZmRzLFxuICAnZXhpZic6IHRhZ05hbWVzMHRoRXhpZklmZHMsXG4gICdncHMnOiBfdGFnX25hbWVzX2dwc19pZmRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0sXG4gICdpbnRlcm9wZXJhYmlsaXR5JzogX3RhZ19uYW1lc19pbnRlcm9wZXJhYmlsaXR5X2lmZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiZGVmYXVsdFwiXVxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3RhZ3MuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90YWdzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29uc3RhbnRzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnN0YW50cy5qcyAqLyBcIi4vc3JjL2NvbnN0YW50cy5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMuanMgKi8gXCIuL3NyYy91dGlscy5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYnl0ZV9vcmRlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9ieXRlLW9yZGVyLmpzICovIFwiLi9zcmMvYnl0ZS1vcmRlci5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHlwZXMuanMgKi8gXCIuL3NyYy90eXBlcy5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdGFnX25hbWVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RhZy1uYW1lcy5qcyAqLyBcIi4vc3JjL3RhZy1uYW1lcy5qc1wiKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwczovL21vemlsbGEub3JnL01QTC8yLjAvLiAqL1xuXG5cblxuXG5cbnZhciBFWElGX0lGRF9QT0lOVEVSX0tFWSA9ICdFeGlmIElGRCBQb2ludGVyJztcbnZhciBHUFNfSU5GT19JRkRfUE9JTlRFUl9LRVkgPSAnR1BTIEluZm8gSUZEIFBvaW50ZXInO1xudmFyIElOVEVST1BFUkFCSUxJVFlfSUZEX1BPSU5URVJfS0VZID0gJ0ludGVyb3BlcmFiaWxpdHkgSUZEIFBvaW50ZXInO1xudmFyIGdldFRhZ1ZhbHVlQXQgPSB7XG4gIDE6IF90eXBlc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXS5nZXRCeXRlQXQsXG4gIDI6IF90eXBlc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXS5nZXRBc2NpaUF0LFxuICAzOiBfdHlwZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0uZ2V0U2hvcnRBdCxcbiAgNDogX3R5cGVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdLmdldExvbmdBdCxcbiAgNTogX3R5cGVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdLmdldFJhdGlvbmFsQXQsXG4gIDc6IF90eXBlc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXS5nZXRVbmRlZmluZWRBdCxcbiAgOTogX3R5cGVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdLmdldFNsb25nQXQsXG4gIDEwOiBfdHlwZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0uZ2V0U3JhdGlvbmFsQXQsXG4gIDEzOiBfdHlwZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0uZ2V0SWZkUG9pbnRlckF0XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gIHJlYWQ6IHJlYWRcbn0pO1xuXG5mdW5jdGlvbiByZWFkKGRhdGFWaWV3LCB0aWZmSGVhZGVyT2Zmc2V0KSB7XG4gIHZhciBieXRlT3JkZXIgPSBfYnl0ZV9vcmRlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXS5nZXRCeXRlT3JkZXIoZGF0YVZpZXcsIHRpZmZIZWFkZXJPZmZzZXQpO1xuICB2YXIgdGFncyA9IHJlYWQwdGhJZmQoZGF0YVZpZXcsIHRpZmZIZWFkZXJPZmZzZXQsIGJ5dGVPcmRlcik7XG4gIHRhZ3MgPSByZWFkRXhpZklmZCh0YWdzLCBkYXRhVmlldywgdGlmZkhlYWRlck9mZnNldCwgYnl0ZU9yZGVyKTtcbiAgdGFncyA9IHJlYWRHcHNJZmQodGFncywgZGF0YVZpZXcsIHRpZmZIZWFkZXJPZmZzZXQsIGJ5dGVPcmRlcik7XG4gIHRhZ3MgPSByZWFkSW50ZXJvcGVyYWJpbGl0eUlmZCh0YWdzLCBkYXRhVmlldywgdGlmZkhlYWRlck9mZnNldCwgYnl0ZU9yZGVyKTtcbiAgcmV0dXJuIHRhZ3M7XG59XG5cbmZ1bmN0aW9uIHJlYWQwdGhJZmQoZGF0YVZpZXcsIHRpZmZIZWFkZXJPZmZzZXQsIGJ5dGVPcmRlcikge1xuICByZXR1cm4gcmVhZElmZChkYXRhVmlldywgJzB0aCcsIHRpZmZIZWFkZXJPZmZzZXQsIGdldDB0aElmZE9mZnNldChkYXRhVmlldywgdGlmZkhlYWRlck9mZnNldCwgYnl0ZU9yZGVyKSwgYnl0ZU9yZGVyKTtcbn1cblxuZnVuY3Rpb24gZ2V0MHRoSWZkT2Zmc2V0KGRhdGFWaWV3LCB0aWZmSGVhZGVyT2Zmc2V0LCBieXRlT3JkZXIpIHtcbiAgcmV0dXJuIHRpZmZIZWFkZXJPZmZzZXQgKyBfdHlwZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0uZ2V0TG9uZ0F0KGRhdGFWaWV3LCB0aWZmSGVhZGVyT2Zmc2V0ICsgNCwgYnl0ZU9yZGVyKTtcbn1cblxuZnVuY3Rpb24gcmVhZEV4aWZJZmQodGFncywgZGF0YVZpZXcsIHRpZmZIZWFkZXJPZmZzZXQsIGJ5dGVPcmRlcikge1xuICBpZiAodGFnc1tFWElGX0lGRF9QT0lOVEVSX0tFWV0gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBPYmplY3QoX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJvYmplY3RBc3NpZ25cIl0pKHRhZ3MsIHJlYWRJZmQoZGF0YVZpZXcsICdleGlmJywgdGlmZkhlYWRlck9mZnNldCwgdGlmZkhlYWRlck9mZnNldCArIHRhZ3NbRVhJRl9JRkRfUE9JTlRFUl9LRVldLnZhbHVlLCBieXRlT3JkZXIpKTtcbiAgfVxuXG4gIHJldHVybiB0YWdzO1xufVxuXG5mdW5jdGlvbiByZWFkR3BzSWZkKHRhZ3MsIGRhdGFWaWV3LCB0aWZmSGVhZGVyT2Zmc2V0LCBieXRlT3JkZXIpIHtcbiAgaWYgKHRhZ3NbR1BTX0lORk9fSUZEX1BPSU5URVJfS0VZXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIE9iamVjdChfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIm9iamVjdEFzc2lnblwiXSkodGFncywgcmVhZElmZChkYXRhVmlldywgJ2dwcycsIHRpZmZIZWFkZXJPZmZzZXQsIHRpZmZIZWFkZXJPZmZzZXQgKyB0YWdzW0dQU19JTkZPX0lGRF9QT0lOVEVSX0tFWV0udmFsdWUsIGJ5dGVPcmRlcikpO1xuICB9XG5cbiAgcmV0dXJuIHRhZ3M7XG59XG5cbmZ1bmN0aW9uIHJlYWRJbnRlcm9wZXJhYmlsaXR5SWZkKHRhZ3MsIGRhdGFWaWV3LCB0aWZmSGVhZGVyT2Zmc2V0LCBieXRlT3JkZXIpIHtcbiAgaWYgKHRhZ3NbSU5URVJPUEVSQUJJTElUWV9JRkRfUE9JTlRFUl9LRVldICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gT2JqZWN0KF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wib2JqZWN0QXNzaWduXCJdKSh0YWdzLCByZWFkSWZkKGRhdGFWaWV3LCAnaW50ZXJvcGVyYWJpbGl0eScsIHRpZmZIZWFkZXJPZmZzZXQsIHRpZmZIZWFkZXJPZmZzZXQgKyB0YWdzW0lOVEVST1BFUkFCSUxJVFlfSUZEX1BPSU5URVJfS0VZXS52YWx1ZSwgYnl0ZU9yZGVyKSk7XG4gIH1cblxuICByZXR1cm4gdGFncztcbn1cblxuZnVuY3Rpb24gcmVhZElmZChkYXRhVmlldywgaWZkVHlwZSwgdGlmZkhlYWRlck9mZnNldCwgb2Zmc2V0LCBieXRlT3JkZXIpIHtcbiAgdmFyIEZJRUxEX0NPVU5UX1NJWkUgPSBfdHlwZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0uZ2V0VHlwZVNpemUoJ1NIT1JUJyk7XG4gIHZhciBGSUVMRF9TSVpFID0gMTI7XG4gIHZhciB0YWdzID0ge307XG4gIHZhciBudW1iZXJPZkZpZWxkcyA9IGdldE51bWJlck9mRmllbGRzKGRhdGFWaWV3LCBvZmZzZXQsIGJ5dGVPcmRlcik7XG4gIG9mZnNldCArPSBGSUVMRF9DT1VOVF9TSVpFO1xuXG4gIGZvciAodmFyIGZpZWxkSW5kZXggPSAwOyBmaWVsZEluZGV4IDwgbnVtYmVyT2ZGaWVsZHM7IGZpZWxkSW5kZXgrKykge1xuICAgIGlmIChvZmZzZXQgKyBGSUVMRF9TSVpFID4gZGF0YVZpZXcuYnl0ZUxlbmd0aCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIHRhZyA9IHJlYWRUYWcoZGF0YVZpZXcsIGlmZFR5cGUsIHRpZmZIZWFkZXJPZmZzZXQsIG9mZnNldCwgYnl0ZU9yZGVyKTtcblxuICAgIGlmICh0YWcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFnc1t0YWcubmFtZV0gPSB7XG4gICAgICAgICdpZCc6IHRhZy5pZCxcbiAgICAgICAgJ3ZhbHVlJzogdGFnLnZhbHVlLFxuICAgICAgICAnZGVzY3JpcHRpb24nOiB0YWcuZGVzY3JpcHRpb25cbiAgICAgIH07XG4gICAgfVxuXG4gICAgb2Zmc2V0ICs9IEZJRUxEX1NJWkU7XG4gIH1cblxuICBpZiAoX2NvbnN0YW50c19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXS5VU0VfVEhVTUJOQUlMICYmIG9mZnNldCA8IGRhdGFWaWV3LmJ5dGVMZW5ndGggLSBfdHlwZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0uZ2V0VHlwZVNpemUoJ0xPTkcnKSkge1xuICAgIHZhciBuZXh0SWZkT2Zmc2V0ID0gX3R5cGVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdLmdldExvbmdBdChkYXRhVmlldywgb2Zmc2V0LCBieXRlT3JkZXIpO1xuXG4gICAgaWYgKG5leHRJZmRPZmZzZXQgIT09IDApIHtcbiAgICAgIHRhZ3NbJ1RodW1ibmFpbCddID0gcmVhZElmZChkYXRhVmlldywgaWZkVHlwZSwgdGlmZkhlYWRlck9mZnNldCwgdGlmZkhlYWRlck9mZnNldCArIG5leHRJZmRPZmZzZXQsIGJ5dGVPcmRlcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhZ3M7XG59XG5cbmZ1bmN0aW9uIGdldE51bWJlck9mRmllbGRzKGRhdGFWaWV3LCBvZmZzZXQsIGJ5dGVPcmRlcikge1xuICBpZiAob2Zmc2V0ICsgX3R5cGVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdLmdldFR5cGVTaXplKCdTSE9SVCcpIDw9IGRhdGFWaWV3LmJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gX3R5cGVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdLmdldFNob3J0QXQoZGF0YVZpZXcsIG9mZnNldCwgYnl0ZU9yZGVyKTtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiByZWFkVGFnKGRhdGFWaWV3LCBpZmRUeXBlLCB0aWZmSGVhZGVyT2Zmc2V0LCBvZmZzZXQsIGJ5dGVPcmRlcikge1xuICB2YXIgVEFHX0NPREVfSVBUQ19OQUEgPSAweDgzYmI7XG4gIHZhciBUQUdfVFlQRV9PRkZTRVQgPSBfdHlwZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0uZ2V0VHlwZVNpemUoJ1NIT1JUJyk7XG4gIHZhciBUQUdfQ09VTlRfT0ZGU0VUID0gVEFHX1RZUEVfT0ZGU0VUICsgX3R5cGVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdLmdldFR5cGVTaXplKCdTSE9SVCcpO1xuICB2YXIgVEFHX1ZBTFVFX09GRlNFVCA9IFRBR19DT1VOVF9PRkZTRVQgKyBfdHlwZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0uZ2V0VHlwZVNpemUoJ0xPTkcnKTtcbiAgdmFyIHRhZ0NvZGUgPSBfdHlwZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0uZ2V0U2hvcnRBdChkYXRhVmlldywgb2Zmc2V0LCBieXRlT3JkZXIpO1xuICB2YXIgdGFnVHlwZSA9IF90eXBlc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXS5nZXRTaG9ydEF0KGRhdGFWaWV3LCBvZmZzZXQgKyBUQUdfVFlQRV9PRkZTRVQsIGJ5dGVPcmRlcik7XG4gIHZhciB0YWdDb3VudCA9IF90eXBlc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXS5nZXRMb25nQXQoZGF0YVZpZXcsIG9mZnNldCArIFRBR19DT1VOVF9PRkZTRVQsIGJ5dGVPcmRlcik7XG4gIHZhciB0YWdWYWx1ZTtcblxuICBpZiAoX3R5cGVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdLnR5cGVTaXplc1t0YWdUeXBlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0YWdWYWx1ZUZpdHNJbk9mZnNldFNsb3QodGFnVHlwZSwgdGFnQ291bnQpKSB7XG4gICAgdGFnVmFsdWUgPSBnZXRUYWdWYWx1ZShkYXRhVmlldywgb2Zmc2V0ICsgVEFHX1ZBTFVFX09GRlNFVCwgdGFnVHlwZSwgdGFnQ291bnQsIGJ5dGVPcmRlcik7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhZ1ZhbHVlT2Zmc2V0ID0gX3R5cGVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdLmdldExvbmdBdChkYXRhVmlldywgb2Zmc2V0ICsgVEFHX1ZBTFVFX09GRlNFVCwgYnl0ZU9yZGVyKTtcblxuICAgIGlmICh0YWdWYWx1ZUZpdHNJbkRhdGFWaWV3KGRhdGFWaWV3LCB0aWZmSGVhZGVyT2Zmc2V0LCB0YWdWYWx1ZU9mZnNldCwgdGFnVHlwZSwgdGFnQ291bnQpKSB7XG4gICAgICB2YXIgZm9yY2VCeXRlVHlwZSA9IHRhZ0NvZGUgPT09IFRBR19DT0RFX0lQVENfTkFBO1xuICAgICAgdGFnVmFsdWUgPSBnZXRUYWdWYWx1ZShkYXRhVmlldywgdGlmZkhlYWRlck9mZnNldCArIHRhZ1ZhbHVlT2Zmc2V0LCB0YWdUeXBlLCB0YWdDb3VudCwgYnl0ZU9yZGVyLCBmb3JjZUJ5dGVUeXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFnVmFsdWUgPSAnPGZhdWx0eSB2YWx1ZT4nO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0YWdUeXBlID09PSBfdHlwZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0udGFnVHlwZXNbJ0FTQ0lJJ10pIHtcbiAgICB0YWdWYWx1ZSA9IHNwbGl0TnVsbFNlcGFyYXRlZEFzY2lpU3RyaW5nKHRhZ1ZhbHVlKTtcbiAgICB0YWdWYWx1ZSA9IGRlY29kZUFzY2lpVmFsdWUodGFnVmFsdWUpO1xuICB9XG5cbiAgdmFyIHRhZ05hbWUgPSBcInVuZGVmaW5lZC1cIi5jb25jYXQodGFnQ29kZSk7XG4gIHZhciB0YWdEZXNjcmlwdGlvbiA9IHRhZ1ZhbHVlO1xuXG4gIGlmIChfdGFnX25hbWVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJkZWZhdWx0XCJdW2lmZFR5cGVdW3RhZ0NvZGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoX3RhZ19uYW1lc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiZGVmYXVsdFwiXVtpZmRUeXBlXVt0YWdDb2RlXVsnbmFtZSddICE9PSB1bmRlZmluZWQgJiYgX3RhZ19uYW1lc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiZGVmYXVsdFwiXVtpZmRUeXBlXVt0YWdDb2RlXVsnZGVzY3JpcHRpb24nXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YWdOYW1lID0gX3RhZ19uYW1lc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiZGVmYXVsdFwiXVtpZmRUeXBlXVt0YWdDb2RlXVsnbmFtZSddO1xuXG4gICAgICB0cnkge1xuICAgICAgICB0YWdEZXNjcmlwdGlvbiA9IF90YWdfbmFtZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImRlZmF1bHRcIl1baWZkVHlwZV1bdGFnQ29kZV1bJ2Rlc2NyaXB0aW9uJ10odGFnVmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGFnRGVzY3JpcHRpb24gPSBnZXREZXNjcmlwdGlvbkZyb21UYWdWYWx1ZSh0YWdWYWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0YWdUeXBlID09PSBfdHlwZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0udGFnVHlwZXNbJ1JBVElPTkFMJ10gfHwgdGFnVHlwZSA9PT0gX3R5cGVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdLnRhZ1R5cGVzWydTUkFUSU9OQUwnXSkge1xuICAgICAgdGFnTmFtZSA9IF90YWdfbmFtZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImRlZmF1bHRcIl1baWZkVHlwZV1bdGFnQ29kZV07XG4gICAgICB0YWdEZXNjcmlwdGlvbiA9ICcnICsgdGFnVmFsdWVbMF0gLyB0YWdWYWx1ZVsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFnTmFtZSA9IF90YWdfbmFtZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImRlZmF1bHRcIl1baWZkVHlwZV1bdGFnQ29kZV07XG4gICAgICB0YWdEZXNjcmlwdGlvbiA9IGdldERlc2NyaXB0aW9uRnJvbVRhZ1ZhbHVlKHRhZ1ZhbHVlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGlkOiB0YWdDb2RlLFxuICAgIG5hbWU6IHRhZ05hbWUsXG4gICAgdmFsdWU6IHRhZ1ZhbHVlLFxuICAgIGRlc2NyaXB0aW9uOiB0YWdEZXNjcmlwdGlvblxuICB9O1xufVxuXG5mdW5jdGlvbiB0YWdWYWx1ZUZpdHNJbk9mZnNldFNsb3QodGFnVHlwZSwgdGFnQ291bnQpIHtcbiAgcmV0dXJuIF90eXBlc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXS50eXBlU2l6ZXNbdGFnVHlwZV0gKiB0YWdDb3VudCA8PSBfdHlwZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0uZ2V0VHlwZVNpemUoJ0xPTkcnKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGFnVmFsdWUoZGF0YVZpZXcsIG9mZnNldCwgdHlwZSwgY291bnQsIGJ5dGVPcmRlcikge1xuICB2YXIgZm9yY2VCeXRlVHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogZmFsc2U7XG4gIHZhciB2YWx1ZSA9IFtdO1xuXG4gIGlmIChmb3JjZUJ5dGVUeXBlKSB7XG4gICAgY291bnQgPSBjb3VudCAqIF90eXBlc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXS50eXBlU2l6ZXNbdHlwZV07XG4gICAgdHlwZSA9IF90eXBlc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXS50YWdUeXBlc1snQllURSddO1xuICB9XG5cbiAgZm9yICh2YXIgdmFsdWVJbmRleCA9IDA7IHZhbHVlSW5kZXggPCBjb3VudDsgdmFsdWVJbmRleCsrKSB7XG4gICAgdmFsdWUucHVzaChnZXRUYWdWYWx1ZUF0W3R5cGVdKGRhdGFWaWV3LCBvZmZzZXQsIGJ5dGVPcmRlcikpO1xuICAgIG9mZnNldCArPSBfdHlwZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0udHlwZVNpemVzW3R5cGVdO1xuICB9XG5cbiAgaWYgKHR5cGUgPT09IF90eXBlc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXS50YWdUeXBlc1snQVNDSUknXSkge1xuICAgIHZhbHVlID0gX3R5cGVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdLmdldEFzY2lpVmFsdWUodmFsdWUpO1xuICB9IGVsc2UgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhbHVlID0gdmFsdWVbMF07XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHRhZ1ZhbHVlRml0c0luRGF0YVZpZXcoZGF0YVZpZXcsIHRpZmZIZWFkZXJPZmZzZXQsIHRhZ1ZhbHVlT2Zmc2V0LCB0YWdUeXBlLCB0YWdDb3VudCkge1xuICByZXR1cm4gdGlmZkhlYWRlck9mZnNldCArIHRhZ1ZhbHVlT2Zmc2V0ICsgX3R5cGVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdLnR5cGVTaXplc1t0YWdUeXBlXSAqIHRhZ0NvdW50IDw9IGRhdGFWaWV3LmJ5dGVMZW5ndGg7XG59XG5cbmZ1bmN0aW9uIHNwbGl0TnVsbFNlcGFyYXRlZEFzY2lpU3RyaW5nKHN0cmluZykge1xuICB2YXIgdGFnVmFsdWUgPSBbXTtcbiAgdmFyIGkgPSAwO1xuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgc3RyaW5nLmxlbmd0aDsgaisrKSB7XG4gICAgaWYgKHN0cmluZ1tqXSA9PT0gJ1xceDAwJykge1xuICAgICAgaSsrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHRhZ1ZhbHVlW2ldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhZ1ZhbHVlW2ldID0gJyc7XG4gICAgfVxuXG4gICAgdGFnVmFsdWVbaV0gKz0gc3RyaW5nW2pdO1xuICB9XG5cbiAgcmV0dXJuIHRhZ1ZhbHVlO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVBc2NpaVZhbHVlKGFzY2lpVmFsdWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXNjaWlWYWx1ZS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZSh2YWx1ZSkpO1xuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBhc2NpaVZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlc2NyaXB0aW9uRnJvbVRhZ1ZhbHVlKHRhZ1ZhbHVlKSB7XG4gIGlmICh0YWdWYWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgcmV0dXJuIHRhZ1ZhbHVlLmpvaW4oJywgJyk7XG4gIH1cblxuICByZXR1cm4gdGFnVmFsdWU7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3RleHQtZGVjb2Rlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdGV4dC1kZWNvZGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgZ2V0OiBnZXRcbn0pO1xuXG5mdW5jdGlvbiBnZXQoKSB7XG4gIGlmICh0eXBlb2YgVGV4dERlY29kZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIFRleHREZWNvZGVyO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdGh1bWJuYWlsLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90aHVtYm5haWwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzLmpzICovIFwiLi9zcmMvdXRpbHMuanNcIik7XG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwczovL21vemlsbGEub3JnL01QTC8yLjAvLiAqL1xuIC8vIGh0dHBzOi8vZXhpZnRvb2wub3JnL1RhZ05hbWVzL0VYSUYuaHRtbCNDb21wcmVzc2lvblxuXG52YXIgQ09NUFJFU1NJT05fSlBFRyA9IFs2LCA3LCA5OV07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgZ2V0OiBnZXRcbn0pO1xuXG5mdW5jdGlvbiBnZXQoZGF0YVZpZXcsIHRodW1ibmFpbFRhZ3MsIHRpZmZIZWFkZXJPZmZzZXQpIHtcbiAgaWYgKGhhc0pwZWdUaHVtYm5haWwodGh1bWJuYWlsVGFncykpIHtcbiAgICB0aHVtYm5haWxUYWdzLnR5cGUgPSAnaW1hZ2UvanBlZyc7XG4gICAgdmFyIG9mZnNldCA9IHRpZmZIZWFkZXJPZmZzZXQgKyB0aHVtYm5haWxUYWdzLkpQRUdJbnRlcmNoYW5nZUZvcm1hdC52YWx1ZTtcbiAgICB0aHVtYm5haWxUYWdzLmltYWdlID0gZGF0YVZpZXcuYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgdGh1bWJuYWlsVGFncy5KUEVHSW50ZXJjaGFuZ2VGb3JtYXRMZW5ndGgudmFsdWUpO1xuICAgIE9iamVjdChfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmVySW5pdFwiXSkodGh1bWJuYWlsVGFncywgJ2Jhc2U2NCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBnZXRCYXNlNjRJbWFnZSh0aGlzLmltYWdlKTtcbiAgICB9KTtcbiAgfSAvLyBUaGVyZSBpcyBhIHNtYWxsIHBvc3NpYmlsaXR5IG9mIHRodW1ibmFpbHMgaW4gVElGRiBmb3JtYXQgYnV0IHRoZXkgYXJlXG4gIC8vIG5vdCBzdG9yZWQgYXMgYSBzZWxmLWNvbnRhaW5lZCBpbWFnZSBmaWxlIGFuZCB3b3VsZCBiZSBtdWNoIG1vcmVcbiAgLy8gZGlmZmljdWx0IHRvIGV4dHJhY3QuXG4gIC8vIGh0dHBzOi8vZXhpZnRvb2wub3JnL2ZvcnVtL2luZGV4LnBocD90b3BpYz0zMjczLm1zZzE0Nzc4I21zZzE0Nzc4XG5cblxuICByZXR1cm4gdGh1bWJuYWlsVGFncztcbn1cblxuZnVuY3Rpb24gaGFzSnBlZ1RodW1ibmFpbCh0YWdzKSB7XG4gIHJldHVybiB0YWdzICYmICh0YWdzLkNvbXByZXNzaW9uID09PSB1bmRlZmluZWQgfHwgQ09NUFJFU1NJT05fSlBFRy5pbmNsdWRlcyh0YWdzLkNvbXByZXNzaW9uLnZhbHVlKSkgJiYgdGFncy5KUEVHSW50ZXJjaGFuZ2VGb3JtYXQgJiYgdGFncy5KUEVHSW50ZXJjaGFuZ2VGb3JtYXQudmFsdWUgJiYgdGFncy5KUEVHSW50ZXJjaGFuZ2VGb3JtYXRMZW5ndGggJiYgdGFncy5KUEVHSW50ZXJjaGFuZ2VGb3JtYXRMZW5ndGgudmFsdWU7XG59XG5cbmZ1bmN0aW9uIGdldEJhc2U2NEltYWdlKGltYWdlKSB7XG4gIGlmICh0eXBlb2YgYnRvYSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBJRTExLSBkb2VzIG5vdCBpbXBsZW1lbnQgcmVkdWNlIG9uIHRoZSBVaW50OEFycmF5IHByb3RvdHlwZS5cbiAgICByZXR1cm4gYnRvYShBcnJheS5wcm90b3R5cGUucmVkdWNlLmNhbGwobmV3IFVpbnQ4QXJyYXkoaW1hZ2UpLCBmdW5jdGlvbiAoZGF0YSwgX2J5dGUpIHtcbiAgICAgIHJldHVybiBkYXRhICsgU3RyaW5nLmZyb21DaGFyQ29kZShfYnl0ZSk7XG4gICAgfSwgJycpKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgQnVmZmVyID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoX3R5cGVvZihCdWZmZXIuZnJvbSkgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oaW1hZ2UpLnRvU3RyaW5nKCdiYXNlNjQnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICB9XG5cbiAgcmV0dXJuIG5ldyBCdWZmZXIoaW1hZ2UpLnRvU3RyaW5nKCdiYXNlNjQnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90eXBlcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90eXBlcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ieXRlX29yZGVyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2J5dGUtb3JkZXIuanMgKi8gXCIuL3NyYy9ieXRlLW9yZGVyLmpzXCIpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uICovXG5cbnZhciB0eXBlU2l6ZXMgPSB7XG4gIDE6IDEsXG4gIC8vIEJZVEVcbiAgMjogMSxcbiAgLy8gQVNDSUlcbiAgMzogMixcbiAgLy8gU0hPUlRcbiAgNDogNCxcbiAgLy8gTE9OR1xuICA1OiA4LFxuICAvLyBSQVRJT05BTFxuICA3OiAxLFxuICAvLyBVTkRFRklORURcbiAgOTogNCxcbiAgLy8gU0xPTkdcbiAgMTA6IDgsXG4gIC8vIFNSQVRJT05BTFxuICAxMzogNCAvLyBJRkRcblxufTtcbnZhciB0YWdUeXBlcyA9IHtcbiAgJ0JZVEUnOiAxLFxuICAnQVNDSUknOiAyLFxuICAnU0hPUlQnOiAzLFxuICAnTE9ORyc6IDQsXG4gICdSQVRJT05BTCc6IDUsXG4gICdVTkRFRklORUQnOiA3LFxuICAnU0xPTkcnOiA5LFxuICAnU1JBVElPTkFMJzogMTAsXG4gICdJRkQnOiAxM1xufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICBnZXRBc2NpaVZhbHVlOiBnZXRBc2NpaVZhbHVlLFxuICBnZXRCeXRlQXQ6IGdldEJ5dGVBdCxcbiAgZ2V0QXNjaWlBdDogZ2V0QXNjaWlBdCxcbiAgZ2V0U2hvcnRBdDogZ2V0U2hvcnRBdCxcbiAgZ2V0TG9uZ0F0OiBnZXRMb25nQXQsXG4gIGdldFJhdGlvbmFsQXQ6IGdldFJhdGlvbmFsQXQsXG4gIGdldFVuZGVmaW5lZEF0OiBnZXRVbmRlZmluZWRBdCxcbiAgZ2V0U2xvbmdBdDogZ2V0U2xvbmdBdCxcbiAgZ2V0U3JhdGlvbmFsQXQ6IGdldFNyYXRpb25hbEF0LFxuICBnZXRJZmRQb2ludGVyQXQ6IGdldElmZFBvaW50ZXJBdCxcbiAgdHlwZVNpemVzOiB0eXBlU2l6ZXMsXG4gIHRhZ1R5cGVzOiB0YWdUeXBlcyxcbiAgZ2V0VHlwZVNpemU6IGdldFR5cGVTaXplXG59KTtcblxuZnVuY3Rpb24gZ2V0QXNjaWlWYWx1ZShjaGFyQXJyYXkpIHtcbiAgcmV0dXJuIGNoYXJBcnJheS5tYXAoZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0Qnl0ZUF0KGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgcmV0dXJuIGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCk7XG59XG5cbmZ1bmN0aW9uIGdldEFzY2lpQXQoZGF0YVZpZXcsIG9mZnNldCkge1xuICByZXR1cm4gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0KTtcbn1cblxuZnVuY3Rpb24gZ2V0U2hvcnRBdChkYXRhVmlldywgb2Zmc2V0LCBieXRlT3JkZXIpIHtcbiAgcmV0dXJuIGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQsIGJ5dGVPcmRlciA9PT0gX2J5dGVfb3JkZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0uTElUVExFX0VORElBTik7XG59XG5cbmZ1bmN0aW9uIGdldExvbmdBdChkYXRhVmlldywgb2Zmc2V0LCBieXRlT3JkZXIpIHtcbiAgcmV0dXJuIGRhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQsIGJ5dGVPcmRlciA9PT0gX2J5dGVfb3JkZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0uTElUVExFX0VORElBTik7XG59XG5cbmZ1bmN0aW9uIGdldFJhdGlvbmFsQXQoZGF0YVZpZXcsIG9mZnNldCwgYnl0ZU9yZGVyKSB7XG4gIHJldHVybiBbZ2V0TG9uZ0F0KGRhdGFWaWV3LCBvZmZzZXQsIGJ5dGVPcmRlciksIGdldExvbmdBdChkYXRhVmlldywgb2Zmc2V0ICsgNCwgYnl0ZU9yZGVyKV07XG59XG5cbmZ1bmN0aW9uIGdldFVuZGVmaW5lZEF0KGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgcmV0dXJuIGdldEJ5dGVBdChkYXRhVmlldywgb2Zmc2V0KTtcbn1cblxuZnVuY3Rpb24gZ2V0U2xvbmdBdChkYXRhVmlldywgb2Zmc2V0LCBieXRlT3JkZXIpIHtcbiAgcmV0dXJuIGRhdGFWaWV3LmdldEludDMyKG9mZnNldCwgYnl0ZU9yZGVyID09PSBfYnl0ZV9vcmRlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXS5MSVRUTEVfRU5ESUFOKTtcbn1cblxuZnVuY3Rpb24gZ2V0U3JhdGlvbmFsQXQoZGF0YVZpZXcsIG9mZnNldCwgYnl0ZU9yZGVyKSB7XG4gIHJldHVybiBbZ2V0U2xvbmdBdChkYXRhVmlldywgb2Zmc2V0LCBieXRlT3JkZXIpLCBnZXRTbG9uZ0F0KGRhdGFWaWV3LCBvZmZzZXQgKyA0LCBieXRlT3JkZXIpXTtcbn1cblxuZnVuY3Rpb24gZ2V0SWZkUG9pbnRlckF0KGRhdGFWaWV3LCBvZmZzZXQsIGJ5dGVPcmRlcikge1xuICByZXR1cm4gZ2V0TG9uZ0F0KGRhdGFWaWV3LCBvZmZzZXQsIGJ5dGVPcmRlcik7XG59XG5cbmZ1bmN0aW9uIGdldFR5cGVTaXplKHR5cGVOYW1lKSB7XG4gIGlmICh0YWdUeXBlc1t0eXBlTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gc3VjaCB0eXBlIGZvdW5kLicpO1xuICB9XG5cbiAgcmV0dXJuIHR5cGVTaXplc1t0YWdUeXBlc1t0eXBlTmFtZV1dO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBnZXRTdHJpbmdGcm9tRGF0YVZpZXcsIGdldFVuaWNvZGVTdHJpbmdGcm9tRGF0YVZpZXcsIGdldFN0cmluZ1ZhbHVlRnJvbUFycmF5LCBnZXRDaGFyYWN0ZXJBcnJheSwgb2JqZWN0QXNzaWduLCBkZWZlckluaXQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZ2V0U3RyaW5nRnJvbURhdGFWaWV3XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0U3RyaW5nRnJvbURhdGFWaWV3OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJnZXRVbmljb2RlU3RyaW5nRnJvbURhdGFWaWV3XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0VW5pY29kZVN0cmluZ0Zyb21EYXRhVmlldzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZ2V0U3RyaW5nVmFsdWVGcm9tQXJyYXlcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRTdHJpbmdWYWx1ZUZyb21BcnJheTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZ2V0Q2hhcmFjdGVyQXJyYXlcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRDaGFyYWN0ZXJBcnJheTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwib2JqZWN0QXNzaWduXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gb2JqZWN0QXNzaWduOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZlckluaXRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBkZWZlckluaXQ7IH0pO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uICovXG5mdW5jdGlvbiBnZXRTdHJpbmdGcm9tRGF0YVZpZXcoZGF0YVZpZXcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoICYmIG9mZnNldCArIGkgPCBkYXRhVmlldy5ieXRlTGVuZ3RoOyBpKyspIHtcbiAgICBjaGFycy5wdXNoKGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIGkpKTtcbiAgfVxuXG4gIHJldHVybiBnZXRTdHJpbmdWYWx1ZUZyb21BcnJheShjaGFycyk7XG59XG5mdW5jdGlvbiBnZXRVbmljb2RlU3RyaW5nRnJvbURhdGFWaWV3KGRhdGFWaWV3LCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aCAmJiBvZmZzZXQgKyBpIDwgZGF0YVZpZXcuYnl0ZUxlbmd0aDsgaSArPSAyKSB7XG4gICAgY2hhcnMucHVzaChkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0ICsgaSkpO1xuICB9XG5cbiAgcmV0dXJuIGdldFN0cmluZ1ZhbHVlRnJvbUFycmF5KGNoYXJzKTtcbn1cbmZ1bmN0aW9uIGdldFN0cmluZ1ZhbHVlRnJvbUFycmF5KGNoYXJBcnJheSkge1xuICByZXR1cm4gY2hhckFycmF5Lm1hcChmdW5jdGlvbiAoY2hhckNvZGUpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gIH0pLmpvaW4oJycpO1xufVxuZnVuY3Rpb24gZ2V0Q2hhcmFjdGVyQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcuc3BsaXQoJycpLm1hcChmdW5jdGlvbiAoY2hhcmFjdGVyKSB7XG4gICAgcmV0dXJuIGNoYXJhY3Rlci5jaGFyQ29kZUF0KDApO1xuICB9KTtcbn1cbmZ1bmN0aW9uIG9iamVjdEFzc2lnbigpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBhcmd1bWVudHNbaV0pIHtcbiAgICAgIGFyZ3VtZW50c1swXVtwcm9wZXJ0eV0gPSBhcmd1bWVudHNbaV1bcHJvcGVydHldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhcmd1bWVudHNbMF07XG59XG5mdW5jdGlvbiBkZWZlckluaXQob2JqZWN0LCBrZXksIGluaXRpYWxpemVyKSB7XG4gIHZhciBpbml0aWFsaXplZCA9IGZhbHNlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogaW5pdGlhbGl6ZXIuYXBwbHkob2JqZWN0KSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3htcC10YWctbmFtZXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy94bXAtdGFnLW5hbWVzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShuKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSkgcmV0dXJuOyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwczovL21vemlsbGEub3JnL01QTC8yLjAvLiAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICd0aWZmOk9yaWVudGF0aW9uJzogZnVuY3Rpb24gdGlmZk9yaWVudGF0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSAnMScpIHtcbiAgICAgIHJldHVybiAnSG9yaXpvbnRhbCAobm9ybWFsKSc7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSAnMicpIHtcbiAgICAgIHJldHVybiAnTWlycm9yIGhvcml6b250YWwnO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSA9PT0gJzMnKSB7XG4gICAgICByZXR1cm4gJ1JvdGF0ZSAxODAnO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSA9PT0gJzQnKSB7XG4gICAgICByZXR1cm4gJ01pcnJvciB2ZXJ0aWNhbCc7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSAnNScpIHtcbiAgICAgIHJldHVybiAnTWlycm9yIGhvcml6b250YWwgYW5kIHJvdGF0ZSAyNzAgQ1cnO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSA9PT0gJzYnKSB7XG4gICAgICByZXR1cm4gJ1JvdGF0ZSA5MCBDVyc7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSAnNycpIHtcbiAgICAgIHJldHVybiAnTWlycm9yIGhvcml6b250YWwgYW5kIHJvdGF0ZSA5MCBDVyc7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSAnOCcpIHtcbiAgICAgIHJldHVybiAnUm90YXRlIDI3MCBDVyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICAnZXhpZjpHUFNMYXRpdHVkZSc6IGNhbGN1bGF0ZUdQU1ZhbHVlLFxuICAnZXhpZjpHUFNMb25naXR1ZGUnOiBjYWxjdWxhdGVHUFNWYWx1ZVxufSk7XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUdQU1ZhbHVlKHZhbHVlKSB7XG4gIHZhciBfdmFsdWUkc3BsaXQgPSB2YWx1ZS5zcGxpdCgnLCcpLFxuICAgICAgX3ZhbHVlJHNwbGl0MiA9IF9zbGljZWRUb0FycmF5KF92YWx1ZSRzcGxpdCwgMiksXG4gICAgICBkZWdyZWVzU3RyaW5nID0gX3ZhbHVlJHNwbGl0MlswXSxcbiAgICAgIG1pbnV0ZXNTdHJpbmcgPSBfdmFsdWUkc3BsaXQyWzFdO1xuXG4gIGlmIChkZWdyZWVzU3RyaW5nICE9PSB1bmRlZmluZWQgJiYgbWludXRlc1N0cmluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGRlZ3JlZXMgPSBwYXJzZUZsb2F0KGRlZ3JlZXNTdHJpbmcpO1xuICAgIHZhciBtaW51dGVzID0gcGFyc2VGbG9hdChtaW51dGVzU3RyaW5nKTtcbiAgICB2YXIgcmVmID0gbWludXRlc1N0cmluZy5jaGFyQXQobWludXRlc1N0cmluZy5sZW5ndGggLSAxKTtcblxuICAgIGlmICghTnVtYmVyLmlzTmFOKGRlZ3JlZXMpICYmICFOdW1iZXIuaXNOYU4obWludXRlcykpIHtcbiAgICAgIHJldHVybiAnJyArIChkZWdyZWVzICsgbWludXRlcyAvIDYwKSArIHJlZjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3htcC10YWdzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3htcC10YWdzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzLmpzICovIFwiLi9zcmMvdXRpbHMuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3htcF90YWdfbmFtZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4veG1wLXRhZy1uYW1lcy5qcyAqLyBcIi4vc3JjL3htcC10YWctbmFtZXMuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RvbV9wYXJzZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZG9tLXBhcnNlci5qcyAqLyBcIi4vc3JjL2RvbS1wYXJzZXIuanNcIik7XG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwczovL21vemlsbGEub3JnL01QTC8yLjAvLiAqL1xuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gIHJlYWQ6IHJlYWRcbn0pO1xuXG5mdW5jdGlvbiByZWFkKGRhdGFWaWV3LCBjaHVua3MpIHtcbiAgaWYgKHR5cGVvZiBkYXRhVmlldyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcmVhZFRhZ3Moe30sIGRhdGFWaWV3KTtcbiAgfVxuXG4gIHJldHVybiBleHRyYWN0Q29tcGxldGVDaHVua3MoZGF0YVZpZXcsIGNodW5rcykucmVkdWNlKHJlYWRUYWdzLCB7fSk7XG59IC8vIFRoZSBmaXJzdCBjaHVuayBpcyBhbHdheXMgdGhlIHJlZ3VsYXIgWE1QIGRvY3VtZW50LiBUaGVuIHRoZXJlIGlzIHNvbWV0aGluZ1xuLy8gY2FsbGVkIGV4dGVuZGVkIFhNUC4gVGhlIGV4dGVuZGVkIFhNUCBpcyBhbHNvIGEgc2luZ2xlIFhNUCBkb2N1bWVudCBidXQgaXRcbi8vIGNhbiBiZSBkaXZpZGVkIGludG8gbXVsdGlwbGUgY2h1bmtzIHRoYXQgbmVlZCB0byBiZSBjb21iaW5lZCBpbnRvIG9uZS5cblxuXG5mdW5jdGlvbiBleHRyYWN0Q29tcGxldGVDaHVua3MoZGF0YVZpZXcsIGNodW5rcykge1xuICBpZiAoY2h1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBjb21wbGV0ZUNodW5rcyA9IFtjb21iaW5lQ2h1bmtzKGRhdGFWaWV3LCBjaHVua3Muc2xpY2UoMCwgMSkpXTtcblxuICBpZiAoY2h1bmtzLmxlbmd0aCA+IDEpIHtcbiAgICBjb21wbGV0ZUNodW5rcy5wdXNoKGNvbWJpbmVDaHVua3MoZGF0YVZpZXcsIGNodW5rcy5zbGljZSgxKSkpO1xuICB9XG5cbiAgcmV0dXJuIGNvbXBsZXRlQ2h1bmtzO1xufVxuXG5mdW5jdGlvbiBjb21iaW5lQ2h1bmtzKGRhdGFWaWV3LCBjaHVua3MpIHtcbiAgdmFyIHRvdGFsTGVuZ3RoID0gY2h1bmtzLnJlZHVjZShmdW5jdGlvbiAoc2l6ZSwgY2h1bmspIHtcbiAgICByZXR1cm4gc2l6ZSArIGNodW5rLmxlbmd0aDtcbiAgfSwgMCk7XG4gIHZhciBjb21iaW5lZENodW5rcyA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcbiAgdmFyIG9mZnNldCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2h1bmsgPSBjaHVua3NbaV07XG4gICAgdmFyIHNsaWNlID0gZGF0YVZpZXcuYnVmZmVyLnNsaWNlKGNodW5rLmRhdGFPZmZzZXQsIGNodW5rLmRhdGFPZmZzZXQgKyBjaHVuay5sZW5ndGgpO1xuICAgIGNvbWJpbmVkQ2h1bmtzLnNldChuZXcgVWludDhBcnJheShzbGljZSksIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGNodW5rLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBuZXcgRGF0YVZpZXcoY29tYmluZWRDaHVua3MuYnVmZmVyKTtcbn1cblxuZnVuY3Rpb24gcmVhZFRhZ3ModGFncywgY2h1bmtEYXRhVmlldykge1xuICB0cnkge1xuICAgIHZhciBkb2MgPSBnZXREb2N1bWVudChjaHVua0RhdGFWaWV3KTtcbiAgICB2YXIgcmRmID0gZ2V0UkRGKGRvYyk7XG4gICAgcmV0dXJuIE9iamVjdChfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIm9iamVjdEFzc2lnblwiXSkodGFncywgcGFyc2VYTVBPYmplY3QoY29udmVydFRvT2JqZWN0KHJkZiwgdHJ1ZSkpKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdGFncztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREb2N1bWVudChjaHVua0RhdGFWaWV3KSB7XG4gIHZhciBQYXJzZXIgPSBfZG9tX3BhcnNlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXS5nZXQoKTtcblxuICBpZiAoIVBhcnNlcikge1xuICAgIGNvbnNvbGUud2FybignV2FybmluZzogRE9NUGFyc2VyIGlzIG5vdCBhdmFpbGFibGUuIEl0IGlzIG5lZWRlZCB0byBiZSBhYmxlIHRvIHBhcnNlIFhNUCB0YWdzLicpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcblxuICAgIHRocm93IG5ldyBFcnJvcigpO1xuICB9XG5cbiAgdmFyIGRvbVBhcnNlciA9IG5ldyBQYXJzZXIoKTtcbiAgdmFyIHhtbFN0cmluZyA9IHR5cGVvZiBjaHVua0RhdGFWaWV3ID09PSAnc3RyaW5nJyA/IGNodW5rRGF0YVZpZXcgOiBPYmplY3QoX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJnZXRTdHJpbmdGcm9tRGF0YVZpZXdcIl0pKGNodW5rRGF0YVZpZXcsIDAsIGNodW5rRGF0YVZpZXcuYnl0ZUxlbmd0aCk7XG4gIHZhciBkb2MgPSBkb21QYXJzZXIucGFyc2VGcm9tU3RyaW5nKHRyaW1YbWxTb3VyY2UoeG1sU3RyaW5nKSwgJ2FwcGxpY2F0aW9uL3htbCcpO1xuXG4gIGlmIChkb2MuZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lID09PSAncGFyc2VyZXJyb3InKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGRvYy5kb2N1bWVudEVsZW1lbnQudGV4dENvbnRlbnQpO1xuICB9XG5cbiAgcmV0dXJuIGRvYztcbn1cblxuZnVuY3Rpb24gdHJpbVhtbFNvdXJjZSh4bWxTb3VyY2UpIHtcbiAgcmV0dXJuIHhtbFNvdXJjZS5yZXBsYWNlKC9eLisoPFxcP3hwYWNrZXQgYmVnaW4pLywgJyQxJykucmVwbGFjZSgvKDxcXD94cGFja2V0IGVuZD1cIi4qXCJcXD8+KS4rJC8sICckMScpO1xufVxuXG5mdW5jdGlvbiBnZXRSREYobm9kZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChub2RlLmNoaWxkTm9kZXNbaV0udGFnTmFtZSA9PT0gJ3g6eG1wbWV0YScpIHtcbiAgICAgIHJldHVybiBnZXRSREYobm9kZS5jaGlsZE5vZGVzW2ldKTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5jaGlsZE5vZGVzW2ldLnRhZ05hbWUgPT09ICdyZGY6UkRGJykge1xuICAgICAgcmV0dXJuIG5vZGUuY2hpbGROb2Rlc1tpXTtcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoKTtcbn1cblxuZnVuY3Rpb24gY29udmVydFRvT2JqZWN0KG5vZGUpIHtcbiAgdmFyIGlzVG9wTm9kZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gIHZhciBjaGlsZE5vZGVzID0gZ2V0Q2hpbGROb2Rlcyhub2RlKTtcblxuICBpZiAoaGFzVGV4dE9ubHlDb250ZW50KGNoaWxkTm9kZXMpKSB7XG4gICAgaWYgKGlzVG9wTm9kZSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIHJldHVybiBnZXRUZXh0VmFsdWUoY2hpbGROb2Rlc1swXSk7XG4gIH1cblxuICByZXR1cm4gZ2V0RWxlbWVudHNGcm9tTm9kZXMoY2hpbGROb2Rlcyk7XG59XG5cbmZ1bmN0aW9uIGdldENoaWxkTm9kZXMobm9kZSkge1xuICB2YXIgZWxlbWVudHMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGVsZW1lbnRzLnB1c2gobm9kZS5jaGlsZE5vZGVzW2ldKTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50cztcbn1cblxuZnVuY3Rpb24gaGFzVGV4dE9ubHlDb250ZW50KG5vZGVzKSB7XG4gIHJldHVybiBub2Rlcy5sZW5ndGggPT09IDEgJiYgbm9kZXNbMF0ubm9kZU5hbWUgPT09ICcjdGV4dCc7XG59XG5cbmZ1bmN0aW9uIGdldFRleHRWYWx1ZShub2RlKSB7XG4gIHJldHVybiBub2RlLm5vZGVWYWx1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0RWxlbWVudHNGcm9tTm9kZXMobm9kZXMpIHtcbiAgdmFyIGVsZW1lbnRzID0ge307XG4gIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBpZiAoaXNFbGVtZW50KG5vZGUpKSB7XG4gICAgICB2YXIgbm9kZUVsZW1lbnQgPSBnZXRFbGVtZW50RnJvbU5vZGUobm9kZSk7XG5cbiAgICAgIGlmIChlbGVtZW50c1tub2RlLm5vZGVOYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShlbGVtZW50c1tub2RlLm5vZGVOYW1lXSkpIHtcbiAgICAgICAgICBlbGVtZW50c1tub2RlLm5vZGVOYW1lXSA9IFtlbGVtZW50c1tub2RlLm5vZGVOYW1lXV07XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50c1tub2RlLm5vZGVOYW1lXS5wdXNoKG5vZGVFbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnRzW25vZGUubm9kZU5hbWVdID0gbm9kZUVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGVsZW1lbnRzO1xufVxuXG5mdW5jdGlvbiBpc0VsZW1lbnQobm9kZSkge1xuICByZXR1cm4gbm9kZS5ub2RlTmFtZSAmJiBub2RlLm5vZGVOYW1lICE9PSAnI3RleHQnO1xufVxuXG5mdW5jdGlvbiBnZXRFbGVtZW50RnJvbU5vZGUobm9kZSkge1xuICByZXR1cm4ge1xuICAgIGF0dHJpYnV0ZXM6IGdldEF0dHJpYnV0ZXMobm9kZSksXG4gICAgdmFsdWU6IGNvbnZlcnRUb09iamVjdChub2RlKVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVzKGVsZW1lbnQpIHtcbiAgdmFyIGF0dHJpYnV0ZXMgPSB7fTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnQuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgIGF0dHJpYnV0ZXNbZWxlbWVudC5hdHRyaWJ1dGVzW2ldLm5vZGVOYW1lXSA9IGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoZWxlbWVudC5hdHRyaWJ1dGVzW2ldLnZhbHVlKSk7XG4gIH1cblxuICByZXR1cm4gYXR0cmlidXRlcztcbn1cblxuZnVuY3Rpb24gcGFyc2VYTVBPYmplY3QoeG1wT2JqZWN0KSB7XG4gIHZhciB0YWdzID0ge307XG5cbiAgaWYgKHR5cGVvZiB4bXBPYmplY3QgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHhtcE9iamVjdDtcbiAgfVxuXG4gIGZvciAodmFyIG5vZGVOYW1lIGluIHhtcE9iamVjdCkge1xuICAgIHZhciBub2RlcyA9IHhtcE9iamVjdFtub2RlTmFtZV07XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobm9kZXMpKSB7XG4gICAgICBub2RlcyA9IFtub2Rlc107XG4gICAgfVxuXG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgT2JqZWN0KF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wib2JqZWN0QXNzaWduXCJdKSh0YWdzLCBwYXJzZU5vZGVBdHRyaWJ1dGVzQXNUYWdzKG5vZGUuYXR0cmlidXRlcykpO1xuXG4gICAgICBpZiAoX3R5cGVvZihub2RlLnZhbHVlKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgT2JqZWN0KF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wib2JqZWN0QXNzaWduXCJdKSh0YWdzLCBwYXJzZU5vZGVDaGlsZHJlbkFzVGFncyhub2RlLnZhbHVlKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGFncztcbn1cblxuZnVuY3Rpb24gcGFyc2VOb2RlQXR0cmlidXRlc0FzVGFncyhhdHRyaWJ1dGVzKSB7XG4gIHZhciB0YWdzID0ge307XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgaWYgKGlzVGFnQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICB0YWdzW2dldExvY2FsTmFtZShuYW1lKV0gPSB7XG4gICAgICAgIHZhbHVlOiBhdHRyaWJ1dGVzW25hbWVdLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgICAgZGVzY3JpcHRpb246IGdldERlc2NyaXB0aW9uKGF0dHJpYnV0ZXNbbmFtZV0sIG5hbWUpXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YWdzO1xufVxuXG5mdW5jdGlvbiBpc1RhZ0F0dHJpYnV0ZShuYW1lKSB7XG4gIHJldHVybiBuYW1lICE9PSAncmRmOnBhcnNlVHlwZScgJiYgIWlzTmFtZXNwYWNlRGVmaW5pdGlvbihuYW1lKTtcbn1cblxuZnVuY3Rpb24gaXNOYW1lc3BhY2VEZWZpbml0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUuc3BsaXQoJzonKVswXSA9PT0gJ3htbG5zJztcbn1cblxuZnVuY3Rpb24gZ2V0TG9jYWxOYW1lKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUuc3BsaXQoJzonKVsxXTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVzY3JpcHRpb24odmFsdWUpIHtcbiAgdmFyIG5hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZ2V0RGVzY3JpcHRpb25PZkFycmF5KHZhbHVlKTtcbiAgfVxuXG4gIGlmIChfdHlwZW9mKHZhbHVlKSA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZ2V0RGVzY3JpcHRpb25PZk9iamVjdCh2YWx1ZSk7XG4gIH1cblxuICB0cnkge1xuICAgIGlmIChuYW1lICYmIHR5cGVvZiBfeG1wX3RhZ19uYW1lc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXVtuYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIF94bXBfdGFnX25hbWVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdW25hbWVdKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZSh2YWx1ZSkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZXNjcmlwdGlvbk9mQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmIChpdGVtLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBnZXREZXNjcmlwdGlvbihpdGVtLnZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0RGVzY3JpcHRpb24oaXRlbSk7XG4gIH0pLmpvaW4oJywgJyk7XG59XG5cbmZ1bmN0aW9uIGdldERlc2NyaXB0aW9uT2ZPYmplY3QodmFsdWUpIHtcbiAgdmFyIGRlc2NyaXB0aW9ucyA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGRlc2NyaXB0aW9ucy5wdXNoKFwiXCIuY29uY2F0KGdldENsZWFyVGV4dEtleShrZXkpLCBcIjogXCIpLmNvbmNhdCh2YWx1ZVtrZXldLnZhbHVlKSk7XG4gIH1cblxuICByZXR1cm4gZGVzY3JpcHRpb25zLmpvaW4oJzsgJyk7XG59XG5cbmZ1bmN0aW9uIGdldENsZWFyVGV4dEtleShrZXkpIHtcbiAgaWYgKGtleSA9PT0gJ0NpQWRyQ2l0eScpIHtcbiAgICByZXR1cm4gJ0NyZWF0b3JDaXR5JztcbiAgfVxuXG4gIGlmIChrZXkgPT09ICdDaUFkckN0cnknKSB7XG4gICAgcmV0dXJuICdDcmVhdG9yQ291bnRyeSc7XG4gIH1cblxuICBpZiAoa2V5ID09PSAnQ2lBZHJFeHRhZHInKSB7XG4gICAgcmV0dXJuICdDcmVhdG9yQWRkcmVzcyc7XG4gIH1cblxuICBpZiAoa2V5ID09PSAnQ2lBZHJQY29kZScpIHtcbiAgICByZXR1cm4gJ0NyZWF0b3JQb3N0YWxDb2RlJztcbiAgfVxuXG4gIGlmIChrZXkgPT09ICdDaUFkclJlZ2lvbicpIHtcbiAgICByZXR1cm4gJ0NyZWF0b3JSZWdpb24nO1xuICB9XG5cbiAgaWYgKGtleSA9PT0gJ0NpRW1haWxXb3JrJykge1xuICAgIHJldHVybiAnQ3JlYXRvcldvcmtFbWFpbCc7XG4gIH1cblxuICBpZiAoa2V5ID09PSAnQ2lUZWxXb3JrJykge1xuICAgIHJldHVybiAnQ3JlYXRvcldvcmtQaG9uZSc7XG4gIH1cblxuICBpZiAoa2V5ID09PSAnQ2lVcmxXb3JrJykge1xuICAgIHJldHVybiAnQ3JlYXRvcldvcmtVcmwnO1xuICB9XG5cbiAgcmV0dXJuIGtleTtcbn1cblxuZnVuY3Rpb24gcGFyc2VOb2RlQ2hpbGRyZW5Bc1RhZ3MoY2hpbGRyZW4pIHtcbiAgdmFyIHRhZ3MgPSB7fTtcblxuICBmb3IgKHZhciBuYW1lIGluIGNoaWxkcmVuKSB7XG4gICAgaWYgKCFpc05hbWVzcGFjZURlZmluaXRpb24obmFtZSkpIHtcbiAgICAgIHRhZ3NbZ2V0TG9jYWxOYW1lKG5hbWUpXSA9IHBhcnNlTm9kZUFzVGFnKGNoaWxkcmVuW25hbWVdLCBuYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFncztcbn1cblxuZnVuY3Rpb24gcGFyc2VOb2RlQXNUYWcobm9kZSwgbmFtZSkge1xuICBpZiAoaGFzTmVzdGVkU2ltcGxlUmRmRGVzY3JpcHRpb24obm9kZSkpIHtcbiAgICByZXR1cm4gcGFyc2VOb2RlQXNTaW1wbGVSZGZEZXNjcmlwdGlvbihub2RlLCBuYW1lKTtcbiAgfSBlbHNlIGlmIChoYXNOZXN0ZWRTdHJ1Y3R1cmVSZGZEZXNjcmlwdGlvbihub2RlKSkge1xuICAgIHJldHVybiBwYXJzZU5vZGVBc1N0cnVjdHVyZVJkZkRlc2NyaXB0aW9uKG5vZGUsIG5hbWUpO1xuICB9IGVsc2UgaWYgKGlzQ29tcGFjdFN0cnVjdHVyZShub2RlKSkge1xuICAgIHJldHVybiBwYXJzZU5vZGVBc0NvbXBhY3RTdHJ1Y3R1cmUobm9kZSwgbmFtZSk7XG4gIH0gZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xuICAgIHJldHVybiBwYXJzZU5vZGVBc0FycmF5KG5vZGUsIG5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlTm9kZUFzU2ltcGxlVmFsdWUobm9kZSwgbmFtZSk7XG59XG5cbmZ1bmN0aW9uIGhhc05lc3RlZFNpbXBsZVJkZkRlc2NyaXB0aW9uKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuYXR0cmlidXRlc1sncmRmOnBhcnNlVHlwZSddID09PSAnUmVzb3VyY2UnICYmIG5vZGUudmFsdWVbJ3JkZjp2YWx1ZSddICE9PSB1bmRlZmluZWQgfHwgbm9kZS52YWx1ZVsncmRmOkRlc2NyaXB0aW9uJ10gIT09IHVuZGVmaW5lZCAmJiBub2RlLnZhbHVlWydyZGY6RGVzY3JpcHRpb24nXS52YWx1ZVsncmRmOnZhbHVlJ10gIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gcGFyc2VOb2RlQXNTaW1wbGVSZGZEZXNjcmlwdGlvbihub2RlLCBuYW1lKSB7XG4gIHZhciBhdHRyaWJ1dGVzID0gcGFyc2VOb2RlQXR0cmlidXRlcyhub2RlKTtcblxuICBpZiAobm9kZS52YWx1ZVsncmRmOkRlc2NyaXB0aW9uJ10gIT09IHVuZGVmaW5lZCkge1xuICAgIG5vZGUgPSBub2RlLnZhbHVlWydyZGY6RGVzY3JpcHRpb24nXTtcbiAgfVxuXG4gIE9iamVjdChfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIm9iamVjdEFzc2lnblwiXSkoYXR0cmlidXRlcywgcGFyc2VOb2RlQXR0cmlidXRlcyhub2RlKSwgcGFyc2VOb2RlQ2hpbGRyZW5Bc0F0dHJpYnV0ZXMobm9kZSkpO1xuICB2YXIgdmFsdWUgPSBwYXJzZVJkZlZhbHVlKG5vZGUpO1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzLFxuICAgIGRlc2NyaXB0aW9uOiBnZXREZXNjcmlwdGlvbih2YWx1ZSwgbmFtZSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VOb2RlQXR0cmlidXRlcyhub2RlKSB7XG4gIHZhciBhdHRyaWJ1dGVzID0ge307XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBub2RlLmF0dHJpYnV0ZXMpIHtcbiAgICBpZiAobmFtZSAhPT0gJ3JkZjpwYXJzZVR5cGUnICYmIG5hbWUgIT09ICdyZGY6cmVzb3VyY2UnICYmICFpc05hbWVzcGFjZURlZmluaXRpb24obmFtZSkpIHtcbiAgICAgIGF0dHJpYnV0ZXNbZ2V0TG9jYWxOYW1lKG5hbWUpXSA9IG5vZGUuYXR0cmlidXRlc1tuYW1lXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXR0cmlidXRlcztcbn1cblxuZnVuY3Rpb24gcGFyc2VOb2RlQ2hpbGRyZW5Bc0F0dHJpYnV0ZXMobm9kZSkge1xuICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuXG4gIGZvciAodmFyIG5hbWUgaW4gbm9kZS52YWx1ZSkge1xuICAgIGlmIChuYW1lICE9PSAncmRmOnZhbHVlJyAmJiAhaXNOYW1lc3BhY2VEZWZpbml0aW9uKG5hbWUpKSB7XG4gICAgICBhdHRyaWJ1dGVzW2dldExvY2FsTmFtZShuYW1lKV0gPSBub2RlLnZhbHVlW25hbWVdLnZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhdHRyaWJ1dGVzO1xufVxuXG5mdW5jdGlvbiBwYXJzZVJkZlZhbHVlKG5vZGUpIHtcbiAgcmV0dXJuIGdldFVSSVZhbHVlKG5vZGUudmFsdWVbJ3JkZjp2YWx1ZSddKSB8fCBub2RlLnZhbHVlWydyZGY6dmFsdWUnXS52YWx1ZTtcbn1cblxuZnVuY3Rpb24gaGFzTmVzdGVkU3RydWN0dXJlUmRmRGVzY3JpcHRpb24obm9kZSkge1xuICByZXR1cm4gbm9kZS5hdHRyaWJ1dGVzWydyZGY6cGFyc2VUeXBlJ10gPT09ICdSZXNvdXJjZScgfHwgbm9kZS52YWx1ZVsncmRmOkRlc2NyaXB0aW9uJ10gIT09IHVuZGVmaW5lZCAmJiBub2RlLnZhbHVlWydyZGY6RGVzY3JpcHRpb24nXS52YWx1ZVsncmRmOnZhbHVlJ10gPT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gcGFyc2VOb2RlQXNTdHJ1Y3R1cmVSZGZEZXNjcmlwdGlvbihub2RlLCBuYW1lKSB7XG4gIHZhciB0YWcgPSB7XG4gICAgdmFsdWU6IHt9LFxuICAgIGF0dHJpYnV0ZXM6IHt9XG4gIH07XG5cbiAgaWYgKG5vZGUudmFsdWVbJ3JkZjpEZXNjcmlwdGlvbiddICE9PSB1bmRlZmluZWQpIHtcbiAgICBPYmplY3QoX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJvYmplY3RBc3NpZ25cIl0pKHRhZy52YWx1ZSwgcGFyc2VOb2RlQXR0cmlidXRlc0FzVGFncyhub2RlLnZhbHVlWydyZGY6RGVzY3JpcHRpb24nXS5hdHRyaWJ1dGVzKSk7XG4gICAgT2JqZWN0KF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wib2JqZWN0QXNzaWduXCJdKSh0YWcuYXR0cmlidXRlcywgcGFyc2VOb2RlQXR0cmlidXRlcyhub2RlKSk7XG4gICAgbm9kZSA9IG5vZGUudmFsdWVbJ3JkZjpEZXNjcmlwdGlvbiddO1xuICB9XG5cbiAgT2JqZWN0KF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wib2JqZWN0QXNzaWduXCJdKSh0YWcudmFsdWUsIHBhcnNlTm9kZUNoaWxkcmVuQXNUYWdzKG5vZGUudmFsdWUpKTtcbiAgdGFnLmRlc2NyaXB0aW9uID0gZ2V0RGVzY3JpcHRpb24odGFnLnZhbHVlLCBuYW1lKTtcbiAgcmV0dXJuIHRhZztcbn1cblxuZnVuY3Rpb24gaXNDb21wYWN0U3RydWN0dXJlKG5vZGUpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG5vZGUudmFsdWUpLmxlbmd0aCA9PT0gMCAmJiBub2RlLmF0dHJpYnV0ZXNbJ3JkZjpyZXNvdXJjZSddID09PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTm9kZUFzQ29tcGFjdFN0cnVjdHVyZShub2RlLCBuYW1lKSB7XG4gIHZhciB2YWx1ZSA9IHBhcnNlTm9kZUF0dHJpYnV0ZXNBc1RhZ3Mobm9kZS5hdHRyaWJ1dGVzKTtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgYXR0cmlidXRlczoge30sXG4gICAgZGVzY3JpcHRpb246IGdldERlc2NyaXB0aW9uKHZhbHVlLCBuYW1lKVxuICB9O1xufVxuXG5mdW5jdGlvbiBpc0FycmF5KG5vZGUpIHtcbiAgcmV0dXJuIGdldEFycmF5Q2hpbGQobm9kZS52YWx1ZSkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZ2V0QXJyYXlDaGlsZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWVbJ3JkZjpCYWcnXSB8fCB2YWx1ZVsncmRmOlNlcSddIHx8IHZhbHVlWydyZGY6QWx0J107XG59XG5cbmZ1bmN0aW9uIHBhcnNlTm9kZUFzQXJyYXkobm9kZSwgbmFtZSkge1xuICB2YXIgaXRlbXMgPSBnZXRBcnJheUNoaWxkKG5vZGUudmFsdWUpLnZhbHVlWydyZGY6bGknXTtcbiAgdmFyIGF0dHJpYnV0ZXMgPSBwYXJzZU5vZGVBdHRyaWJ1dGVzKG5vZGUpO1xuICB2YXIgdmFsdWUgPSBbXTtcblxuICBpZiAoaXRlbXMgPT09IHVuZGVmaW5lZCkge1xuICAgIGl0ZW1zID0gW107XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgaXRlbXMgPSBbaXRlbXNdO1xuICB9XG5cbiAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgIHZhbHVlLnB1c2gocGFyc2VBcnJheVZhbHVlKGl0ZW0pKTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMsXG4gICAgZGVzY3JpcHRpb246IGdldERlc2NyaXB0aW9uKHZhbHVlLCBuYW1lKVxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZUFycmF5VmFsdWUoaXRlbSkge1xuICBpZiAoaGFzTmVzdGVkU2ltcGxlUmRmRGVzY3JpcHRpb24oaXRlbSkpIHtcbiAgICByZXR1cm4gcGFyc2VOb2RlQXNTaW1wbGVSZGZEZXNjcmlwdGlvbihpdGVtKTtcbiAgfVxuXG4gIGlmIChoYXNOZXN0ZWRBcnJheVZhbHVlKGl0ZW0pKSB7XG4gICAgcmV0dXJuIHBhcnNlTm9kZUNoaWxkcmVuQXNUYWdzKGl0ZW0udmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogaXRlbS52YWx1ZSxcbiAgICBhdHRyaWJ1dGVzOiBwYXJzZU5vZGVBdHRyaWJ1dGVzKGl0ZW0pLFxuICAgIGRlc2NyaXB0aW9uOiBnZXREZXNjcmlwdGlvbihpdGVtLnZhbHVlKVxuICB9O1xufVxuXG5mdW5jdGlvbiBoYXNOZXN0ZWRBcnJheVZhbHVlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuYXR0cmlidXRlc1sncmRmOnBhcnNlVHlwZSddID09PSAnUmVzb3VyY2UnO1xufVxuXG5mdW5jdGlvbiBwYXJzZU5vZGVBc1NpbXBsZVZhbHVlKG5vZGUsIG5hbWUpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VVJJVmFsdWUobm9kZSkgfHwgcGFyc2VYTVBPYmplY3Qobm9kZS52YWx1ZSk7XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGF0dHJpYnV0ZXM6IHBhcnNlTm9kZUF0dHJpYnV0ZXMobm9kZSksXG4gICAgZGVzY3JpcHRpb246IGdldERlc2NyaXB0aW9uKHZhbHVlLCBuYW1lKVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRVUklWYWx1ZShub2RlKSB7XG4gIHJldHVybiBub2RlLmF0dHJpYnV0ZXMgJiYgbm9kZS5hdHRyaWJ1dGVzWydyZGY6cmVzb3VyY2UnXTtcbn1cblxuLyoqKi8gfSlcblxuLyoqKioqKi8gfSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4aWYtcmVhZGVyLmpzLm1hcCIsIi8qXG4gIENvcHlyaWdodCAoYykgMjAwOCwgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWRcbiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgXG4gIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAgbWV0OlxuXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCBcbiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICBcbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgXG4gICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAgXG4gICogTmVpdGhlciB0aGUgbmFtZSBvZiBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZCBub3IgdGhlIG5hbWVzIG9mIGl0cyBcbiAgICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSBcbiAgICB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBU1xuICBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgT1dORVIgT1IgXG4gIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLFxuICBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4gIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuICBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG4vKlxuSlBFRyBlbmNvZGVyIHBvcnRlZCB0byBKYXZhU2NyaXB0IGFuZCBvcHRpbWl6ZWQgYnkgQW5kcmVhcyBSaXR0ZXIsIHd3dy5ieXRlc3Ryb20uZXUsIDExLzIwMDlcblxuQmFzaWMgR1VJIGJsb2NraW5nIGpwZWcgZW5jb2RlclxuKi9cblxuZnVuY3Rpb24gSlBFR0VuY29kZXIocXVhbGl0eSkge1xuXHR2YXIgZmZsb29yID0gTWF0aC5mbG9vcjtcblx0dmFyIFlUYWJsZSA9IG5ldyBBcnJheSg2NCk7XG5cdHZhciBVVlRhYmxlID0gbmV3IEFycmF5KDY0KTtcblx0dmFyIGZkdGJsX1kgPSBuZXcgQXJyYXkoNjQpO1xuXHR2YXIgZmR0YmxfVVYgPSBuZXcgQXJyYXkoNjQpO1xuXHR2YXIgWURDX0hUO1xuXHR2YXIgVVZEQ19IVDtcblx0dmFyIFlBQ19IVDtcblx0dmFyIFVWQUNfSFQ7XG5cblx0dmFyIGJpdGNvZGUgPSBuZXcgQXJyYXkoNjU1MzUpO1xuXHR2YXIgY2F0ZWdvcnkgPSBuZXcgQXJyYXkoNjU1MzUpO1xuXHR2YXIgb3V0cHV0ZkRDVFF1YW50ID0gbmV3IEFycmF5KDY0KTtcblx0dmFyIERVID0gbmV3IEFycmF5KDY0KTtcblx0dmFyIGJ5dGVvdXQgPSBbXTtcblx0dmFyIGJ5dGVuZXcgPSAwO1xuXHR2YXIgYnl0ZXBvcyA9IDc7XG5cblx0dmFyIFlEVSA9IG5ldyBBcnJheSg2NCk7XG5cdHZhciBVRFUgPSBuZXcgQXJyYXkoNjQpO1xuXHR2YXIgVkRVID0gbmV3IEFycmF5KDY0KTtcblx0dmFyIGNsdCA9IG5ldyBBcnJheSgyNTYpO1xuXHR2YXIgUkdCX1lVVl9UQUJMRSA9IG5ldyBBcnJheSgyMDQ4KTtcblx0dmFyIGN1cnJlbnRRdWFsaXR5O1xuXG5cdHZhciBaaWdaYWcgPSBbXG5cdFx0MCwgMSwgNSwgNiwgMTQsIDE1LCAyNywgMjgsXG5cdFx0MiwgNCwgNywgMTMsIDE2LCAyNiwgMjksIDQyLFxuXHRcdDMsIDgsIDEyLCAxNywgMjUsIDMwLCA0MSwgNDMsXG5cdFx0OSwgMTEsIDE4LCAyNCwgMzEsIDQwLCA0NCwgNTMsXG5cdFx0MTAsIDE5LCAyMywgMzIsIDM5LCA0NSwgNTIsIDU0LFxuXHRcdDIwLCAyMiwgMzMsIDM4LCA0NiwgNTEsIDU1LCA2MCxcblx0XHQyMSwgMzQsIDM3LCA0NywgNTAsIDU2LCA1OSwgNjEsXG5cdFx0MzUsIDM2LCA0OCwgNDksIDU3LCA1OCwgNjIsIDYzXG5cdF07XG5cblx0dmFyIHN0ZF9kY19sdW1pbmFuY2VfbnJjb2RlcyA9IFswLCAwLCAxLCA1LCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTtcblx0dmFyIHN0ZF9kY19sdW1pbmFuY2VfdmFsdWVzID0gWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMV07XG5cdHZhciBzdGRfYWNfbHVtaW5hbmNlX25yY29kZXMgPSBbMCwgMCwgMiwgMSwgMywgMywgMiwgNCwgMywgNSwgNSwgNCwgNCwgMCwgMCwgMSwgMHg3ZF07XG5cdHZhciBzdGRfYWNfbHVtaW5hbmNlX3ZhbHVlcyA9IFtcblx0XHQweDAxLCAweDAyLCAweDAzLCAweDAwLCAweDA0LCAweDExLCAweDA1LCAweDEyLFxuXHRcdDB4MjEsIDB4MzEsIDB4NDEsIDB4MDYsIDB4MTMsIDB4NTEsIDB4NjEsIDB4MDcsXG5cdFx0MHgyMiwgMHg3MSwgMHgxNCwgMHgzMiwgMHg4MSwgMHg5MSwgMHhhMSwgMHgwOCxcblx0XHQweDIzLCAweDQyLCAweGIxLCAweGMxLCAweDE1LCAweDUyLCAweGQxLCAweGYwLFxuXHRcdDB4MjQsIDB4MzMsIDB4NjIsIDB4NzIsIDB4ODIsIDB4MDksIDB4MGEsIDB4MTYsXG5cdFx0MHgxNywgMHgxOCwgMHgxOSwgMHgxYSwgMHgyNSwgMHgyNiwgMHgyNywgMHgyOCxcblx0XHQweDI5LCAweDJhLCAweDM0LCAweDM1LCAweDM2LCAweDM3LCAweDM4LCAweDM5LFxuXHRcdDB4M2EsIDB4NDMsIDB4NDQsIDB4NDUsIDB4NDYsIDB4NDcsIDB4NDgsIDB4NDksXG5cdFx0MHg0YSwgMHg1MywgMHg1NCwgMHg1NSwgMHg1NiwgMHg1NywgMHg1OCwgMHg1OSxcblx0XHQweDVhLCAweDYzLCAweDY0LCAweDY1LCAweDY2LCAweDY3LCAweDY4LCAweDY5LFxuXHRcdDB4NmEsIDB4NzMsIDB4NzQsIDB4NzUsIDB4NzYsIDB4NzcsIDB4NzgsIDB4NzksXG5cdFx0MHg3YSwgMHg4MywgMHg4NCwgMHg4NSwgMHg4NiwgMHg4NywgMHg4OCwgMHg4OSxcblx0XHQweDhhLCAweDkyLCAweDkzLCAweDk0LCAweDk1LCAweDk2LCAweDk3LCAweDk4LFxuXHRcdDB4OTksIDB4OWEsIDB4YTIsIDB4YTMsIDB4YTQsIDB4YTUsIDB4YTYsIDB4YTcsXG5cdFx0MHhhOCwgMHhhOSwgMHhhYSwgMHhiMiwgMHhiMywgMHhiNCwgMHhiNSwgMHhiNixcblx0XHQweGI3LCAweGI4LCAweGI5LCAweGJhLCAweGMyLCAweGMzLCAweGM0LCAweGM1LFxuXHRcdDB4YzYsIDB4YzcsIDB4YzgsIDB4YzksIDB4Y2EsIDB4ZDIsIDB4ZDMsIDB4ZDQsXG5cdFx0MHhkNSwgMHhkNiwgMHhkNywgMHhkOCwgMHhkOSwgMHhkYSwgMHhlMSwgMHhlMixcblx0XHQweGUzLCAweGU0LCAweGU1LCAweGU2LCAweGU3LCAweGU4LCAweGU5LCAweGVhLFxuXHRcdDB4ZjEsIDB4ZjIsIDB4ZjMsIDB4ZjQsIDB4ZjUsIDB4ZjYsIDB4ZjcsIDB4ZjgsXG5cdFx0MHhmOSwgMHhmYVxuXHRdO1xuXG5cdHZhciBzdGRfZGNfY2hyb21pbmFuY2VfbnJjb2RlcyA9IFswLCAwLCAzLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAwLCAwLCAwXTtcblx0dmFyIHN0ZF9kY19jaHJvbWluYW5jZV92YWx1ZXMgPSBbMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExXTtcblx0dmFyIHN0ZF9hY19jaHJvbWluYW5jZV9ucmNvZGVzID0gWzAsIDAsIDIsIDEsIDIsIDQsIDQsIDMsIDQsIDcsIDUsIDQsIDQsIDAsIDEsIDIsIDB4NzddO1xuXHR2YXIgc3RkX2FjX2Nocm9taW5hbmNlX3ZhbHVlcyA9IFtcblx0XHQweDAwLCAweDAxLCAweDAyLCAweDAzLCAweDExLCAweDA0LCAweDA1LCAweDIxLFxuXHRcdDB4MzEsIDB4MDYsIDB4MTIsIDB4NDEsIDB4NTEsIDB4MDcsIDB4NjEsIDB4NzEsXG5cdFx0MHgxMywgMHgyMiwgMHgzMiwgMHg4MSwgMHgwOCwgMHgxNCwgMHg0MiwgMHg5MSxcblx0XHQweGExLCAweGIxLCAweGMxLCAweDA5LCAweDIzLCAweDMzLCAweDUyLCAweGYwLFxuXHRcdDB4MTUsIDB4NjIsIDB4NzIsIDB4ZDEsIDB4MGEsIDB4MTYsIDB4MjQsIDB4MzQsXG5cdFx0MHhlMSwgMHgyNSwgMHhmMSwgMHgxNywgMHgxOCwgMHgxOSwgMHgxYSwgMHgyNixcblx0XHQweDI3LCAweDI4LCAweDI5LCAweDJhLCAweDM1LCAweDM2LCAweDM3LCAweDM4LFxuXHRcdDB4MzksIDB4M2EsIDB4NDMsIDB4NDQsIDB4NDUsIDB4NDYsIDB4NDcsIDB4NDgsXG5cdFx0MHg0OSwgMHg0YSwgMHg1MywgMHg1NCwgMHg1NSwgMHg1NiwgMHg1NywgMHg1OCxcblx0XHQweDU5LCAweDVhLCAweDYzLCAweDY0LCAweDY1LCAweDY2LCAweDY3LCAweDY4LFxuXHRcdDB4NjksIDB4NmEsIDB4NzMsIDB4NzQsIDB4NzUsIDB4NzYsIDB4NzcsIDB4NzgsXG5cdFx0MHg3OSwgMHg3YSwgMHg4MiwgMHg4MywgMHg4NCwgMHg4NSwgMHg4NiwgMHg4Nyxcblx0XHQweDg4LCAweDg5LCAweDhhLCAweDkyLCAweDkzLCAweDk0LCAweDk1LCAweDk2LFxuXHRcdDB4OTcsIDB4OTgsIDB4OTksIDB4OWEsIDB4YTIsIDB4YTMsIDB4YTQsIDB4YTUsXG5cdFx0MHhhNiwgMHhhNywgMHhhOCwgMHhhOSwgMHhhYSwgMHhiMiwgMHhiMywgMHhiNCxcblx0XHQweGI1LCAweGI2LCAweGI3LCAweGI4LCAweGI5LCAweGJhLCAweGMyLCAweGMzLFxuXHRcdDB4YzQsIDB4YzUsIDB4YzYsIDB4YzcsIDB4YzgsIDB4YzksIDB4Y2EsIDB4ZDIsXG5cdFx0MHhkMywgMHhkNCwgMHhkNSwgMHhkNiwgMHhkNywgMHhkOCwgMHhkOSwgMHhkYSxcblx0XHQweGUyLCAweGUzLCAweGU0LCAweGU1LCAweGU2LCAweGU3LCAweGU4LCAweGU5LFxuXHRcdDB4ZWEsIDB4ZjIsIDB4ZjMsIDB4ZjQsIDB4ZjUsIDB4ZjYsIDB4ZjcsIDB4ZjgsXG5cdFx0MHhmOSwgMHhmYVxuXHRdO1xuXG5cdGZ1bmN0aW9uIGluaXRRdWFudFRhYmxlcyhzZikge1xuXHRcdHZhciBZUVQgPSBbXG5cdFx0XHQxNiwgMTEsIDEwLCAxNiwgMjQsIDQwLCA1MSwgNjEsXG5cdFx0XHQxMiwgMTIsIDE0LCAxOSwgMjYsIDU4LCA2MCwgNTUsXG5cdFx0XHQxNCwgMTMsIDE2LCAyNCwgNDAsIDU3LCA2OSwgNTYsXG5cdFx0XHQxNCwgMTcsIDIyLCAyOSwgNTEsIDg3LCA4MCwgNjIsXG5cdFx0XHQxOCwgMjIsIDM3LCA1NiwgNjgsIDEwOSwgMTAzLCA3Nyxcblx0XHRcdDI0LCAzNSwgNTUsIDY0LCA4MSwgMTA0LCAxMTMsIDkyLFxuXHRcdFx0NDksIDY0LCA3OCwgODcsIDEwMywgMTIxLCAxMjAsIDEwMSxcblx0XHRcdDcyLCA5MiwgOTUsIDk4LCAxMTIsIDEwMCwgMTAzLCA5OVxuXHRcdF07XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDY0OyBpKyspIHtcblx0XHRcdHZhciB0ID0gZmZsb29yKChZUVRbaV0gKiBzZiArIDUwKSAvIDEwMCk7XG5cdFx0XHR0ID0gTWF0aC5taW4oTWF0aC5tYXgodCwgMSksIDI1NSk7XG5cdFx0XHRZVGFibGVbWmlnWmFnW2ldXSA9IHQ7XG5cdFx0fVxuXHRcdHZhciBVVlFUID0gW1xuXHRcdFx0MTcsIDE4LCAyNCwgNDcsIDk5LCA5OSwgOTksIDk5LFxuXHRcdFx0MTgsIDIxLCAyNiwgNjYsIDk5LCA5OSwgOTksIDk5LFxuXHRcdFx0MjQsIDI2LCA1NiwgOTksIDk5LCA5OSwgOTksIDk5LFxuXHRcdFx0NDcsIDY2LCA5OSwgOTksIDk5LCA5OSwgOTksIDk5LFxuXHRcdFx0OTksIDk5LCA5OSwgOTksIDk5LCA5OSwgOTksIDk5LFxuXHRcdFx0OTksIDk5LCA5OSwgOTksIDk5LCA5OSwgOTksIDk5LFxuXHRcdFx0OTksIDk5LCA5OSwgOTksIDk5LCA5OSwgOTksIDk5LFxuXHRcdFx0OTksIDk5LCA5OSwgOTksIDk5LCA5OSwgOTksIDk5XG5cdFx0XTtcblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IDY0OyBqKyspIHtcblx0XHRcdHZhciB1ID0gZmZsb29yKChVVlFUW2pdICogc2YgKyA1MCkgLyAxMDApO1xuXHRcdFx0dSA9IE1hdGgubWluKE1hdGgubWF4KHUsIDEpLCAyNTUpO1xuXHRcdFx0VVZUYWJsZVtaaWdaYWdbal1dID0gdTtcblx0XHR9XG5cdFx0dmFyIGFhc2YgPSBbXG5cdFx0XHQxLjAsIDEuMzg3MDM5ODQ1LCAxLjMwNjU2Mjk2NSwgMS4xNzU4NzU2MDIsXG5cdFx0XHQxLjAsIDAuNzg1Njk0OTU4LCAwLjU0MTE5NjEwMCwgMC4yNzU4OTkzNzlcblx0XHRdO1xuXHRcdHZhciBrID0gMDtcblx0XHRmb3IgKHZhciByb3cgPSAwOyByb3cgPCA4OyByb3crKykge1xuXHRcdFx0Zm9yICh2YXIgY29sID0gMDsgY29sIDwgODsgY29sKyspIHtcblx0XHRcdFx0ZmR0YmxfWVtrXSA9ICgxLjAgLyAoWVRhYmxlW1ppZ1phZ1trXV0gKiBhYXNmW3Jvd10gKiBhYXNmW2NvbF0gKiA4LjApKTtcblx0XHRcdFx0ZmR0YmxfVVZba10gPSAoMS4wIC8gKFVWVGFibGVbWmlnWmFnW2tdXSAqIGFhc2Zbcm93XSAqIGFhc2ZbY29sXSAqIDguMCkpO1xuXHRcdFx0XHRrKys7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gY29tcHV0ZUh1ZmZtYW5UYmwobnJjb2Rlcywgc3RkX3RhYmxlKSB7XG5cdFx0dmFyIGNvZGV2YWx1ZSA9IDA7XG5cdFx0dmFyIHBvc19pbl90YWJsZSA9IDA7XG5cdFx0dmFyIEhUID0gbmV3IEFycmF5KCk7XG5cdFx0Zm9yICh2YXIgayA9IDE7IGsgPD0gMTY7IGsrKykge1xuXHRcdFx0Zm9yICh2YXIgaiA9IDE7IGogPD0gbnJjb2Rlc1trXTsgaisrKSB7XG5cdFx0XHRcdEhUW3N0ZF90YWJsZVtwb3NfaW5fdGFibGVdXSA9IFtdO1xuXHRcdFx0XHRIVFtzdGRfdGFibGVbcG9zX2luX3RhYmxlXV1bMF0gPSBjb2RldmFsdWU7XG5cdFx0XHRcdEhUW3N0ZF90YWJsZVtwb3NfaW5fdGFibGVdXVsxXSA9IGs7XG5cdFx0XHRcdHBvc19pbl90YWJsZSsrO1xuXHRcdFx0XHRjb2RldmFsdWUrKztcblx0XHRcdH1cblx0XHRcdGNvZGV2YWx1ZSAqPSAyO1xuXHRcdH1cblx0XHRyZXR1cm4gSFQ7XG5cdH1cblxuXHRmdW5jdGlvbiBpbml0SHVmZm1hblRibCgpIHtcblx0XHRZRENfSFQgPSBjb21wdXRlSHVmZm1hblRibChzdGRfZGNfbHVtaW5hbmNlX25yY29kZXMsIHN0ZF9kY19sdW1pbmFuY2VfdmFsdWVzKTtcblx0XHRVVkRDX0hUID0gY29tcHV0ZUh1ZmZtYW5UYmwoc3RkX2RjX2Nocm9taW5hbmNlX25yY29kZXMsIHN0ZF9kY19jaHJvbWluYW5jZV92YWx1ZXMpO1xuXHRcdFlBQ19IVCA9IGNvbXB1dGVIdWZmbWFuVGJsKHN0ZF9hY19sdW1pbmFuY2VfbnJjb2Rlcywgc3RkX2FjX2x1bWluYW5jZV92YWx1ZXMpO1xuXHRcdFVWQUNfSFQgPSBjb21wdXRlSHVmZm1hblRibChzdGRfYWNfY2hyb21pbmFuY2VfbnJjb2Rlcywgc3RkX2FjX2Nocm9taW5hbmNlX3ZhbHVlcyk7XG5cdH1cblxuXHRmdW5jdGlvbiBpbml0Q2F0ZWdvcnlOdW1iZXIoKSB7XG5cdFx0dmFyIG5ybG93ZXIgPSAxO1xuXHRcdHZhciBucnVwcGVyID0gMjtcblx0XHRmb3IgKHZhciBjYXQgPSAxOyBjYXQgPD0gMTU7IGNhdCsrKSB7XG5cdFx0XHQvL1Bvc2l0aXZlIG51bWJlcnNcblx0XHRcdGZvciAodmFyIG5yID0gbnJsb3dlcjsgbnIgPCBucnVwcGVyOyBucisrKSB7XG5cdFx0XHRcdGNhdGVnb3J5WzMyNzY3ICsgbnJdID0gY2F0O1xuXHRcdFx0XHRiaXRjb2RlWzMyNzY3ICsgbnJdID0gW107XG5cdFx0XHRcdGJpdGNvZGVbMzI3NjcgKyBucl1bMV0gPSBjYXQ7XG5cdFx0XHRcdGJpdGNvZGVbMzI3NjcgKyBucl1bMF0gPSBucjtcblx0XHRcdH1cblx0XHRcdC8vTmVnYXRpdmUgbnVtYmVyc1xuXHRcdFx0Zm9yICh2YXIgbnJuZWcgPSAtKG5ydXBwZXIgLSAxKTsgbnJuZWcgPD0gLW5ybG93ZXI7IG5ybmVnKyspIHtcblx0XHRcdFx0Y2F0ZWdvcnlbMzI3NjcgKyBucm5lZ10gPSBjYXQ7XG5cdFx0XHRcdGJpdGNvZGVbMzI3NjcgKyBucm5lZ10gPSBbXTtcblx0XHRcdFx0Yml0Y29kZVszMjc2NyArIG5ybmVnXVsxXSA9IGNhdDtcblx0XHRcdFx0Yml0Y29kZVszMjc2NyArIG5ybmVnXVswXSA9IG5ydXBwZXIgLSAxICsgbnJuZWc7XG5cdFx0XHR9XG5cdFx0XHRucmxvd2VyIDw8PSAxO1xuXHRcdFx0bnJ1cHBlciA8PD0gMTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBpbml0UkdCWVVWVGFibGUoKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuXHRcdFx0UkdCX1lVVl9UQUJMRVtpXSA9IDE5NTk1ICogaTtcblx0XHRcdFJHQl9ZVVZfVEFCTEVbKGkgKyAyNTYpID4+IDBdID0gMzg0NzAgKiBpO1xuXHRcdFx0UkdCX1lVVl9UQUJMRVsoaSArIDUxMikgPj4gMF0gPSA3NDcxICogaSArIDB4ODAwMDtcblx0XHRcdFJHQl9ZVVZfVEFCTEVbKGkgKyA3NjgpID4+IDBdID0gLTExMDU5ICogaTtcblx0XHRcdFJHQl9ZVVZfVEFCTEVbKGkgKyAxMDI0KSA+PiAwXSA9IC0yMTcwOSAqIGk7XG5cdFx0XHRSR0JfWVVWX1RBQkxFWyhpICsgMTI4MCkgPj4gMF0gPSAzMjc2OCAqIGkgKyAweDgwN0ZGRjtcblx0XHRcdFJHQl9ZVVZfVEFCTEVbKGkgKyAxNTM2KSA+PiAwXSA9IC0yNzQzOSAqIGk7XG5cdFx0XHRSR0JfWVVWX1RBQkxFWyhpICsgMTc5MikgPj4gMF0gPSAtIDUzMjkgKiBpO1xuXHRcdH1cblx0fVxuXG5cdC8vIElPIGZ1bmN0aW9uc1xuXHRmdW5jdGlvbiB3cml0ZUJpdHMoYnMpIHtcblx0XHR2YXIgdmFsdWUgPSBic1swXTtcblx0XHR2YXIgcG9zdmFsID0gYnNbMV0gLSAxO1xuXHRcdHdoaWxlIChwb3N2YWwgPj0gMCkge1xuXHRcdFx0aWYgKHZhbHVlICYgKDEgPDwgcG9zdmFsKSkge1xuXHRcdFx0XHRieXRlbmV3IHw9ICgxIDw8IGJ5dGVwb3MpO1xuXHRcdFx0fVxuXHRcdFx0cG9zdmFsLS07XG5cdFx0XHRieXRlcG9zLS07XG5cdFx0XHRpZiAoYnl0ZXBvcyA8IDApIHtcblx0XHRcdFx0aWYgKGJ5dGVuZXcgPT0gMHhGRikge1xuXHRcdFx0XHRcdHdyaXRlQnl0ZSgweEZGKTtcblx0XHRcdFx0XHR3cml0ZUJ5dGUoMCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0d3JpdGVCeXRlKGJ5dGVuZXcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJ5dGVwb3MgPSA3O1xuXHRcdFx0XHRieXRlbmV3ID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiB3cml0ZUJ5dGUodmFsdWUpIHtcblx0XHQvL2J5dGVvdXQucHVzaChjbHRbdmFsdWVdKTsgLy8gd3JpdGUgY2hhciBkaXJlY3RseSBpbnN0ZWFkIG9mIGNvbnZlcnRpbmcgbGF0ZXJcblx0XHRieXRlb3V0LnB1c2godmFsdWUpO1xuXHR9XG5cblx0ZnVuY3Rpb24gd3JpdGVXb3JkKHZhbHVlKSB7XG5cdFx0d3JpdGVCeXRlKCh2YWx1ZSA+PiA4KSAmIDB4RkYpO1xuXHRcdHdyaXRlQnl0ZSgodmFsdWUpICYgMHhGRik7XG5cdH1cblxuXHQvLyBEQ1QgJiBxdWFudGl6YXRpb24gY29yZVxuXHRmdW5jdGlvbiBmRENUUXVhbnQoZGF0YSwgZmR0YmwpIHtcblx0XHR2YXIgZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3O1xuXHRcdC8qIFBhc3MgMTogcHJvY2VzcyByb3dzLiAqL1xuXHRcdHZhciBkYXRhT2ZmID0gMDtcblx0XHR2YXIgaTtcblx0XHR2YXIgSTggPSA4O1xuXHRcdHZhciBJNjQgPSA2NDtcblx0XHRmb3IgKGkgPSAwOyBpIDwgSTg7ICsraSkge1xuXHRcdFx0ZDAgPSBkYXRhW2RhdGFPZmZdO1xuXHRcdFx0ZDEgPSBkYXRhW2RhdGFPZmYgKyAxXTtcblx0XHRcdGQyID0gZGF0YVtkYXRhT2ZmICsgMl07XG5cdFx0XHRkMyA9IGRhdGFbZGF0YU9mZiArIDNdO1xuXHRcdFx0ZDQgPSBkYXRhW2RhdGFPZmYgKyA0XTtcblx0XHRcdGQ1ID0gZGF0YVtkYXRhT2ZmICsgNV07XG5cdFx0XHRkNiA9IGRhdGFbZGF0YU9mZiArIDZdO1xuXHRcdFx0ZDcgPSBkYXRhW2RhdGFPZmYgKyA3XTtcblxuXHRcdFx0dmFyIHRtcDAgPSBkMCArIGQ3O1xuXHRcdFx0dmFyIHRtcDcgPSBkMCAtIGQ3O1xuXHRcdFx0dmFyIHRtcDEgPSBkMSArIGQ2O1xuXHRcdFx0dmFyIHRtcDYgPSBkMSAtIGQ2O1xuXHRcdFx0dmFyIHRtcDIgPSBkMiArIGQ1O1xuXHRcdFx0dmFyIHRtcDUgPSBkMiAtIGQ1O1xuXHRcdFx0dmFyIHRtcDMgPSBkMyArIGQ0O1xuXHRcdFx0dmFyIHRtcDQgPSBkMyAtIGQ0O1xuXG5cdFx0XHQvKiBFdmVuIHBhcnQgKi9cblx0XHRcdHZhciB0bXAxMCA9IHRtcDAgKyB0bXAzO1x0LyogcGhhc2UgMiAqL1xuXHRcdFx0dmFyIHRtcDEzID0gdG1wMCAtIHRtcDM7XG5cdFx0XHR2YXIgdG1wMTEgPSB0bXAxICsgdG1wMjtcblx0XHRcdHZhciB0bXAxMiA9IHRtcDEgLSB0bXAyO1xuXG5cdFx0XHRkYXRhW2RhdGFPZmZdID0gdG1wMTAgKyB0bXAxMTsgLyogcGhhc2UgMyAqL1xuXHRcdFx0ZGF0YVtkYXRhT2ZmICsgNF0gPSB0bXAxMCAtIHRtcDExO1xuXG5cdFx0XHR2YXIgejEgPSAodG1wMTIgKyB0bXAxMykgKiAwLjcwNzEwNjc4MTsgLyogYzQgKi9cblx0XHRcdGRhdGFbZGF0YU9mZiArIDJdID0gdG1wMTMgKyB6MTsgLyogcGhhc2UgNSAqL1xuXHRcdFx0ZGF0YVtkYXRhT2ZmICsgNl0gPSB0bXAxMyAtIHoxO1xuXG5cdFx0XHQvKiBPZGQgcGFydCAqL1xuXHRcdFx0dG1wMTAgPSB0bXA0ICsgdG1wNTsgLyogcGhhc2UgMiAqL1xuXHRcdFx0dG1wMTEgPSB0bXA1ICsgdG1wNjtcblx0XHRcdHRtcDEyID0gdG1wNiArIHRtcDc7XG5cblx0XHRcdC8qIFRoZSByb3RhdG9yIGlzIG1vZGlmaWVkIGZyb20gZmlnIDQtOCB0byBhdm9pZCBleHRyYSBuZWdhdGlvbnMuICovXG5cdFx0XHR2YXIgejUgPSAodG1wMTAgLSB0bXAxMikgKiAwLjM4MjY4MzQzMzsgLyogYzYgKi9cblx0XHRcdHZhciB6MiA9IDAuNTQxMTk2MTAwICogdG1wMTAgKyB6NTsgLyogYzItYzYgKi9cblx0XHRcdHZhciB6NCA9IDEuMzA2NTYyOTY1ICogdG1wMTIgKyB6NTsgLyogYzIrYzYgKi9cblx0XHRcdHZhciB6MyA9IHRtcDExICogMC43MDcxMDY3ODE7IC8qIGM0ICovXG5cblx0XHRcdHZhciB6MTEgPSB0bXA3ICsgejM7XHQvKiBwaGFzZSA1ICovXG5cdFx0XHR2YXIgejEzID0gdG1wNyAtIHozO1xuXG5cdFx0XHRkYXRhW2RhdGFPZmYgKyA1XSA9IHoxMyArIHoyO1x0LyogcGhhc2UgNiAqL1xuXHRcdFx0ZGF0YVtkYXRhT2ZmICsgM10gPSB6MTMgLSB6Mjtcblx0XHRcdGRhdGFbZGF0YU9mZiArIDFdID0gejExICsgejQ7XG5cdFx0XHRkYXRhW2RhdGFPZmYgKyA3XSA9IHoxMSAtIHo0O1xuXG5cdFx0XHRkYXRhT2ZmICs9IDg7IC8qIGFkdmFuY2UgcG9pbnRlciB0byBuZXh0IHJvdyAqL1xuXHRcdH1cblxuXHRcdC8qIFBhc3MgMjogcHJvY2VzcyBjb2x1bW5zLiAqL1xuXHRcdGRhdGFPZmYgPSAwO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBJODsgKytpKSB7XG5cdFx0XHRkMCA9IGRhdGFbZGF0YU9mZl07XG5cdFx0XHRkMSA9IGRhdGFbZGF0YU9mZiArIDhdO1xuXHRcdFx0ZDIgPSBkYXRhW2RhdGFPZmYgKyAxNl07XG5cdFx0XHRkMyA9IGRhdGFbZGF0YU9mZiArIDI0XTtcblx0XHRcdGQ0ID0gZGF0YVtkYXRhT2ZmICsgMzJdO1xuXHRcdFx0ZDUgPSBkYXRhW2RhdGFPZmYgKyA0MF07XG5cdFx0XHRkNiA9IGRhdGFbZGF0YU9mZiArIDQ4XTtcblx0XHRcdGQ3ID0gZGF0YVtkYXRhT2ZmICsgNTZdO1xuXG5cdFx0XHR2YXIgdG1wMHAyID0gZDAgKyBkNztcblx0XHRcdHZhciB0bXA3cDIgPSBkMCAtIGQ3O1xuXHRcdFx0dmFyIHRtcDFwMiA9IGQxICsgZDY7XG5cdFx0XHR2YXIgdG1wNnAyID0gZDEgLSBkNjtcblx0XHRcdHZhciB0bXAycDIgPSBkMiArIGQ1O1xuXHRcdFx0dmFyIHRtcDVwMiA9IGQyIC0gZDU7XG5cdFx0XHR2YXIgdG1wM3AyID0gZDMgKyBkNDtcblx0XHRcdHZhciB0bXA0cDIgPSBkMyAtIGQ0O1xuXG5cdFx0XHQvKiBFdmVuIHBhcnQgKi9cblx0XHRcdHZhciB0bXAxMHAyID0gdG1wMHAyICsgdG1wM3AyO1x0LyogcGhhc2UgMiAqL1xuXHRcdFx0dmFyIHRtcDEzcDIgPSB0bXAwcDIgLSB0bXAzcDI7XG5cdFx0XHR2YXIgdG1wMTFwMiA9IHRtcDFwMiArIHRtcDJwMjtcblx0XHRcdHZhciB0bXAxMnAyID0gdG1wMXAyIC0gdG1wMnAyO1xuXG5cdFx0XHRkYXRhW2RhdGFPZmZdID0gdG1wMTBwMiArIHRtcDExcDI7IC8qIHBoYXNlIDMgKi9cblx0XHRcdGRhdGFbZGF0YU9mZiArIDMyXSA9IHRtcDEwcDIgLSB0bXAxMXAyO1xuXG5cdFx0XHR2YXIgejFwMiA9ICh0bXAxMnAyICsgdG1wMTNwMikgKiAwLjcwNzEwNjc4MTsgLyogYzQgKi9cblx0XHRcdGRhdGFbZGF0YU9mZiArIDE2XSA9IHRtcDEzcDIgKyB6MXAyOyAvKiBwaGFzZSA1ICovXG5cdFx0XHRkYXRhW2RhdGFPZmYgKyA0OF0gPSB0bXAxM3AyIC0gejFwMjtcblxuXHRcdFx0LyogT2RkIHBhcnQgKi9cblx0XHRcdHRtcDEwcDIgPSB0bXA0cDIgKyB0bXA1cDI7IC8qIHBoYXNlIDIgKi9cblx0XHRcdHRtcDExcDIgPSB0bXA1cDIgKyB0bXA2cDI7XG5cdFx0XHR0bXAxMnAyID0gdG1wNnAyICsgdG1wN3AyO1xuXG5cdFx0XHQvKiBUaGUgcm90YXRvciBpcyBtb2RpZmllZCBmcm9tIGZpZyA0LTggdG8gYXZvaWQgZXh0cmEgbmVnYXRpb25zLiAqL1xuXHRcdFx0dmFyIHo1cDIgPSAodG1wMTBwMiAtIHRtcDEycDIpICogMC4zODI2ODM0MzM7IC8qIGM2ICovXG5cdFx0XHR2YXIgejJwMiA9IDAuNTQxMTk2MTAwICogdG1wMTBwMiArIHo1cDI7IC8qIGMyLWM2ICovXG5cdFx0XHR2YXIgejRwMiA9IDEuMzA2NTYyOTY1ICogdG1wMTJwMiArIHo1cDI7IC8qIGMyK2M2ICovXG5cdFx0XHR2YXIgejNwMiA9IHRtcDExcDIgKiAwLjcwNzEwNjc4MTsgLyogYzQgKi9cblxuXHRcdFx0dmFyIHoxMXAyID0gdG1wN3AyICsgejNwMjtcdC8qIHBoYXNlIDUgKi9cblx0XHRcdHZhciB6MTNwMiA9IHRtcDdwMiAtIHozcDI7XG5cblx0XHRcdGRhdGFbZGF0YU9mZiArIDQwXSA9IHoxM3AyICsgejJwMjsgLyogcGhhc2UgNiAqL1xuXHRcdFx0ZGF0YVtkYXRhT2ZmICsgMjRdID0gejEzcDIgLSB6MnAyO1xuXHRcdFx0ZGF0YVtkYXRhT2ZmICsgOF0gPSB6MTFwMiArIHo0cDI7XG5cdFx0XHRkYXRhW2RhdGFPZmYgKyA1Nl0gPSB6MTFwMiAtIHo0cDI7XG5cblx0XHRcdGRhdGFPZmYrKzsgLyogYWR2YW5jZSBwb2ludGVyIHRvIG5leHQgY29sdW1uICovXG5cdFx0fVxuXG5cdFx0Ly8gUXVhbnRpemUvZGVzY2FsZSB0aGUgY29lZmZpY2llbnRzXG5cdFx0dmFyIGZEQ1RRdWFudDtcblx0XHRmb3IgKGkgPSAwOyBpIDwgSTY0OyArK2kpIHtcblx0XHRcdC8vIEFwcGx5IHRoZSBxdWFudGl6YXRpb24gYW5kIHNjYWxpbmcgZmFjdG9yICYgUm91bmQgdG8gbmVhcmVzdCBpbnRlZ2VyXG5cdFx0XHRmRENUUXVhbnQgPSBkYXRhW2ldICogZmR0YmxbaV07XG5cdFx0XHRvdXRwdXRmRENUUXVhbnRbaV0gPSAoZkRDVFF1YW50ID4gMC4wKSA/ICgoZkRDVFF1YW50ICsgMC41KSB8IDApIDogKChmRENUUXVhbnQgLSAwLjUpIHwgMCk7XG5cdFx0XHQvL291dHB1dGZEQ1RRdWFudFtpXSA9IGZyb3VuZChmRENUUXVhbnQpO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXRmRENUUXVhbnQ7XG5cdH1cblxuXHRmdW5jdGlvbiB3cml0ZUFQUDAoKSB7XG5cdFx0d3JpdGVXb3JkKDB4RkZFMCk7IC8vIG1hcmtlclxuXHRcdHdyaXRlV29yZCgxNik7IC8vIGxlbmd0aFxuXHRcdHdyaXRlQnl0ZSgweDRBKTsgLy8gSlxuXHRcdHdyaXRlQnl0ZSgweDQ2KTsgLy8gRlxuXHRcdHdyaXRlQnl0ZSgweDQ5KTsgLy8gSVxuXHRcdHdyaXRlQnl0ZSgweDQ2KTsgLy8gRlxuXHRcdHdyaXRlQnl0ZSgwKTsgLy8gPSBcIkpGSUZcIiwnXFwwJ1xuXHRcdHdyaXRlQnl0ZSgxKTsgLy8gdmVyc2lvbmhpXG5cdFx0d3JpdGVCeXRlKDEpOyAvLyB2ZXJzaW9ubG9cblx0XHR3cml0ZUJ5dGUoMCk7IC8vIHh5dW5pdHNcblx0XHR3cml0ZVdvcmQoMSk7IC8vIHhkZW5zaXR5XG5cdFx0d3JpdGVXb3JkKDEpOyAvLyB5ZGVuc2l0eVxuXHRcdHdyaXRlQnl0ZSgwKTsgLy8gdGh1bWJud2lkdGhcblx0XHR3cml0ZUJ5dGUoMCk7IC8vIHRodW1ibmhlaWdodFxuXHR9XG5cblx0ZnVuY3Rpb24gd3JpdGVTT0YwKHdpZHRoLCBoZWlnaHQpIHtcblx0XHR3cml0ZVdvcmQoMHhGRkMwKTsgLy8gbWFya2VyXG5cdFx0d3JpdGVXb3JkKDE3KTsgICAvLyBsZW5ndGgsIHRydWVjb2xvciBZVVYgSlBHXG5cdFx0d3JpdGVCeXRlKDgpOyAgICAvLyBwcmVjaXNpb25cblx0XHR3cml0ZVdvcmQoaGVpZ2h0KTtcblx0XHR3cml0ZVdvcmQod2lkdGgpO1xuXHRcdHdyaXRlQnl0ZSgzKTsgICAgLy8gbnJvZmNvbXBvbmVudHNcblx0XHR3cml0ZUJ5dGUoMSk7ICAgIC8vIElkWVxuXHRcdHdyaXRlQnl0ZSgweDExKTsgLy8gSFZZXG5cdFx0d3JpdGVCeXRlKDApOyAgICAvLyBRVFlcblx0XHR3cml0ZUJ5dGUoMik7ICAgIC8vIElkVVxuXHRcdHdyaXRlQnl0ZSgweDExKTsgLy8gSFZVXG5cdFx0d3JpdGVCeXRlKDEpOyAgICAvLyBRVFVcblx0XHR3cml0ZUJ5dGUoMyk7ICAgIC8vIElkVlxuXHRcdHdyaXRlQnl0ZSgweDExKTsgLy8gSFZWXG5cdFx0d3JpdGVCeXRlKDEpOyAgICAvLyBRVFZcblx0fVxuXG5cdGZ1bmN0aW9uIHdyaXRlRFFUKCkge1xuXHRcdHdyaXRlV29yZCgweEZGREIpOyAvLyBtYXJrZXJcblx0XHR3cml0ZVdvcmQoMTMyKTtcdCAgIC8vIGxlbmd0aFxuXHRcdHdyaXRlQnl0ZSgwKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDY0OyBpKyspIHtcblx0XHRcdHdyaXRlQnl0ZShZVGFibGVbaV0pO1xuXHRcdH1cblx0XHR3cml0ZUJ5dGUoMSk7XG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCA2NDsgaisrKSB7XG5cdFx0XHR3cml0ZUJ5dGUoVVZUYWJsZVtqXSk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gd3JpdGVESFQoKSB7XG5cdFx0d3JpdGVXb3JkKDB4RkZDNCk7IC8vIG1hcmtlclxuXHRcdHdyaXRlV29yZCgweDAxQTIpOyAvLyBsZW5ndGhcblxuXHRcdHdyaXRlQnl0ZSgwKTsgLy8gSFRZRENpbmZvXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG5cdFx0XHR3cml0ZUJ5dGUoc3RkX2RjX2x1bWluYW5jZV9ucmNvZGVzW2kgKyAxXSk7XG5cdFx0fVxuXHRcdGZvciAodmFyIGogPSAwOyBqIDw9IDExOyBqKyspIHtcblx0XHRcdHdyaXRlQnl0ZShzdGRfZGNfbHVtaW5hbmNlX3ZhbHVlc1tqXSk7XG5cdFx0fVxuXG5cdFx0d3JpdGVCeXRlKDB4MTApOyAvLyBIVFlBQ2luZm9cblx0XHRmb3IgKHZhciBrID0gMDsgayA8IDE2OyBrKyspIHtcblx0XHRcdHdyaXRlQnl0ZShzdGRfYWNfbHVtaW5hbmNlX25yY29kZXNbayArIDFdKTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgbCA9IDA7IGwgPD0gMTYxOyBsKyspIHtcblx0XHRcdHdyaXRlQnl0ZShzdGRfYWNfbHVtaW5hbmNlX3ZhbHVlc1tsXSk7XG5cdFx0fVxuXG5cdFx0d3JpdGVCeXRlKDEpOyAvLyBIVFVEQ2luZm9cblx0XHRmb3IgKHZhciBtID0gMDsgbSA8IDE2OyBtKyspIHtcblx0XHRcdHdyaXRlQnl0ZShzdGRfZGNfY2hyb21pbmFuY2VfbnJjb2Rlc1ttICsgMV0pO1xuXHRcdH1cblx0XHRmb3IgKHZhciBuID0gMDsgbiA8PSAxMTsgbisrKSB7XG5cdFx0XHR3cml0ZUJ5dGUoc3RkX2RjX2Nocm9taW5hbmNlX3ZhbHVlc1tuXSk7XG5cdFx0fVxuXG5cdFx0d3JpdGVCeXRlKDB4MTEpOyAvLyBIVFVBQ2luZm9cblx0XHRmb3IgKHZhciBvID0gMDsgbyA8IDE2OyBvKyspIHtcblx0XHRcdHdyaXRlQnl0ZShzdGRfYWNfY2hyb21pbmFuY2VfbnJjb2Rlc1tvICsgMV0pO1xuXHRcdH1cblx0XHRmb3IgKHZhciBwID0gMDsgcCA8PSAxNjE7IHArKykge1xuXHRcdFx0d3JpdGVCeXRlKHN0ZF9hY19jaHJvbWluYW5jZV92YWx1ZXNbcF0pO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHdyaXRlU09TKCkge1xuXHRcdHdyaXRlV29yZCgweEZGREEpOyAvLyBtYXJrZXJcblx0XHR3cml0ZVdvcmQoMTIpOyAvLyBsZW5ndGhcblx0XHR3cml0ZUJ5dGUoMyk7IC8vIG5yb2Zjb21wb25lbnRzXG5cdFx0d3JpdGVCeXRlKDEpOyAvLyBJZFlcblx0XHR3cml0ZUJ5dGUoMCk7IC8vIEhUWVxuXHRcdHdyaXRlQnl0ZSgyKTsgLy8gSWRVXG5cdFx0d3JpdGVCeXRlKDB4MTEpOyAvLyBIVFVcblx0XHR3cml0ZUJ5dGUoMyk7IC8vIElkVlxuXHRcdHdyaXRlQnl0ZSgweDExKTsgLy8gSFRWXG5cdFx0d3JpdGVCeXRlKDApOyAvLyBTc1xuXHRcdHdyaXRlQnl0ZSgweDNmKTsgLy8gU2Vcblx0XHR3cml0ZUJ5dGUoMCk7IC8vIEJmXG5cdH1cblxuXHRmdW5jdGlvbiBwcm9jZXNzRFUoQ0RVLCBmZHRibCwgREMsIEhUREMsIEhUQUMpIHtcblx0XHR2YXIgRU9CID0gSFRBQ1sweDAwXTtcblx0XHR2YXIgTTE2emVyb2VzID0gSFRBQ1sweEYwXTtcblx0XHR2YXIgcG9zO1xuXHRcdHZhciBJMTYgPSAxNjtcblx0XHR2YXIgSTYzID0gNjM7XG5cdFx0dmFyIEk2NCA9IDY0O1xuXHRcdHZhciBEVV9EQ1QgPSBmRENUUXVhbnQoQ0RVLCBmZHRibCk7XG5cdFx0Ly9aaWdaYWcgcmVvcmRlclxuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgSTY0OyArK2opIHtcblx0XHRcdERVW1ppZ1phZ1tqXV0gPSBEVV9EQ1Rbal07XG5cdFx0fVxuXHRcdHZhciBEaWZmID0gRFVbMF0gLSBEQzsgREMgPSBEVVswXTtcblx0XHQvL0VuY29kZSBEQ1xuXHRcdGlmIChEaWZmID09IDApIHtcblx0XHRcdHdyaXRlQml0cyhIVERDWzBdKTsgLy8gRGlmZiBtaWdodCBiZSAwXG5cdFx0fSBlbHNlIHtcblx0XHRcdHBvcyA9IDMyNzY3ICsgRGlmZjtcblx0XHRcdHdyaXRlQml0cyhIVERDW2NhdGVnb3J5W3Bvc11dKTtcblx0XHRcdHdyaXRlQml0cyhiaXRjb2RlW3Bvc10pO1xuXHRcdH1cblx0XHQvL0VuY29kZSBBQ3Ncblx0XHR2YXIgZW5kMHBvcyA9IDYzOyAvLyB3YXMgY29uc3QuLi4gd2hpY2ggaXMgY3Jhenlcblx0XHR3aGlsZSAoKGVuZDBwb3MgPiAwKSAmJiAoRFVbZW5kMHBvc10gPT0gMCkpIHtcblx0XHRcdGVuZDBwb3MtLTtcblx0XHR9XG5cdFx0Ly9lbmQwcG9zID0gZmlyc3QgZWxlbWVudCBpbiByZXZlcnNlIG9yZGVyICE9MFxuXHRcdGlmIChlbmQwcG9zID09IDApIHtcblx0XHRcdHdyaXRlQml0cyhFT0IpO1xuXHRcdFx0cmV0dXJuIERDO1xuXHRcdH1cblx0XHR2YXIgaSA9IDE7XG5cdFx0dmFyIGxuZztcblx0XHR3aGlsZSAoaSA8PSBlbmQwcG9zKSB7XG5cdFx0XHR2YXIgc3RhcnRwb3MgPSBpO1xuXHRcdFx0d2hpbGUgKChEVVtpXSA9PSAwKSAmJiAoaSA8PSBlbmQwcG9zKSkge1xuXHRcdFx0XHQrK2k7XG5cdFx0XHR9XG5cdFx0XHR2YXIgbnJ6ZXJvZXMgPSBpIC0gc3RhcnRwb3M7XG5cdFx0XHRpZiAobnJ6ZXJvZXMgPj0gSTE2KSB7XG5cdFx0XHRcdGxuZyA9IG5yemVyb2VzID4+IDQ7XG5cdFx0XHRcdGZvciAodmFyIG5ybWFya2VyID0gMTsgbnJtYXJrZXIgPD0gbG5nOyArK25ybWFya2VyKVxuXHRcdFx0XHRcdHdyaXRlQml0cyhNMTZ6ZXJvZXMpO1xuXHRcdFx0XHRucnplcm9lcyA9IG5yemVyb2VzICYgMHhGO1xuXHRcdFx0fVxuXHRcdFx0cG9zID0gMzI3NjcgKyBEVVtpXTtcblx0XHRcdHdyaXRlQml0cyhIVEFDWyhucnplcm9lcyA8PCA0KSArIGNhdGVnb3J5W3Bvc11dKTtcblx0XHRcdHdyaXRlQml0cyhiaXRjb2RlW3Bvc10pO1xuXHRcdFx0aSsrO1xuXHRcdH1cblx0XHRpZiAoZW5kMHBvcyAhPSBJNjMpIHtcblx0XHRcdHdyaXRlQml0cyhFT0IpO1xuXHRcdH1cblx0XHRyZXR1cm4gREM7XG5cdH1cblxuXHRmdW5jdGlvbiBpbml0Q2hhckxvb2t1cFRhYmxlKCkge1xuXHRcdHZhciBzZmNjID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7IC8vLy8vIEFDSFRVTkcgLy8gMjU1XG5cdFx0XHRjbHRbaV0gPSBzZmNjKGkpO1xuXHRcdH1cblx0fVxuXG5cdHRoaXMuZW5jb2RlID0gZnVuY3Rpb24gKGltYWdlLCBxdWFsaXR5KSAvLyBpbWFnZSBkYXRhIG9iamVjdFxuXHR7XG5cdFx0aWYgKHF1YWxpdHkpIHNldFF1YWxpdHkocXVhbGl0eSk7XG5cblx0XHQvLyBJbml0aWFsaXplIGJpdCB3cml0ZXJcblx0XHRieXRlb3V0ID0gbmV3IEFycmF5KCk7XG5cdFx0Ynl0ZW5ldyA9IDA7XG5cdFx0Ynl0ZXBvcyA9IDc7XG5cblx0XHQvLyBBZGQgSlBFRyBoZWFkZXJzXG5cdFx0d3JpdGVXb3JkKDB4RkZEOCk7IC8vIFNPSVxuXHRcdHdyaXRlQVBQMCgpO1xuXHRcdHdyaXRlRFFUKCk7XG5cdFx0d3JpdGVTT0YwKGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpO1xuXHRcdHdyaXRlREhUKCk7XG5cdFx0d3JpdGVTT1MoKTtcblxuXG5cdFx0Ly8gRW5jb2RlIDh4OCBtYWNyb2Jsb2Nrc1xuXHRcdHZhciBEQ1kgPSAwO1xuXHRcdHZhciBEQ1UgPSAwO1xuXHRcdHZhciBEQ1YgPSAwO1xuXG5cdFx0Ynl0ZW5ldyA9IDA7XG5cdFx0Ynl0ZXBvcyA9IDc7XG5cblxuXHRcdHRoaXMuZW5jb2RlLmRpc3BsYXlOYW1lID0gXCJfZW5jb2RlX1wiO1xuXG5cdFx0dmFyIGltYWdlRGF0YSA9IGltYWdlLmRhdGE7XG5cdFx0dmFyIHdpZHRoID0gaW1hZ2Uud2lkdGg7XG5cdFx0dmFyIGhlaWdodCA9IGltYWdlLmhlaWdodDtcblxuXHRcdHZhciBxdWFkV2lkdGggPSB3aWR0aCAqIDQ7XG5cblx0XHR2YXIgeCwgeSA9IDA7XG5cdFx0dmFyIHIsIGcsIGI7XG5cdFx0dmFyIHN0YXJ0LCBwLCBjb2wsIHJvdywgcG9zO1xuXHRcdHdoaWxlICh5IDwgaGVpZ2h0KSB7XG5cdFx0XHR4ID0gMDtcblx0XHRcdHdoaWxlICh4IDwgcXVhZFdpZHRoKSB7XG5cdFx0XHRcdHN0YXJ0ID0gcXVhZFdpZHRoICogeSArIHg7XG5cdFx0XHRcdGNvbCA9IC0xO1xuXHRcdFx0XHRyb3cgPSAwO1xuXG5cdFx0XHRcdGZvciAocG9zID0gMDsgcG9zIDwgNjQ7IHBvcysrKSB7XG5cdFx0XHRcdFx0cm93ID0gcG9zID4+IDM7Ly8gLzhcblx0XHRcdFx0XHRjb2wgPSAocG9zICYgNykgKiA0OyAvLyAlOFxuXHRcdFx0XHRcdHAgPSBzdGFydCArIChyb3cgKiBxdWFkV2lkdGgpICsgY29sO1xuXG5cdFx0XHRcdFx0aWYgKHkgKyByb3cgPj0gaGVpZ2h0KSB7IC8vIHBhZGRpbmcgYm90dG9tXG5cdFx0XHRcdFx0XHRwIC09IChxdWFkV2lkdGggKiAoeSArIDEgKyByb3cgLSBoZWlnaHQpKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoeCArIGNvbCA+PSBxdWFkV2lkdGgpIHsgLy8gcGFkZGluZyByaWdodFxuXHRcdFx0XHRcdFx0cCAtPSAoKHggKyBjb2wpIC0gcXVhZFdpZHRoICsgNCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ciA9IGltYWdlRGF0YVtwKytdO1xuXHRcdFx0XHRcdGcgPSBpbWFnZURhdGFbcCsrXTtcblx0XHRcdFx0XHRiID0gaW1hZ2VEYXRhW3ArK107XG5cblxuXHRcdFx0XHRcdC8qIC8vIGNhbGN1bGF0ZSBZVVYgdmFsdWVzIGR5bmFtaWNhbGx5XG5cdFx0XHRcdFx0WURVW3Bvc109KCgoIDAuMjk5MDApKnIrKCAwLjU4NzAwKSpnKyggMC4xMTQwMCkqYikpLTEyODsgLy8tMHg4MFxuXHRcdFx0XHRcdFVEVVtwb3NdPSgoKC0wLjE2ODc0KSpyKygtMC4zMzEyNikqZysoIDAuNTAwMDApKmIpKTtcblx0XHRcdFx0XHRWRFVbcG9zXT0oKCggMC41MDAwMCkqcisoLTAuNDE4NjkpKmcrKC0wLjA4MTMxKSpiKSk7XG5cdFx0XHRcdFx0Ki9cblxuXHRcdFx0XHRcdC8vIHVzZSBsb29rdXAgdGFibGUgKHNsaWdodGx5IGZhc3Rlcilcblx0XHRcdFx0XHRZRFVbcG9zXSA9ICgoUkdCX1lVVl9UQUJMRVtyXSArIFJHQl9ZVVZfVEFCTEVbKGcgKyAyNTYpID4+IDBdICsgUkdCX1lVVl9UQUJMRVsoYiArIDUxMikgPj4gMF0pID4+IDE2KSAtIDEyODtcblx0XHRcdFx0XHRVRFVbcG9zXSA9ICgoUkdCX1lVVl9UQUJMRVsociArIDc2OCkgPj4gMF0gKyBSR0JfWVVWX1RBQkxFWyhnICsgMTAyNCkgPj4gMF0gKyBSR0JfWVVWX1RBQkxFWyhiICsgMTI4MCkgPj4gMF0pID4+IDE2KSAtIDEyODtcblx0XHRcdFx0XHRWRFVbcG9zXSA9ICgoUkdCX1lVVl9UQUJMRVsociArIDEyODApID4+IDBdICsgUkdCX1lVVl9UQUJMRVsoZyArIDE1MzYpID4+IDBdICsgUkdCX1lVVl9UQUJMRVsoYiArIDE3OTIpID4+IDBdKSA+PiAxNikgLSAxMjg7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdERDWSA9IHByb2Nlc3NEVShZRFUsIGZkdGJsX1ksIERDWSwgWURDX0hULCBZQUNfSFQpO1xuXHRcdFx0XHREQ1UgPSBwcm9jZXNzRFUoVURVLCBmZHRibF9VViwgRENVLCBVVkRDX0hULCBVVkFDX0hUKTtcblx0XHRcdFx0RENWID0gcHJvY2Vzc0RVKFZEVSwgZmR0YmxfVVYsIERDViwgVVZEQ19IVCwgVVZBQ19IVCk7XG5cdFx0XHRcdHggKz0gMzI7XG5cdFx0XHR9XG5cdFx0XHR5ICs9IDg7XG5cdFx0fVxuXG5cblx0XHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblx0XHQvLyBEbyB0aGUgYml0IGFsaWdubWVudCBvZiB0aGUgRU9JIG1hcmtlclxuXHRcdGlmIChieXRlcG9zID49IDApIHtcblx0XHRcdHZhciBmaWxsYml0cyA9IFtdO1xuXHRcdFx0ZmlsbGJpdHNbMV0gPSBieXRlcG9zICsgMTtcblx0XHRcdGZpbGxiaXRzWzBdID0gKDEgPDwgKGJ5dGVwb3MgKyAxKSkgLSAxO1xuXHRcdFx0d3JpdGVCaXRzKGZpbGxiaXRzKTtcblx0XHR9XG5cblx0XHR3cml0ZVdvcmQoMHhGRkQ5KTsgLy9FT0lcblxuXHRcdHJldHVybiBuZXcgVWludDhBcnJheShieXRlb3V0KTtcblx0fTtcblxuXHRmdW5jdGlvbiBzZXRRdWFsaXR5KHF1YWxpdHkpIHtcblx0XHRxdWFsaXR5ID0gTWF0aC5taW4oTWF0aC5tYXgocXVhbGl0eSwgMSksIDEwMCk7XG5cblx0XHRpZiAoY3VycmVudFF1YWxpdHkgPT0gcXVhbGl0eSkgcmV0dXJuIC8vIGRvbid0IHJlY2FsYyBpZiB1bmNoYW5nZWRcblxuXHRcdHZhciBzZiA9IChxdWFsaXR5IDwgNTApID8gTWF0aC5mbG9vcig1MDAwIC8gcXVhbGl0eSkgOiBNYXRoLmZsb29yKDIwMCAtIHF1YWxpdHkgKiAyKTtcblxuXHRcdGluaXRRdWFudFRhYmxlcyhzZik7XG5cdFx0Y3VycmVudFF1YWxpdHkgPSBxdWFsaXR5O1xuXHRcdC8vY29uc29sZS5sb2coJ1F1YWxpdHkgc2V0IHRvOiAnK3F1YWxpdHkgKyclJyk7XG5cdH1cblxuXHRmdW5jdGlvbiBpbml0KCkge1xuXHRcdHF1YWxpdHkgPSBxdWFsaXR5IHx8IDUwO1xuXHRcdC8vIENyZWF0ZSB0YWJsZXNcblx0XHRpbml0Q2hhckxvb2t1cFRhYmxlKClcblx0XHRpbml0SHVmZm1hblRibCgpO1xuXHRcdGluaXRDYXRlZ29yeU51bWJlcigpO1xuXHRcdGluaXRSR0JZVVZUYWJsZSgpO1xuXG5cdFx0c2V0UXVhbGl0eShxdWFsaXR5KTtcblx0fVxuXHRpbml0KCk7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuZXhwb3J0cy5KUEVHRW5jb2RlciA9IEpQRUdFbmNvZGVyOyIsIi8qIENvcHlyaWdodCAyMDE0IE1vemlsbGEgRm91bmRhdGlvblxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmNvbnN0IEJhc2VFeGNlcHRpb24gPSAoZnVuY3Rpb24gQmFzZUV4Y2VwdGlvbkNsb3N1cmUoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcbiAgZnVuY3Rpb24gQmFzZUV4Y2VwdGlvbihtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IEJhc2VFeGNlcHRpb24pIHtcbiAgICAgIHVucmVhY2hhYmxlKFwiQ2Fubm90IGluaXRpYWxpemUgQmFzZUV4Y2VwdGlvbi5cIik7XG4gICAgfVxuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG4gIEJhc2VFeGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG4gIEJhc2VFeGNlcHRpb24uY29uc3RydWN0b3IgPSBCYXNlRXhjZXB0aW9uO1xuXG4gIHJldHVybiBCYXNlRXhjZXB0aW9uO1xufSkoKTtcblxuY29uc3QgVmVyYm9zaXR5TGV2ZWwgPSB7XG4gIEVSUk9SUzogMCxcbiAgV0FSTklOR1M6IDEsXG4gIElORk9TOiA1LFxufTtcblxuXG4vLyBOb24tZmF0YWwgd2FybmluZ3MuXG5mdW5jdGlvbiB3YXJuKG1zZykge1xuICBpZiAodmVyYm9zaXR5ID49IFZlcmJvc2l0eUxldmVsLldBUk5JTkdTKSB7XG4gICAgY29uc29sZS5sb2coYFdhcm5pbmc6ICR7bXNnfWApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVucmVhY2hhYmxlKG1zZykge1xuICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0KGNvbmQsIG1zZykge1xuICBpZiAoIWNvbmQpIHtcbiAgICB1bnJlYWNoYWJsZShtc2cpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlYWRVaW50MTYoZGF0YSwgb2Zmc2V0KSB7XG4gIHJldHVybiAoZGF0YVtvZmZzZXRdIDw8IDgpIHwgZGF0YVtvZmZzZXQgKyAxXTtcbn1cblxuY2xhc3MgSnBlZ0Vycm9yIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZykge1xuICAgIHN1cGVyKGBKUEVHIGVycm9yOiAke21zZ31gKTtcbiAgfVxufVxuXG5jbGFzcyBETkxNYXJrZXJFcnJvciBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzY2FuTGluZXMpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLnNjYW5MaW5lcyA9IHNjYW5MaW5lcztcbiAgfVxufVxuXG5jbGFzcyBFT0lNYXJrZXJFcnJvciBleHRlbmRzIEJhc2VFeGNlcHRpb24ge31cblxuLyoqXG4gKiBUaGlzIGNvZGUgd2FzIGZvcmtlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9ub3RtYXN0ZXJ5ZXQvanBnanMuXG4gKiBUaGUgb3JpZ2luYWwgdmVyc2lvbiB3YXMgY3JlYXRlZCBieSBHaXRIdWIgdXNlciBub3RtYXN0ZXJ5ZXQuXG4gKlxuICogLSBUaGUgSlBFRyBzcGVjaWZpY2F0aW9uIGNhbiBiZSBmb3VuZCBpbiB0aGUgSVRVIENDSVRUIFJlY29tbWVuZGF0aW9uIFQuODFcbiAqICAgKHd3dy53My5vcmcvR3JhcGhpY3MvSlBFRy9pdHUtdDgxLnBkZilcbiAqIC0gVGhlIEpGSUYgc3BlY2lmaWNhdGlvbiBjYW4gYmUgZm91bmQgaW4gdGhlIEpQRUcgRmlsZSBJbnRlcmNoYW5nZSBGb3JtYXRcbiAqICAgKHd3dy53My5vcmcvR3JhcGhpY3MvSlBFRy9qZmlmMy5wZGYpXG4gKiAtIFRoZSBBZG9iZSBBcHBsaWNhdGlvbi1TcGVjaWZpYyBKUEVHIG1hcmtlcnMgaW4gdGhlXG4gKiAgIFN1cHBvcnRpbmcgdGhlIERDVCBGaWx0ZXJzIGluIFBvc3RTY3JpcHQgTGV2ZWwgMiwgVGVjaG5pY2FsIE5vdGUgIzUxMTZcbiAqICAgKHBhcnRuZXJzLmFkb2JlLmNvbS9wdWJsaWMvZGV2ZWxvcGVyL2VuL3BzL3Nkay81MTE2LkRDVF9GaWx0ZXIucGRmKVxuICovXG5cbnZhciBKcGVnSW1hZ2UgPSAoZnVuY3Rpb24gSnBlZ0ltYWdlQ2xvc3VyZSgpIHtcbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIHZhciBkY3RaaWdaYWcgPSBuZXcgVWludDhBcnJheShbXG4gICAgIDAsXG4gICAgIDEsICA4LFxuICAgIDE2LCAgOSwgIDIsXG4gICAgIDMsIDEwLCAxNywgMjQsXG4gICAgMzIsIDI1LCAxOCwgMTEsIDQsXG4gICAgIDUsIDEyLCAxOSwgMjYsIDMzLCA0MCxcbiAgICA0OCwgNDEsIDM0LCAyNywgMjAsIDEzLCAgNixcbiAgICAgNywgMTQsIDIxLCAyOCwgMzUsIDQyLCA0OSwgNTYsXG4gICAgNTcsIDUwLCA0MywgMzYsIDI5LCAyMiwgMTUsXG4gICAgMjMsIDMwLCAzNywgNDQsIDUxLCA1OCxcbiAgICA1OSwgNTIsIDQ1LCAzOCwgMzEsXG4gICAgMzksIDQ2LCA1MywgNjAsXG4gICAgNjEsIDU0LCA0NyxcbiAgICA1NSwgNjIsXG4gICAgNjNcbiAgXSk7XG5cbiAgdmFyIGRjdENvczEgPSA0MDE3OyAvLyBjb3MocGkvMTYpXG4gIHZhciBkY3RTaW4xID0gNzk5OyAvLyBzaW4ocGkvMTYpXG4gIHZhciBkY3RDb3MzID0gMzQwNjsgLy8gY29zKDMqcGkvMTYpXG4gIHZhciBkY3RTaW4zID0gMjI3NjsgLy8gc2luKDMqcGkvMTYpXG4gIHZhciBkY3RDb3M2ID0gMTU2NzsgLy8gY29zKDYqcGkvMTYpXG4gIHZhciBkY3RTaW42ID0gMzc4NDsgLy8gc2luKDYqcGkvMTYpXG4gIHZhciBkY3RTcXJ0MiA9IDU3OTM7IC8vIHNxcnQoMilcbiAgdmFyIGRjdFNxcnQxZDIgPSAyODk2OyAvLyBzcXJ0KDIpIC8gMlxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcbiAgZnVuY3Rpb24gSnBlZ0ltYWdlKHsgZGVjb2RlVHJhbnNmb3JtID0gbnVsbCwgY29sb3JUcmFuc2Zvcm0gPSAtMSB9ID0ge30pIHtcbiAgICB0aGlzLl9kZWNvZGVUcmFuc2Zvcm0gPSBkZWNvZGVUcmFuc2Zvcm07XG4gICAgdGhpcy5fY29sb3JUcmFuc2Zvcm0gPSBjb2xvclRyYW5zZm9ybTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkSHVmZm1hblRhYmxlKGNvZGVMZW5ndGhzLCB2YWx1ZXMpIHtcbiAgICB2YXIgayA9IDAsXG4gICAgICBjb2RlID0gW10sXG4gICAgICBpLFxuICAgICAgaixcbiAgICAgIGxlbmd0aCA9IDE2O1xuICAgIHdoaWxlIChsZW5ndGggPiAwICYmICFjb2RlTGVuZ3Roc1tsZW5ndGggLSAxXSkge1xuICAgICAgbGVuZ3RoLS07XG4gICAgfVxuICAgIGNvZGUucHVzaCh7IGNoaWxkcmVuOiBbXSwgaW5kZXg6IDAgfSk7XG4gICAgdmFyIHAgPSBjb2RlWzBdLFxuICAgICAgcTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBjb2RlTGVuZ3Roc1tpXTsgaisrKSB7XG4gICAgICAgIHAgPSBjb2RlLnBvcCgpO1xuICAgICAgICBwLmNoaWxkcmVuW3AuaW5kZXhdID0gdmFsdWVzW2tdO1xuICAgICAgICB3aGlsZSAocC5pbmRleCA+IDApIHtcbiAgICAgICAgICBwID0gY29kZS5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBwLmluZGV4Kys7XG4gICAgICAgIGNvZGUucHVzaChwKTtcbiAgICAgICAgd2hpbGUgKGNvZGUubGVuZ3RoIDw9IGkpIHtcbiAgICAgICAgICBjb2RlLnB1c2goKHEgPSB7IGNoaWxkcmVuOiBbXSwgaW5kZXg6IDAgfSkpO1xuICAgICAgICAgIHAuY2hpbGRyZW5bcC5pbmRleF0gPSBxLmNoaWxkcmVuO1xuICAgICAgICAgIHAgPSBxO1xuICAgICAgICB9XG4gICAgICAgIGsrKztcbiAgICAgIH1cbiAgICAgIGlmIChpICsgMSA8IGxlbmd0aCkge1xuICAgICAgICAvLyBwIGhlcmUgcG9pbnRzIHRvIGxhc3QgY29kZVxuICAgICAgICBjb2RlLnB1c2goKHEgPSB7IGNoaWxkcmVuOiBbXSwgaW5kZXg6IDAgfSkpO1xuICAgICAgICBwLmNoaWxkcmVuW3AuaW5kZXhdID0gcS5jaGlsZHJlbjtcbiAgICAgICAgcCA9IHE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2RlWzBdLmNoaWxkcmVuO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QmxvY2tCdWZmZXJPZmZzZXQoY29tcG9uZW50LCByb3csIGNvbCkge1xuICAgIHJldHVybiA2NCAqICgoY29tcG9uZW50LmJsb2Nrc1BlckxpbmUgKyAxKSAqIHJvdyArIGNvbCk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGVTY2FuKFxuICAgIGRhdGEsXG4gICAgb2Zmc2V0LFxuICAgIGZyYW1lLFxuICAgIGNvbXBvbmVudHMsXG4gICAgcmVzZXRJbnRlcnZhbCxcbiAgICBzcGVjdHJhbFN0YXJ0LFxuICAgIHNwZWN0cmFsRW5kLFxuICAgIHN1Y2Nlc3NpdmVQcmV2LFxuICAgIHN1Y2Nlc3NpdmUsXG4gICAgcGFyc2VETkxNYXJrZXIgPSBmYWxzZVxuICApIHtcbiAgICB2YXIgbWN1c1BlckxpbmUgPSBmcmFtZS5tY3VzUGVyTGluZTtcbiAgICB2YXIgcHJvZ3Jlc3NpdmUgPSBmcmFtZS5wcm9ncmVzc2l2ZTtcblxuICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgIGxldCBiaXRzRGF0YSA9IDAsXG4gICAgICBiaXRzQ291bnQgPSAwO1xuXG4gICAgZnVuY3Rpb24gcmVhZEJpdCgpIHtcbiAgICAgIGlmIChiaXRzQ291bnQgPiAwKSB7XG4gICAgICAgIGJpdHNDb3VudC0tO1xuICAgICAgICByZXR1cm4gKGJpdHNEYXRhID4+IGJpdHNDb3VudCkgJiAxO1xuICAgICAgfVxuICAgICAgYml0c0RhdGEgPSBkYXRhW29mZnNldCsrXTtcbiAgICAgIGlmIChiaXRzRGF0YSA9PT0gMHhmZikge1xuICAgICAgICB2YXIgbmV4dEJ5dGUgPSBkYXRhW29mZnNldCsrXTtcbiAgICAgICAgaWYgKG5leHRCeXRlKSB7XG4gICAgICAgICAgaWYgKG5leHRCeXRlID09PSAvKiBETkwgPSAqLyAweGRjICYmIHBhcnNlRE5MTWFya2VyKSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gMjsgLy8gU2tpcCBtYXJrZXIgbGVuZ3RoLlxuXG4gICAgICAgICAgICBjb25zdCBzY2FuTGluZXMgPSByZWFkVWludDE2KGRhdGEsIG9mZnNldCk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgICAgICAgIGlmIChzY2FuTGluZXMgPiAwICYmIHNjYW5MaW5lcyAhPT0gZnJhbWUuc2NhbkxpbmVzKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBETkxNYXJrZXJFcnJvcihcbiAgICAgICAgICAgICAgICBcIkZvdW5kIEROTCBtYXJrZXIgKDB4RkZEQykgd2hpbGUgcGFyc2luZyBzY2FuIGRhdGFcIixcbiAgICAgICAgICAgICAgICBzY2FuTGluZXNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKG5leHRCeXRlID09PSAvKiBFT0kgPSAqLyAweGQ5KSB7XG4gICAgICAgICAgICBpZiAocGFyc2VETkxNYXJrZXIpIHtcbiAgICAgICAgICAgICAgLy8gTk9URTogb25seSA4LWJpdCBKUEVHIGltYWdlcyBhcmUgc3VwcG9ydGVkIGluIHRoaXMgZGVjb2Rlci5cbiAgICAgICAgICAgICAgY29uc3QgbWF5YmVTY2FuTGluZXMgPSBibG9ja1JvdyAqIChmcmFtZS5wcmVjaXNpb24gPT09IDggPyA4IDogMCk7XG4gICAgICAgICAgICAgIC8vIEhldXJpc3RpYyB0byBhdHRlbXB0IHRvIGhhbmRsZSBjb3JydXB0IEpQRUcgaW1hZ2VzIHdpdGggdG9vXG4gICAgICAgICAgICAgIC8vIGxhcmdlIGBzY2FuTGluZXNgIHBhcmFtZXRlciwgYnkgZmFsbGluZyBiYWNrIHRvIHRoZSBjdXJyZW50bHlcbiAgICAgICAgICAgICAgLy8gcGFyc2VkIG51bWJlciBvZiBzY2FuTGluZXMgd2hlbiBpdCdzIGF0IGxlYXN0IChhcHByb3hpbWF0ZWx5KVxuICAgICAgICAgICAgICAvLyBvbmUgb3JkZXIgb2YgbWFnbml0dWRlIHNtYWxsZXIgdGhhbiBleHBlY3RlZCAoZml4ZXNcbiAgICAgICAgICAgICAgLy8gaXNzdWUxMDg4MC5wZGYgYW5kIGlzc3VlMTA5ODkucGRmKS5cbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG1heWJlU2NhbkxpbmVzID4gMCAmJlxuICAgICAgICAgICAgICAgIE1hdGgucm91bmQoZnJhbWUuc2NhbkxpbmVzIC8gbWF5YmVTY2FuTGluZXMpID49IDEwXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBETkxNYXJrZXJFcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiRm91bmQgRU9JIG1hcmtlciAoMHhGRkQ5KSB3aGlsZSBwYXJzaW5nIHNjYW4gZGF0YSwgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcInBvc3NpYmx5IGNhdXNlZCBieSBpbmNvcnJlY3QgYHNjYW5MaW5lc2AgcGFyYW1ldGVyXCIsXG4gICAgICAgICAgICAgICAgICBtYXliZVNjYW5MaW5lc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFT0lNYXJrZXJFcnJvcihcbiAgICAgICAgICAgICAgXCJGb3VuZCBFT0kgbWFya2VyICgweEZGRDkpIHdoaWxlIHBhcnNpbmcgc2NhbiBkYXRhXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBKcGVnRXJyb3IoXG4gICAgICAgICAgICBgdW5leHBlY3RlZCBtYXJrZXIgJHsoKGJpdHNEYXRhIDw8IDgpIHwgbmV4dEJ5dGUpLnRvU3RyaW5nKDE2KX1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB1bnN0dWZmIDBcbiAgICAgIH1cbiAgICAgIGJpdHNDb3VudCA9IDc7XG4gICAgICByZXR1cm4gYml0c0RhdGEgPj4+IDc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVjb2RlSHVmZm1hbih0cmVlKSB7XG4gICAgICB2YXIgbm9kZSA9IHRyZWU7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBub2RlID0gbm9kZVtyZWFkQml0KCldO1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiBub2RlKSB7XG4gICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEpwZWdFcnJvcihcImludmFsaWQgaHVmZm1hbiBzZXF1ZW5jZVwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWNlaXZlKGxlbmd0aCkge1xuICAgICAgdmFyIG4gPSAwO1xuICAgICAgd2hpbGUgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgbiA9IChuIDw8IDEpIHwgcmVhZEJpdCgpO1xuICAgICAgICBsZW5ndGgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlY2VpdmVBbmRFeHRlbmQobGVuZ3RoKSB7XG4gICAgICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiByZWFkQml0KCkgPT09IDEgPyAxIDogLTE7XG4gICAgICB9XG4gICAgICB2YXIgbiA9IHJlY2VpdmUobGVuZ3RoKTtcbiAgICAgIGlmIChuID49IDEgPDwgKGxlbmd0aCAtIDEpKSB7XG4gICAgICAgIHJldHVybiBuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG4gKyAoLTEgPDwgbGVuZ3RoKSArIDE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVjb2RlQmFzZWxpbmUoY29tcG9uZW50LCBibG9ja09mZnNldCkge1xuICAgICAgdmFyIHQgPSBkZWNvZGVIdWZmbWFuKGNvbXBvbmVudC5odWZmbWFuVGFibGVEQyk7XG4gICAgICB2YXIgZGlmZiA9IHQgPT09IDAgPyAwIDogcmVjZWl2ZUFuZEV4dGVuZCh0KTtcbiAgICAgIGNvbXBvbmVudC5ibG9ja0RhdGFbYmxvY2tPZmZzZXRdID0gY29tcG9uZW50LnByZWQgKz0gZGlmZjtcbiAgICAgIHZhciBrID0gMTtcbiAgICAgIHdoaWxlIChrIDwgNjQpIHtcbiAgICAgICAgdmFyIHJzID0gZGVjb2RlSHVmZm1hbihjb21wb25lbnQuaHVmZm1hblRhYmxlQUMpO1xuICAgICAgICB2YXIgcyA9IHJzICYgMTUsXG4gICAgICAgICAgciA9IHJzID4+IDQ7XG4gICAgICAgIGlmIChzID09PSAwKSB7XG4gICAgICAgICAgaWYgKHIgPCAxNSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGsgKz0gMTY7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgayArPSByO1xuICAgICAgICB2YXIgeiA9IGRjdFppZ1phZ1trXTtcbiAgICAgICAgY29tcG9uZW50LmJsb2NrRGF0YVtibG9ja09mZnNldCArIHpdID0gcmVjZWl2ZUFuZEV4dGVuZChzKTtcbiAgICAgICAgaysrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlY29kZURDRmlyc3QoY29tcG9uZW50LCBibG9ja09mZnNldCkge1xuICAgICAgdmFyIHQgPSBkZWNvZGVIdWZmbWFuKGNvbXBvbmVudC5odWZmbWFuVGFibGVEQyk7XG4gICAgICB2YXIgZGlmZiA9IHQgPT09IDAgPyAwIDogcmVjZWl2ZUFuZEV4dGVuZCh0KSA8PCBzdWNjZXNzaXZlO1xuICAgICAgY29tcG9uZW50LmJsb2NrRGF0YVtibG9ja09mZnNldF0gPSBjb21wb25lbnQucHJlZCArPSBkaWZmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlY29kZURDU3VjY2Vzc2l2ZShjb21wb25lbnQsIGJsb2NrT2Zmc2V0KSB7XG4gICAgICBjb21wb25lbnQuYmxvY2tEYXRhW2Jsb2NrT2Zmc2V0XSB8PSByZWFkQml0KCkgPDwgc3VjY2Vzc2l2ZTtcbiAgICB9XG5cbiAgICB2YXIgZW9icnVuID0gMDtcbiAgICBmdW5jdGlvbiBkZWNvZGVBQ0ZpcnN0KGNvbXBvbmVudCwgYmxvY2tPZmZzZXQpIHtcbiAgICAgIGlmIChlb2JydW4gPiAwKSB7XG4gICAgICAgIGVvYnJ1bi0tO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgayA9IHNwZWN0cmFsU3RhcnQsXG4gICAgICAgIGUgPSBzcGVjdHJhbEVuZDtcbiAgICAgIHdoaWxlIChrIDw9IGUpIHtcbiAgICAgICAgdmFyIHJzID0gZGVjb2RlSHVmZm1hbihjb21wb25lbnQuaHVmZm1hblRhYmxlQUMpO1xuICAgICAgICB2YXIgcyA9IHJzICYgMTUsXG4gICAgICAgICAgciA9IHJzID4+IDQ7XG4gICAgICAgIGlmIChzID09PSAwKSB7XG4gICAgICAgICAgaWYgKHIgPCAxNSkge1xuICAgICAgICAgICAgZW9icnVuID0gcmVjZWl2ZShyKSArICgxIDw8IHIpIC0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrICs9IDE2O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGsgKz0gcjtcbiAgICAgICAgdmFyIHogPSBkY3RaaWdaYWdba107XG4gICAgICAgIGNvbXBvbmVudC5ibG9ja0RhdGFbYmxvY2tPZmZzZXQgKyB6XSA9XG4gICAgICAgICAgcmVjZWl2ZUFuZEV4dGVuZChzKSAqICgxIDw8IHN1Y2Nlc3NpdmUpO1xuICAgICAgICBrKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHN1Y2Nlc3NpdmVBQ1N0YXRlID0gMCxcbiAgICAgIHN1Y2Nlc3NpdmVBQ05leHRWYWx1ZTtcbiAgICBmdW5jdGlvbiBkZWNvZGVBQ1N1Y2Nlc3NpdmUoY29tcG9uZW50LCBibG9ja09mZnNldCkge1xuICAgICAgdmFyIGsgPSBzcGVjdHJhbFN0YXJ0O1xuICAgICAgdmFyIGUgPSBzcGVjdHJhbEVuZDtcbiAgICAgIHZhciByID0gMDtcbiAgICAgIHZhciBzO1xuICAgICAgdmFyIHJzO1xuICAgICAgd2hpbGUgKGsgPD0gZSkge1xuICAgICAgICBjb25zdCBvZmZzZXRaID0gYmxvY2tPZmZzZXQgKyBkY3RaaWdaYWdba107XG4gICAgICAgIGNvbnN0IHNpZ24gPSBjb21wb25lbnQuYmxvY2tEYXRhW29mZnNldFpdIDwgMCA/IC0xIDogMTtcbiAgICAgICAgc3dpdGNoIChzdWNjZXNzaXZlQUNTdGF0ZSkge1xuICAgICAgICAgIGNhc2UgMDogLy8gaW5pdGlhbCBzdGF0ZVxuICAgICAgICAgICAgcnMgPSBkZWNvZGVIdWZmbWFuKGNvbXBvbmVudC5odWZmbWFuVGFibGVBQyk7XG4gICAgICAgICAgICBzID0gcnMgJiAxNTtcbiAgICAgICAgICAgIHIgPSBycyA+PiA0O1xuICAgICAgICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgICAgICAgaWYgKHIgPCAxNSkge1xuICAgICAgICAgICAgICAgIGVvYnJ1biA9IHJlY2VpdmUocikgKyAoMSA8PCByKTtcbiAgICAgICAgICAgICAgICBzdWNjZXNzaXZlQUNTdGF0ZSA9IDQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgciA9IDE2O1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3NpdmVBQ1N0YXRlID0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHMgIT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSnBlZ0Vycm9yKFwiaW52YWxpZCBBQ24gZW5jb2RpbmdcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3VjY2Vzc2l2ZUFDTmV4dFZhbHVlID0gcmVjZWl2ZUFuZEV4dGVuZChzKTtcbiAgICAgICAgICAgICAgc3VjY2Vzc2l2ZUFDU3RhdGUgPSByID8gMiA6IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIDE6IC8vIHNraXBwaW5nIHIgemVybyBpdGVtc1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQuYmxvY2tEYXRhW29mZnNldFpdKSB7XG4gICAgICAgICAgICAgIGNvbXBvbmVudC5ibG9ja0RhdGFbb2Zmc2V0Wl0gKz0gc2lnbiAqIChyZWFkQml0KCkgPDwgc3VjY2Vzc2l2ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByLS07XG4gICAgICAgICAgICAgIGlmIChyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3VjY2Vzc2l2ZUFDU3RhdGUgPSBzdWNjZXNzaXZlQUNTdGF0ZSA9PT0gMiA/IDMgOiAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6IC8vIHNldCB2YWx1ZSBmb3IgYSB6ZXJvIGl0ZW1cbiAgICAgICAgICAgIGlmIChjb21wb25lbnQuYmxvY2tEYXRhW29mZnNldFpdKSB7XG4gICAgICAgICAgICAgIGNvbXBvbmVudC5ibG9ja0RhdGFbb2Zmc2V0Wl0gKz0gc2lnbiAqIChyZWFkQml0KCkgPDwgc3VjY2Vzc2l2ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb21wb25lbnQuYmxvY2tEYXRhW29mZnNldFpdID1cbiAgICAgICAgICAgICAgICBzdWNjZXNzaXZlQUNOZXh0VmFsdWUgPDwgc3VjY2Vzc2l2ZTtcbiAgICAgICAgICAgICAgc3VjY2Vzc2l2ZUFDU3RhdGUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0OiAvLyBlb2JcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQuYmxvY2tEYXRhW29mZnNldFpdKSB7XG4gICAgICAgICAgICAgIGNvbXBvbmVudC5ibG9ja0RhdGFbb2Zmc2V0Wl0gKz0gc2lnbiAqIChyZWFkQml0KCkgPDwgc3VjY2Vzc2l2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBrKys7XG4gICAgICB9XG4gICAgICBpZiAoc3VjY2Vzc2l2ZUFDU3RhdGUgPT09IDQpIHtcbiAgICAgICAgZW9icnVuLS07XG4gICAgICAgIGlmIChlb2JydW4gPT09IDApIHtcbiAgICAgICAgICBzdWNjZXNzaXZlQUNTdGF0ZSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgYmxvY2tSb3cgPSAwO1xuICAgIGZ1bmN0aW9uIGRlY29kZU1jdShjb21wb25lbnQsIGRlY29kZSwgbWN1LCByb3csIGNvbCkge1xuICAgICAgdmFyIG1jdVJvdyA9IChtY3UgLyBtY3VzUGVyTGluZSkgfCAwO1xuICAgICAgdmFyIG1jdUNvbCA9IG1jdSAlIG1jdXNQZXJMaW5lO1xuICAgICAgYmxvY2tSb3cgPSBtY3VSb3cgKiBjb21wb25lbnQudiArIHJvdztcbiAgICAgIHZhciBibG9ja0NvbCA9IG1jdUNvbCAqIGNvbXBvbmVudC5oICsgY29sO1xuICAgICAgY29uc3QgYmxvY2tPZmZzZXQgPSBnZXRCbG9ja0J1ZmZlck9mZnNldChjb21wb25lbnQsIGJsb2NrUm93LCBibG9ja0NvbCk7XG4gICAgICBkZWNvZGUoY29tcG9uZW50LCBibG9ja09mZnNldCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVjb2RlQmxvY2soY29tcG9uZW50LCBkZWNvZGUsIG1jdSkge1xuICAgICAgYmxvY2tSb3cgPSAobWN1IC8gY29tcG9uZW50LmJsb2Nrc1BlckxpbmUpIHwgMDtcbiAgICAgIHZhciBibG9ja0NvbCA9IG1jdSAlIGNvbXBvbmVudC5ibG9ja3NQZXJMaW5lO1xuICAgICAgY29uc3QgYmxvY2tPZmZzZXQgPSBnZXRCbG9ja0J1ZmZlck9mZnNldChjb21wb25lbnQsIGJsb2NrUm93LCBibG9ja0NvbCk7XG4gICAgICBkZWNvZGUoY29tcG9uZW50LCBibG9ja09mZnNldCk7XG4gICAgfVxuXG4gICAgdmFyIGNvbXBvbmVudHNMZW5ndGggPSBjb21wb25lbnRzLmxlbmd0aDtcbiAgICB2YXIgY29tcG9uZW50LCBpLCBqLCBrLCBuO1xuICAgIHZhciBkZWNvZGVGbjtcbiAgICBpZiAocHJvZ3Jlc3NpdmUpIHtcbiAgICAgIGlmIChzcGVjdHJhbFN0YXJ0ID09PSAwKSB7XG4gICAgICAgIGRlY29kZUZuID0gc3VjY2Vzc2l2ZVByZXYgPT09IDAgPyBkZWNvZGVEQ0ZpcnN0IDogZGVjb2RlRENTdWNjZXNzaXZlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVjb2RlRm4gPSBzdWNjZXNzaXZlUHJldiA9PT0gMCA/IGRlY29kZUFDRmlyc3QgOiBkZWNvZGVBQ1N1Y2Nlc3NpdmU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlY29kZUZuID0gZGVjb2RlQmFzZWxpbmU7XG4gICAgfVxuXG4gICAgdmFyIG1jdSA9IDAsXG4gICAgICBmaWxlTWFya2VyO1xuICAgIHZhciBtY3VFeHBlY3RlZDtcbiAgICBpZiAoY29tcG9uZW50c0xlbmd0aCA9PT0gMSkge1xuICAgICAgbWN1RXhwZWN0ZWQgPSBjb21wb25lbnRzWzBdLmJsb2Nrc1BlckxpbmUgKiBjb21wb25lbnRzWzBdLmJsb2Nrc1BlckNvbHVtbjtcbiAgICB9IGVsc2Uge1xuICAgICAgbWN1RXhwZWN0ZWQgPSBtY3VzUGVyTGluZSAqIGZyYW1lLm1jdXNQZXJDb2x1bW47XG4gICAgfVxuXG4gICAgdmFyIGgsIHY7XG4gICAgd2hpbGUgKG1jdSA8PSBtY3VFeHBlY3RlZCkge1xuICAgICAgLy8gcmVzZXQgaW50ZXJ2YWwgc3R1ZmZcbiAgICAgIHZhciBtY3VUb1JlYWQgPSByZXNldEludGVydmFsXG4gICAgICAgID8gTWF0aC5taW4obWN1RXhwZWN0ZWQgLSBtY3UsIHJlc2V0SW50ZXJ2YWwpXG4gICAgICAgIDogbWN1RXhwZWN0ZWQ7XG5cbiAgICAgIC8vIFRoZSBgbWN1VG9SZWFkID09PSAwYCBjYXNlIHNob3VsZCBvbmx5IG9jY3VyIHdoZW4gYWxsIG9mIHRoZSBleHBlY3RlZFxuICAgICAgLy8gTUNVIGRhdGEgaGFzIGJlZW4gYWxyZWFkeSBwYXJzZWQsIGkuZS4gd2hlbiBgbWN1ID09PSBtY3VFeHBlY3RlZGAsIGJ1dFxuICAgICAgLy8gc29tZSBjb3JydXB0IEpQRUcgaW1hZ2VzIGNvbnRhaW4gbW9yZSBkYXRhIHRoYW4gaW50ZW5kZWQgYW5kIHdlIHRodXNcbiAgICAgIC8vIHdhbnQgdG8gc2tpcCBvdmVyIGFueSBleHRyYSBSU1R4IG1hcmtlcnMgYmVsb3cgKGZpeGVzIGlzc3VlMTE3OTQucGRmKS5cbiAgICAgIGlmIChtY3VUb1JlYWQgPiAwKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb21wb25lbnRzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb21wb25lbnRzW2ldLnByZWQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVvYnJ1biA9IDA7XG5cbiAgICAgICAgaWYgKGNvbXBvbmVudHNMZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBjb21wb25lbnQgPSBjb21wb25lbnRzWzBdO1xuICAgICAgICAgIGZvciAobiA9IDA7IG4gPCBtY3VUb1JlYWQ7IG4rKykge1xuICAgICAgICAgICAgZGVjb2RlQmxvY2soY29tcG9uZW50LCBkZWNvZGVGbiwgbWN1KTtcbiAgICAgICAgICAgIG1jdSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgbWN1VG9SZWFkOyBuKyspIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb21wb25lbnRzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50c1tpXTtcbiAgICAgICAgICAgICAgaCA9IGNvbXBvbmVudC5oO1xuICAgICAgICAgICAgICB2ID0gY29tcG9uZW50LnY7XG4gICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB2OyBqKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgaDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICBkZWNvZGVNY3UoY29tcG9uZW50LCBkZWNvZGVGbiwgbWN1LCBqLCBrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1jdSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBmaW5kIG1hcmtlclxuICAgICAgYml0c0NvdW50ID0gMDtcbiAgICAgIGZpbGVNYXJrZXIgPSBmaW5kTmV4dEZpbGVNYXJrZXIoZGF0YSwgb2Zmc2V0KTtcbiAgICAgIGlmICghZmlsZU1hcmtlcikge1xuICAgICAgICBicmVhazsgLy8gUmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBpbWFnZSBkYXRhIHdpdGhvdXQgZmluZGluZyBhbnkgbWFya2VyLlxuICAgICAgfVxuICAgICAgaWYgKGZpbGVNYXJrZXIuaW52YWxpZCkge1xuICAgICAgICAvLyBTb21lIGJhZCBpbWFnZXMgc2VlbSB0byBwYWQgU2NhbiBibG9ja3Mgd2l0aCBlLmcuIHplcm8gYnl0ZXMsIHNraXBcbiAgICAgICAgLy8gcGFzdCB0aG9zZSB0byBhdHRlbXB0IHRvIGZpbmQgYSB2YWxpZCBtYXJrZXIgKGZpeGVzIGlzc3VlNDA5MC5wZGYpLlxuICAgICAgICBjb25zdCBwYXJ0aWFsTXNnID0gbWN1VG9SZWFkID4gMCA/IFwidW5leHBlY3RlZFwiIDogXCJleGNlc3NpdmVcIjtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgZGVjb2RlU2NhbiAtICR7cGFydGlhbE1zZ30gTUNVIGRhdGEsIGN1cnJlbnQgbWFya2VyIGlzOiAke2ZpbGVNYXJrZXIuaW52YWxpZH1gXG4gICAgICAgICk7XG4gICAgICAgIG9mZnNldCA9IGZpbGVNYXJrZXIub2Zmc2V0O1xuICAgICAgfVxuICAgICAgaWYgKGZpbGVNYXJrZXIubWFya2VyID49IDB4ZmZkMCAmJiBmaWxlTWFya2VyLm1hcmtlciA8PSAweGZmZDcpIHtcbiAgICAgICAgLy8gUlNUeFxuICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXQgLSBzdGFydE9mZnNldDtcbiAgfVxuXG4gIC8vIEEgcG9ydCBvZiBwb3BwbGVyJ3MgSURDVCBtZXRob2Qgd2hpY2ggaW4gdHVybiBpcyB0YWtlbiBmcm9tOlxuICAvLyAgIENocmlzdG9waCBMb2VmZmxlciwgQWRyaWFhbiBMaWd0ZW5iZXJnLCBHZW9yZ2UgUy4gTW9zY2h5dHosXG4gIC8vICAgJ1ByYWN0aWNhbCBGYXN0IDEtRCBEQ1QgQWxnb3JpdGhtcyB3aXRoIDExIE11bHRpcGxpY2F0aW9ucycsXG4gIC8vICAgSUVFRSBJbnRsLiBDb25mLiBvbiBBY291c3RpY3MsIFNwZWVjaCAmIFNpZ25hbCBQcm9jZXNzaW5nLCAxOTg5LFxuICAvLyAgIDk4OC05OTEuXG4gIGZ1bmN0aW9uIHF1YW50aXplQW5kSW52ZXJzZShjb21wb25lbnQsIGJsb2NrQnVmZmVyT2Zmc2V0LCBwKSB7XG4gICAgdmFyIHF0ID0gY29tcG9uZW50LnF1YW50aXphdGlvblRhYmxlLFxuICAgICAgYmxvY2tEYXRhID0gY29tcG9uZW50LmJsb2NrRGF0YTtcbiAgICB2YXIgdjAsIHYxLCB2MiwgdjMsIHY0LCB2NSwgdjYsIHY3O1xuICAgIHZhciBwMCwgcDEsIHAyLCBwMywgcDQsIHA1LCBwNiwgcDc7XG4gICAgdmFyIHQ7XG5cbiAgICBpZiAoIXF0KSB7XG4gICAgICB0aHJvdyBuZXcgSnBlZ0Vycm9yKFwibWlzc2luZyByZXF1aXJlZCBRdWFudGl6YXRpb24gVGFibGUuXCIpO1xuICAgIH1cblxuICAgIC8vIGludmVyc2UgRENUIG9uIHJvd3NcbiAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCA2NDsgcm93ICs9IDgpIHtcbiAgICAgIC8vIGdhdGhlciBibG9jayBkYXRhXG4gICAgICBwMCA9IGJsb2NrRGF0YVtibG9ja0J1ZmZlck9mZnNldCArIHJvd107XG4gICAgICBwMSA9IGJsb2NrRGF0YVtibG9ja0J1ZmZlck9mZnNldCArIHJvdyArIDFdO1xuICAgICAgcDIgPSBibG9ja0RhdGFbYmxvY2tCdWZmZXJPZmZzZXQgKyByb3cgKyAyXTtcbiAgICAgIHAzID0gYmxvY2tEYXRhW2Jsb2NrQnVmZmVyT2Zmc2V0ICsgcm93ICsgM107XG4gICAgICBwNCA9IGJsb2NrRGF0YVtibG9ja0J1ZmZlck9mZnNldCArIHJvdyArIDRdO1xuICAgICAgcDUgPSBibG9ja0RhdGFbYmxvY2tCdWZmZXJPZmZzZXQgKyByb3cgKyA1XTtcbiAgICAgIHA2ID0gYmxvY2tEYXRhW2Jsb2NrQnVmZmVyT2Zmc2V0ICsgcm93ICsgNl07XG4gICAgICBwNyA9IGJsb2NrRGF0YVtibG9ja0J1ZmZlck9mZnNldCArIHJvdyArIDddO1xuXG4gICAgICAvLyBkZXF1YW50IHAwXG4gICAgICBwMCAqPSBxdFtyb3ddO1xuXG4gICAgICAvLyBjaGVjayBmb3IgYWxsLXplcm8gQUMgY29lZmZpY2llbnRzXG4gICAgICBpZiAoKHAxIHwgcDIgfCBwMyB8IHA0IHwgcDUgfCBwNiB8IHA3KSA9PT0gMCkge1xuICAgICAgICB0ID0gKGRjdFNxcnQyICogcDAgKyA1MTIpID4+IDEwO1xuICAgICAgICBwW3Jvd10gPSB0O1xuICAgICAgICBwW3JvdyArIDFdID0gdDtcbiAgICAgICAgcFtyb3cgKyAyXSA9IHQ7XG4gICAgICAgIHBbcm93ICsgM10gPSB0O1xuICAgICAgICBwW3JvdyArIDRdID0gdDtcbiAgICAgICAgcFtyb3cgKyA1XSA9IHQ7XG4gICAgICAgIHBbcm93ICsgNl0gPSB0O1xuICAgICAgICBwW3JvdyArIDddID0gdDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBkZXF1YW50IHAxIC4uLiBwN1xuICAgICAgcDEgKj0gcXRbcm93ICsgMV07XG4gICAgICBwMiAqPSBxdFtyb3cgKyAyXTtcbiAgICAgIHAzICo9IHF0W3JvdyArIDNdO1xuICAgICAgcDQgKj0gcXRbcm93ICsgNF07XG4gICAgICBwNSAqPSBxdFtyb3cgKyA1XTtcbiAgICAgIHA2ICo9IHF0W3JvdyArIDZdO1xuICAgICAgcDcgKj0gcXRbcm93ICsgN107XG5cbiAgICAgIC8vIHN0YWdlIDRcbiAgICAgIHYwID0gKGRjdFNxcnQyICogcDAgKyAxMjgpID4+IDg7XG4gICAgICB2MSA9IChkY3RTcXJ0MiAqIHA0ICsgMTI4KSA+PiA4O1xuICAgICAgdjIgPSBwMjtcbiAgICAgIHYzID0gcDY7XG4gICAgICB2NCA9IChkY3RTcXJ0MWQyICogKHAxIC0gcDcpICsgMTI4KSA+PiA4O1xuICAgICAgdjcgPSAoZGN0U3FydDFkMiAqIChwMSArIHA3KSArIDEyOCkgPj4gODtcbiAgICAgIHY1ID0gcDMgPDwgNDtcbiAgICAgIHY2ID0gcDUgPDwgNDtcblxuICAgICAgLy8gc3RhZ2UgM1xuICAgICAgdjAgPSAodjAgKyB2MSArIDEpID4+IDE7XG4gICAgICB2MSA9IHYwIC0gdjE7XG4gICAgICB0ID0gKHYyICogZGN0U2luNiArIHYzICogZGN0Q29zNiArIDEyOCkgPj4gODtcbiAgICAgIHYyID0gKHYyICogZGN0Q29zNiAtIHYzICogZGN0U2luNiArIDEyOCkgPj4gODtcbiAgICAgIHYzID0gdDtcbiAgICAgIHY0ID0gKHY0ICsgdjYgKyAxKSA+PiAxO1xuICAgICAgdjYgPSB2NCAtIHY2O1xuICAgICAgdjcgPSAodjcgKyB2NSArIDEpID4+IDE7XG4gICAgICB2NSA9IHY3IC0gdjU7XG5cbiAgICAgIC8vIHN0YWdlIDJcbiAgICAgIHYwID0gKHYwICsgdjMgKyAxKSA+PiAxO1xuICAgICAgdjMgPSB2MCAtIHYzO1xuICAgICAgdjEgPSAodjEgKyB2MiArIDEpID4+IDE7XG4gICAgICB2MiA9IHYxIC0gdjI7XG4gICAgICB0ID0gKHY0ICogZGN0U2luMyArIHY3ICogZGN0Q29zMyArIDIwNDgpID4+IDEyO1xuICAgICAgdjQgPSAodjQgKiBkY3RDb3MzIC0gdjcgKiBkY3RTaW4zICsgMjA0OCkgPj4gMTI7XG4gICAgICB2NyA9IHQ7XG4gICAgICB0ID0gKHY1ICogZGN0U2luMSArIHY2ICogZGN0Q29zMSArIDIwNDgpID4+IDEyO1xuICAgICAgdjUgPSAodjUgKiBkY3RDb3MxIC0gdjYgKiBkY3RTaW4xICsgMjA0OCkgPj4gMTI7XG4gICAgICB2NiA9IHQ7XG5cbiAgICAgIC8vIHN0YWdlIDFcbiAgICAgIHBbcm93XSA9IHYwICsgdjc7XG4gICAgICBwW3JvdyArIDddID0gdjAgLSB2NztcbiAgICAgIHBbcm93ICsgMV0gPSB2MSArIHY2O1xuICAgICAgcFtyb3cgKyA2XSA9IHYxIC0gdjY7XG4gICAgICBwW3JvdyArIDJdID0gdjIgKyB2NTtcbiAgICAgIHBbcm93ICsgNV0gPSB2MiAtIHY1O1xuICAgICAgcFtyb3cgKyAzXSA9IHYzICsgdjQ7XG4gICAgICBwW3JvdyArIDRdID0gdjMgLSB2NDtcbiAgICB9XG5cbiAgICAvLyBpbnZlcnNlIERDVCBvbiBjb2x1bW5zXG4gICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgODsgKytjb2wpIHtcbiAgICAgIHAwID0gcFtjb2xdO1xuICAgICAgcDEgPSBwW2NvbCArIDhdO1xuICAgICAgcDIgPSBwW2NvbCArIDE2XTtcbiAgICAgIHAzID0gcFtjb2wgKyAyNF07XG4gICAgICBwNCA9IHBbY29sICsgMzJdO1xuICAgICAgcDUgPSBwW2NvbCArIDQwXTtcbiAgICAgIHA2ID0gcFtjb2wgKyA0OF07XG4gICAgICBwNyA9IHBbY29sICsgNTZdO1xuXG4gICAgICAvLyBjaGVjayBmb3IgYWxsLXplcm8gQUMgY29lZmZpY2llbnRzXG4gICAgICBpZiAoKHAxIHwgcDIgfCBwMyB8IHA0IHwgcDUgfCBwNiB8IHA3KSA9PT0gMCkge1xuICAgICAgICB0ID0gKGRjdFNxcnQyICogcDAgKyA4MTkyKSA+PiAxNDtcbiAgICAgICAgLy8gQ29udmVydCB0byA4LWJpdC5cbiAgICAgICAgaWYgKHQgPCAtMjA0MCkge1xuICAgICAgICAgIHQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKHQgPj0gMjAyNCkge1xuICAgICAgICAgIHQgPSAyNTU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdCA9ICh0ICsgMjA1NikgPj4gNDtcbiAgICAgICAgfVxuICAgICAgICBibG9ja0RhdGFbYmxvY2tCdWZmZXJPZmZzZXQgKyBjb2xdID0gdDtcbiAgICAgICAgYmxvY2tEYXRhW2Jsb2NrQnVmZmVyT2Zmc2V0ICsgY29sICsgOF0gPSB0O1xuICAgICAgICBibG9ja0RhdGFbYmxvY2tCdWZmZXJPZmZzZXQgKyBjb2wgKyAxNl0gPSB0O1xuICAgICAgICBibG9ja0RhdGFbYmxvY2tCdWZmZXJPZmZzZXQgKyBjb2wgKyAyNF0gPSB0O1xuICAgICAgICBibG9ja0RhdGFbYmxvY2tCdWZmZXJPZmZzZXQgKyBjb2wgKyAzMl0gPSB0O1xuICAgICAgICBibG9ja0RhdGFbYmxvY2tCdWZmZXJPZmZzZXQgKyBjb2wgKyA0MF0gPSB0O1xuICAgICAgICBibG9ja0RhdGFbYmxvY2tCdWZmZXJPZmZzZXQgKyBjb2wgKyA0OF0gPSB0O1xuICAgICAgICBibG9ja0RhdGFbYmxvY2tCdWZmZXJPZmZzZXQgKyBjb2wgKyA1Nl0gPSB0O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gc3RhZ2UgNFxuICAgICAgdjAgPSAoZGN0U3FydDIgKiBwMCArIDIwNDgpID4+IDEyO1xuICAgICAgdjEgPSAoZGN0U3FydDIgKiBwNCArIDIwNDgpID4+IDEyO1xuICAgICAgdjIgPSBwMjtcbiAgICAgIHYzID0gcDY7XG4gICAgICB2NCA9IChkY3RTcXJ0MWQyICogKHAxIC0gcDcpICsgMjA0OCkgPj4gMTI7XG4gICAgICB2NyA9IChkY3RTcXJ0MWQyICogKHAxICsgcDcpICsgMjA0OCkgPj4gMTI7XG4gICAgICB2NSA9IHAzO1xuICAgICAgdjYgPSBwNTtcblxuICAgICAgLy8gc3RhZ2UgM1xuICAgICAgLy8gU2hpZnQgdjAgYnkgMTI4LjUgPDwgNSBoZXJlLCBzbyB3ZSBkb24ndCBuZWVkIHRvIHNoaWZ0IHAwLi4ucDcgd2hlblxuICAgICAgLy8gY29udmVydGluZyB0byBVSW50OCByYW5nZSBsYXRlci5cbiAgICAgIHYwID0gKCh2MCArIHYxICsgMSkgPj4gMSkgKyA0MTEyO1xuICAgICAgdjEgPSB2MCAtIHYxO1xuICAgICAgdCA9ICh2MiAqIGRjdFNpbjYgKyB2MyAqIGRjdENvczYgKyAyMDQ4KSA+PiAxMjtcbiAgICAgIHYyID0gKHYyICogZGN0Q29zNiAtIHYzICogZGN0U2luNiArIDIwNDgpID4+IDEyO1xuICAgICAgdjMgPSB0O1xuICAgICAgdjQgPSAodjQgKyB2NiArIDEpID4+IDE7XG4gICAgICB2NiA9IHY0IC0gdjY7XG4gICAgICB2NyA9ICh2NyArIHY1ICsgMSkgPj4gMTtcbiAgICAgIHY1ID0gdjcgLSB2NTtcblxuICAgICAgLy8gc3RhZ2UgMlxuICAgICAgdjAgPSAodjAgKyB2MyArIDEpID4+IDE7XG4gICAgICB2MyA9IHYwIC0gdjM7XG4gICAgICB2MSA9ICh2MSArIHYyICsgMSkgPj4gMTtcbiAgICAgIHYyID0gdjEgLSB2MjtcbiAgICAgIHQgPSAodjQgKiBkY3RTaW4zICsgdjcgKiBkY3RDb3MzICsgMjA0OCkgPj4gMTI7XG4gICAgICB2NCA9ICh2NCAqIGRjdENvczMgLSB2NyAqIGRjdFNpbjMgKyAyMDQ4KSA+PiAxMjtcbiAgICAgIHY3ID0gdDtcbiAgICAgIHQgPSAodjUgKiBkY3RTaW4xICsgdjYgKiBkY3RDb3MxICsgMjA0OCkgPj4gMTI7XG4gICAgICB2NSA9ICh2NSAqIGRjdENvczEgLSB2NiAqIGRjdFNpbjEgKyAyMDQ4KSA+PiAxMjtcbiAgICAgIHY2ID0gdDtcblxuICAgICAgLy8gc3RhZ2UgMVxuICAgICAgcDAgPSB2MCArIHY3O1xuICAgICAgcDcgPSB2MCAtIHY3O1xuICAgICAgcDEgPSB2MSArIHY2O1xuICAgICAgcDYgPSB2MSAtIHY2O1xuICAgICAgcDIgPSB2MiArIHY1O1xuICAgICAgcDUgPSB2MiAtIHY1O1xuICAgICAgcDMgPSB2MyArIHY0O1xuICAgICAgcDQgPSB2MyAtIHY0O1xuXG4gICAgICAvLyBDb252ZXJ0IHRvIDgtYml0IGludGVnZXJzLlxuICAgICAgaWYgKHAwIDwgMTYpIHtcbiAgICAgICAgcDAgPSAwO1xuICAgICAgfSBlbHNlIGlmIChwMCA+PSA0MDgwKSB7XG4gICAgICAgIHAwID0gMjU1O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcDAgPj49IDQ7XG4gICAgICB9XG4gICAgICBpZiAocDEgPCAxNikge1xuICAgICAgICBwMSA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHAxID49IDQwODApIHtcbiAgICAgICAgcDEgPSAyNTU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwMSA+Pj0gNDtcbiAgICAgIH1cbiAgICAgIGlmIChwMiA8IDE2KSB7XG4gICAgICAgIHAyID0gMDtcbiAgICAgIH0gZWxzZSBpZiAocDIgPj0gNDA4MCkge1xuICAgICAgICBwMiA9IDI1NTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHAyID4+PSA0O1xuICAgICAgfVxuICAgICAgaWYgKHAzIDwgMTYpIHtcbiAgICAgICAgcDMgPSAwO1xuICAgICAgfSBlbHNlIGlmIChwMyA+PSA0MDgwKSB7XG4gICAgICAgIHAzID0gMjU1O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcDMgPj49IDQ7XG4gICAgICB9XG4gICAgICBpZiAocDQgPCAxNikge1xuICAgICAgICBwNCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHA0ID49IDQwODApIHtcbiAgICAgICAgcDQgPSAyNTU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwNCA+Pj0gNDtcbiAgICAgIH1cbiAgICAgIGlmIChwNSA8IDE2KSB7XG4gICAgICAgIHA1ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAocDUgPj0gNDA4MCkge1xuICAgICAgICBwNSA9IDI1NTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHA1ID4+PSA0O1xuICAgICAgfVxuICAgICAgaWYgKHA2IDwgMTYpIHtcbiAgICAgICAgcDYgPSAwO1xuICAgICAgfSBlbHNlIGlmIChwNiA+PSA0MDgwKSB7XG4gICAgICAgIHA2ID0gMjU1O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcDYgPj49IDQ7XG4gICAgICB9XG4gICAgICBpZiAocDcgPCAxNikge1xuICAgICAgICBwNyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHA3ID49IDQwODApIHtcbiAgICAgICAgcDcgPSAyNTU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwNyA+Pj0gNDtcbiAgICAgIH1cblxuICAgICAgLy8gc3RvcmUgYmxvY2sgZGF0YVxuICAgICAgYmxvY2tEYXRhW2Jsb2NrQnVmZmVyT2Zmc2V0ICsgY29sXSA9IHAwO1xuICAgICAgYmxvY2tEYXRhW2Jsb2NrQnVmZmVyT2Zmc2V0ICsgY29sICsgOF0gPSBwMTtcbiAgICAgIGJsb2NrRGF0YVtibG9ja0J1ZmZlck9mZnNldCArIGNvbCArIDE2XSA9IHAyO1xuICAgICAgYmxvY2tEYXRhW2Jsb2NrQnVmZmVyT2Zmc2V0ICsgY29sICsgMjRdID0gcDM7XG4gICAgICBibG9ja0RhdGFbYmxvY2tCdWZmZXJPZmZzZXQgKyBjb2wgKyAzMl0gPSBwNDtcbiAgICAgIGJsb2NrRGF0YVtibG9ja0J1ZmZlck9mZnNldCArIGNvbCArIDQwXSA9IHA1O1xuICAgICAgYmxvY2tEYXRhW2Jsb2NrQnVmZmVyT2Zmc2V0ICsgY29sICsgNDhdID0gcDY7XG4gICAgICBibG9ja0RhdGFbYmxvY2tCdWZmZXJPZmZzZXQgKyBjb2wgKyA1Nl0gPSBwNztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBidWlsZENvbXBvbmVudERhdGEoZnJhbWUsIGNvbXBvbmVudCkge1xuICAgIHZhciBibG9ja3NQZXJMaW5lID0gY29tcG9uZW50LmJsb2Nrc1BlckxpbmU7XG4gICAgdmFyIGJsb2Nrc1BlckNvbHVtbiA9IGNvbXBvbmVudC5ibG9ja3NQZXJDb2x1bW47XG4gICAgdmFyIGNvbXB1dGF0aW9uQnVmZmVyID0gbmV3IEludDE2QXJyYXkoNjQpO1xuXG4gICAgZm9yICh2YXIgYmxvY2tSb3cgPSAwOyBibG9ja1JvdyA8IGJsb2Nrc1BlckNvbHVtbjsgYmxvY2tSb3crKykge1xuICAgICAgZm9yICh2YXIgYmxvY2tDb2wgPSAwOyBibG9ja0NvbCA8IGJsb2Nrc1BlckxpbmU7IGJsb2NrQ29sKyspIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IGdldEJsb2NrQnVmZmVyT2Zmc2V0KGNvbXBvbmVudCwgYmxvY2tSb3csIGJsb2NrQ29sKTtcbiAgICAgICAgcXVhbnRpemVBbmRJbnZlcnNlKGNvbXBvbmVudCwgb2Zmc2V0LCBjb21wdXRhdGlvbkJ1ZmZlcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb21wb25lbnQuYmxvY2tEYXRhO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZE5leHRGaWxlTWFya2VyKGRhdGEsIGN1cnJlbnRQb3MsIHN0YXJ0UG9zID0gY3VycmVudFBvcykge1xuICAgIGNvbnN0IG1heFBvcyA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgICB2YXIgbmV3UG9zID0gc3RhcnRQb3MgPCBjdXJyZW50UG9zID8gc3RhcnRQb3MgOiBjdXJyZW50UG9zO1xuXG4gICAgaWYgKGN1cnJlbnRQb3MgPj0gbWF4UG9zKSB7XG4gICAgICByZXR1cm4gbnVsbDsgLy8gRG9uJ3QgYXR0ZW1wdCB0byByZWFkIG5vbi1leGlzdGVudCBkYXRhIGFuZCBqdXN0IHJldHVybi5cbiAgICB9XG4gICAgdmFyIGN1cnJlbnRNYXJrZXIgPSByZWFkVWludDE2KGRhdGEsIGN1cnJlbnRQb3MpO1xuICAgIGlmIChjdXJyZW50TWFya2VyID49IDB4ZmZjMCAmJiBjdXJyZW50TWFya2VyIDw9IDB4ZmZmZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW52YWxpZDogbnVsbCxcbiAgICAgICAgbWFya2VyOiBjdXJyZW50TWFya2VyLFxuICAgICAgICBvZmZzZXQ6IGN1cnJlbnRQb3MsXG4gICAgICB9O1xuICAgIH1cbiAgICB2YXIgbmV3TWFya2VyID0gcmVhZFVpbnQxNihkYXRhLCBuZXdQb3MpO1xuICAgIHdoaWxlICghKG5ld01hcmtlciA+PSAweGZmYzAgJiYgbmV3TWFya2VyIDw9IDB4ZmZmZSkpIHtcbiAgICAgIGlmICgrK25ld1BvcyA+PSBtYXhQb3MpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7IC8vIERvbid0IGF0dGVtcHQgdG8gcmVhZCBub24tZXhpc3RlbnQgZGF0YSBhbmQganVzdCByZXR1cm4uXG4gICAgICB9XG4gICAgICBuZXdNYXJrZXIgPSByZWFkVWludDE2KGRhdGEsIG5ld1Bvcyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBpbnZhbGlkOiBjdXJyZW50TWFya2VyLnRvU3RyaW5nKDE2KSxcbiAgICAgIG1hcmtlcjogbmV3TWFya2VyLFxuICAgICAgb2Zmc2V0OiBuZXdQb3MsXG4gICAgfTtcbiAgfVxuXG4gIEpwZWdJbWFnZS5wcm90b3R5cGUgPSB7XG4gICAgcGFyc2UoZGF0YSwgeyBkbmxTY2FuTGluZXMgPSBudWxsIH0gPSB7fSkge1xuICAgICAgZnVuY3Rpb24gcmVhZERhdGFCbG9jaygpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gcmVhZFVpbnQxNihkYXRhLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgICAgbGV0IGVuZE9mZnNldCA9IG9mZnNldCArIGxlbmd0aCAtIDI7XG5cbiAgICAgICAgdmFyIGZpbGVNYXJrZXIgPSBmaW5kTmV4dEZpbGVNYXJrZXIoZGF0YSwgZW5kT2Zmc2V0LCBvZmZzZXQpO1xuICAgICAgICBpZiAoZmlsZU1hcmtlciAmJiBmaWxlTWFya2VyLmludmFsaWQpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJyZWFkRGF0YUJsb2NrIC0gaW5jb3JyZWN0IGxlbmd0aCwgY3VycmVudCBtYXJrZXIgaXM6IFwiICtcbiAgICAgICAgICAgICAgZmlsZU1hcmtlci5pbnZhbGlkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBlbmRPZmZzZXQgPSBmaWxlTWFya2VyLm9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhcnJheSA9IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBlbmRPZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gYXJyYXkubGVuZ3RoO1xuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHByZXBhcmVDb21wb25lbnRzKGZyYW1lKSB7XG4gICAgICAgIHZhciBtY3VzUGVyTGluZSA9IE1hdGguY2VpbChmcmFtZS5zYW1wbGVzUGVyTGluZSAvIDggLyBmcmFtZS5tYXhIKTtcbiAgICAgICAgdmFyIG1jdXNQZXJDb2x1bW4gPSBNYXRoLmNlaWwoZnJhbWUuc2NhbkxpbmVzIC8gOCAvIGZyYW1lLm1heFYpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lLmNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb21wb25lbnQgPSBmcmFtZS5jb21wb25lbnRzW2ldO1xuICAgICAgICAgIHZhciBibG9ja3NQZXJMaW5lID0gTWF0aC5jZWlsKFxuICAgICAgICAgICAgKE1hdGguY2VpbChmcmFtZS5zYW1wbGVzUGVyTGluZSAvIDgpICogY29tcG9uZW50LmgpIC8gZnJhbWUubWF4SFxuICAgICAgICAgICk7XG4gICAgICAgICAgdmFyIGJsb2Nrc1BlckNvbHVtbiA9IE1hdGguY2VpbChcbiAgICAgICAgICAgIChNYXRoLmNlaWwoZnJhbWUuc2NhbkxpbmVzIC8gOCkgKiBjb21wb25lbnQudikgLyBmcmFtZS5tYXhWXG4gICAgICAgICAgKTtcbiAgICAgICAgICB2YXIgYmxvY2tzUGVyTGluZUZvck1jdSA9IG1jdXNQZXJMaW5lICogY29tcG9uZW50Lmg7XG4gICAgICAgICAgdmFyIGJsb2Nrc1BlckNvbHVtbkZvck1jdSA9IG1jdXNQZXJDb2x1bW4gKiBjb21wb25lbnQudjtcblxuICAgICAgICAgIHZhciBibG9ja3NCdWZmZXJTaXplID1cbiAgICAgICAgICAgIDY0ICogYmxvY2tzUGVyQ29sdW1uRm9yTWN1ICogKGJsb2Nrc1BlckxpbmVGb3JNY3UgKyAxKTtcbiAgICAgICAgICBjb21wb25lbnQuYmxvY2tEYXRhID0gbmV3IEludDE2QXJyYXkoYmxvY2tzQnVmZmVyU2l6ZSk7XG4gICAgICAgICAgY29tcG9uZW50LmJsb2Nrc1BlckxpbmUgPSBibG9ja3NQZXJMaW5lO1xuICAgICAgICAgIGNvbXBvbmVudC5ibG9ja3NQZXJDb2x1bW4gPSBibG9ja3NQZXJDb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgZnJhbWUubWN1c1BlckxpbmUgPSBtY3VzUGVyTGluZTtcbiAgICAgICAgZnJhbWUubWN1c1BlckNvbHVtbiA9IG1jdXNQZXJDb2x1bW47XG4gICAgICB9XG5cbiAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgdmFyIGpmaWYgPSBudWxsO1xuICAgICAgdmFyIGFkb2JlID0gbnVsbDtcbiAgICAgIHZhciBmcmFtZSwgcmVzZXRJbnRlcnZhbDtcbiAgICAgIGxldCBudW1TT1NNYXJrZXJzID0gMDtcbiAgICAgIHZhciBxdWFudGl6YXRpb25UYWJsZXMgPSBbXTtcbiAgICAgIHZhciBodWZmbWFuVGFibGVzQUMgPSBbXSxcbiAgICAgICAgaHVmZm1hblRhYmxlc0RDID0gW107XG5cbiAgICAgIGxldCBmaWxlTWFya2VyID0gcmVhZFVpbnQxNihkYXRhLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICBpZiAoZmlsZU1hcmtlciAhPT0gLyogU09JIChTdGFydCBvZiBJbWFnZSkgPSAqLyAweGZmZDgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpwZWdFcnJvcihcIlNPSSBub3QgZm91bmRcIik7XG4gICAgICB9XG4gICAgICBmaWxlTWFya2VyID0gcmVhZFVpbnQxNihkYXRhLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IDI7XG5cbiAgICAgIG1hcmtlckxvb3A6IHdoaWxlIChmaWxlTWFya2VyICE9PSAvKiBFT0kgKEVuZCBvZiBJbWFnZSkgPSAqLyAweGZmZDkpIHtcbiAgICAgICAgdmFyIGksIGosIGw7XG4gICAgICAgIHN3aXRjaCAoZmlsZU1hcmtlcikge1xuICAgICAgICAgIGNhc2UgMHhmZmUwOiAvLyBBUFAwIChBcHBsaWNhdGlvbiBTcGVjaWZpYylcbiAgICAgICAgICBjYXNlIDB4ZmZlMTogLy8gQVBQMVxuICAgICAgICAgIGNhc2UgMHhmZmUyOiAvLyBBUFAyXG4gICAgICAgICAgY2FzZSAweGZmZTM6IC8vIEFQUDNcbiAgICAgICAgICBjYXNlIDB4ZmZlNDogLy8gQVBQNFxuICAgICAgICAgIGNhc2UgMHhmZmU1OiAvLyBBUFA1XG4gICAgICAgICAgY2FzZSAweGZmZTY6IC8vIEFQUDZcbiAgICAgICAgICBjYXNlIDB4ZmZlNzogLy8gQVBQN1xuICAgICAgICAgIGNhc2UgMHhmZmU4OiAvLyBBUFA4XG4gICAgICAgICAgY2FzZSAweGZmZTk6IC8vIEFQUDlcbiAgICAgICAgICBjYXNlIDB4ZmZlYTogLy8gQVBQMTBcbiAgICAgICAgICBjYXNlIDB4ZmZlYjogLy8gQVBQMTFcbiAgICAgICAgICBjYXNlIDB4ZmZlYzogLy8gQVBQMTJcbiAgICAgICAgICBjYXNlIDB4ZmZlZDogLy8gQVBQMTNcbiAgICAgICAgICBjYXNlIDB4ZmZlZTogLy8gQVBQMTRcbiAgICAgICAgICBjYXNlIDB4ZmZlZjogLy8gQVBQMTVcbiAgICAgICAgICBjYXNlIDB4ZmZmZTogLy8gQ09NIChDb21tZW50KVxuICAgICAgICAgICAgdmFyIGFwcERhdGEgPSByZWFkRGF0YUJsb2NrKCk7XG5cbiAgICAgICAgICAgIGlmIChmaWxlTWFya2VyID09PSAweGZmZTApIHtcbiAgICAgICAgICAgICAgLy8gJ0pGSUZcXHgwMCdcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGFwcERhdGFbMF0gPT09IDB4NGEgJiZcbiAgICAgICAgICAgICAgICBhcHBEYXRhWzFdID09PSAweDQ2ICYmXG4gICAgICAgICAgICAgICAgYXBwRGF0YVsyXSA9PT0gMHg0OSAmJlxuICAgICAgICAgICAgICAgIGFwcERhdGFbM10gPT09IDB4NDYgJiZcbiAgICAgICAgICAgICAgICBhcHBEYXRhWzRdID09PSAwXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGpmaWYgPSB7XG4gICAgICAgICAgICAgICAgICB2ZXJzaW9uOiB7IG1ham9yOiBhcHBEYXRhWzVdLCBtaW5vcjogYXBwRGF0YVs2XSB9LFxuICAgICAgICAgICAgICAgICAgZGVuc2l0eVVuaXRzOiBhcHBEYXRhWzddLFxuICAgICAgICAgICAgICAgICAgeERlbnNpdHk6IChhcHBEYXRhWzhdIDw8IDgpIHwgYXBwRGF0YVs5XSxcbiAgICAgICAgICAgICAgICAgIHlEZW5zaXR5OiAoYXBwRGF0YVsxMF0gPDwgOCkgfCBhcHBEYXRhWzExXSxcbiAgICAgICAgICAgICAgICAgIHRodW1iV2lkdGg6IGFwcERhdGFbMTJdLFxuICAgICAgICAgICAgICAgICAgdGh1bWJIZWlnaHQ6IGFwcERhdGFbMTNdLFxuICAgICAgICAgICAgICAgICAgdGh1bWJEYXRhOiBhcHBEYXRhLnN1YmFycmF5KFxuICAgICAgICAgICAgICAgICAgICAxNCxcbiAgICAgICAgICAgICAgICAgICAgMTQgKyAzICogYXBwRGF0YVsxMl0gKiBhcHBEYXRhWzEzXVxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPIEFQUDEgLSBFeGlmXG4gICAgICAgICAgICBpZiAoZmlsZU1hcmtlciA9PT0gMHhmZmVlKSB7XG4gICAgICAgICAgICAgIC8vICdBZG9iZSdcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGFwcERhdGFbMF0gPT09IDB4NDEgJiZcbiAgICAgICAgICAgICAgICBhcHBEYXRhWzFdID09PSAweDY0ICYmXG4gICAgICAgICAgICAgICAgYXBwRGF0YVsyXSA9PT0gMHg2ZiAmJlxuICAgICAgICAgICAgICAgIGFwcERhdGFbM10gPT09IDB4NjIgJiZcbiAgICAgICAgICAgICAgICBhcHBEYXRhWzRdID09PSAweDY1XG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGFkb2JlID0ge1xuICAgICAgICAgICAgICAgICAgdmVyc2lvbjogKGFwcERhdGFbNV0gPDwgOCkgfCBhcHBEYXRhWzZdLFxuICAgICAgICAgICAgICAgICAgZmxhZ3MwOiAoYXBwRGF0YVs3XSA8PCA4KSB8IGFwcERhdGFbOF0sXG4gICAgICAgICAgICAgICAgICBmbGFnczE6IChhcHBEYXRhWzldIDw8IDgpIHwgYXBwRGF0YVsxMF0sXG4gICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1Db2RlOiBhcHBEYXRhWzExXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMHhmZmRiOiAvLyBEUVQgKERlZmluZSBRdWFudGl6YXRpb24gVGFibGVzKVxuICAgICAgICAgICAgY29uc3QgcXVhbnRpemF0aW9uVGFibGVzTGVuZ3RoID0gcmVhZFVpbnQxNihkYXRhLCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgICAgICB2YXIgcXVhbnRpemF0aW9uVGFibGVzRW5kID0gcXVhbnRpemF0aW9uVGFibGVzTGVuZ3RoICsgb2Zmc2V0IC0gMjtcbiAgICAgICAgICAgIHZhciB6O1xuICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IHF1YW50aXphdGlvblRhYmxlc0VuZCkge1xuICAgICAgICAgICAgICB2YXIgcXVhbnRpemF0aW9uVGFibGVTcGVjID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgICAgIHZhciB0YWJsZURhdGEgPSBuZXcgVWludDE2QXJyYXkoNjQpO1xuICAgICAgICAgICAgICBpZiAocXVhbnRpemF0aW9uVGFibGVTcGVjID4+IDQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyA4IGJpdCB2YWx1ZXNcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgNjQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgeiA9IGRjdFppZ1phZ1tqXTtcbiAgICAgICAgICAgICAgICAgIHRhYmxlRGF0YVt6XSA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChxdWFudGl6YXRpb25UYWJsZVNwZWMgPj4gNCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIDE2IGJpdCB2YWx1ZXNcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgNjQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgeiA9IGRjdFppZ1phZ1tqXTtcbiAgICAgICAgICAgICAgICAgIHRhYmxlRGF0YVt6XSA9IHJlYWRVaW50MTYoZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgIG9mZnNldCArPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSnBlZ0Vycm9yKFwiRFFUIC0gaW52YWxpZCB0YWJsZSBzcGVjXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHF1YW50aXphdGlvblRhYmxlc1txdWFudGl6YXRpb25UYWJsZVNwZWMgJiAxNV0gPSB0YWJsZURhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMHhmZmMwOiAvLyBTT0YwIChTdGFydCBvZiBGcmFtZSwgQmFzZWxpbmUgRENUKVxuICAgICAgICAgIGNhc2UgMHhmZmMxOiAvLyBTT0YxIChTdGFydCBvZiBGcmFtZSwgRXh0ZW5kZWQgRENUKVxuICAgICAgICAgIGNhc2UgMHhmZmMyOiAvLyBTT0YyIChTdGFydCBvZiBGcmFtZSwgUHJvZ3Jlc3NpdmUgRENUKVxuICAgICAgICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBKcGVnRXJyb3IoXCJPbmx5IHNpbmdsZSBmcmFtZSBKUEVHcyBzdXBwb3J0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgKz0gMjsgLy8gU2tpcCBtYXJrZXIgbGVuZ3RoLlxuXG4gICAgICAgICAgICBmcmFtZSA9IHt9O1xuICAgICAgICAgICAgZnJhbWUuZXh0ZW5kZWQgPSBmaWxlTWFya2VyID09PSAweGZmYzE7XG4gICAgICAgICAgICBmcmFtZS5wcm9ncmVzc2l2ZSA9IGZpbGVNYXJrZXIgPT09IDB4ZmZjMjtcbiAgICAgICAgICAgIGZyYW1lLnByZWNpc2lvbiA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgICAgY29uc3Qgc29mU2NhbkxpbmVzID0gcmVhZFVpbnQxNihkYXRhLCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgICAgICBmcmFtZS5zY2FuTGluZXMgPSBkbmxTY2FuTGluZXMgfHwgc29mU2NhbkxpbmVzO1xuICAgICAgICAgICAgZnJhbWUuc2FtcGxlc1BlckxpbmUgPSByZWFkVWludDE2KGRhdGEsIG9mZnNldCk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgICAgICAgIGZyYW1lLmNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgICAgIGZyYW1lLmNvbXBvbmVudElkcyA9IHt9O1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudHNDb3VudCA9IGRhdGFbb2Zmc2V0KytdLFxuICAgICAgICAgICAgICBjb21wb25lbnRJZDtcbiAgICAgICAgICAgIHZhciBtYXhIID0gMCxcbiAgICAgICAgICAgICAgbWF4ViA9IDA7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29tcG9uZW50c0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgY29tcG9uZW50SWQgPSBkYXRhW29mZnNldF07XG4gICAgICAgICAgICAgIHZhciBoID0gZGF0YVtvZmZzZXQgKyAxXSA+PiA0O1xuICAgICAgICAgICAgICB2YXIgdiA9IGRhdGFbb2Zmc2V0ICsgMV0gJiAxNTtcbiAgICAgICAgICAgICAgaWYgKG1heEggPCBoKSB7XG4gICAgICAgICAgICAgICAgbWF4SCA9IGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG1heFYgPCB2KSB7XG4gICAgICAgICAgICAgICAgbWF4ViA9IHY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHFJZCA9IGRhdGFbb2Zmc2V0ICsgMl07XG4gICAgICAgICAgICAgIGwgPSBmcmFtZS5jb21wb25lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGgsXG4gICAgICAgICAgICAgICAgdixcbiAgICAgICAgICAgICAgICBxdWFudGl6YXRpb25JZDogcUlkLFxuICAgICAgICAgICAgICAgIHF1YW50aXphdGlvblRhYmxlOiBudWxsLCAvLyBTZWUgY29tbWVudCBiZWxvdy5cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGZyYW1lLmNvbXBvbmVudElkc1tjb21wb25lbnRJZF0gPSBsIC0gMTtcbiAgICAgICAgICAgICAgb2Zmc2V0ICs9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcmFtZS5tYXhIID0gbWF4SDtcbiAgICAgICAgICAgIGZyYW1lLm1heFYgPSBtYXhWO1xuICAgICAgICAgICAgcHJlcGFyZUNvbXBvbmVudHMoZnJhbWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDB4ZmZjNDogLy8gREhUIChEZWZpbmUgSHVmZm1hbiBUYWJsZXMpXG4gICAgICAgICAgICBjb25zdCBodWZmbWFuTGVuZ3RoID0gcmVhZFVpbnQxNihkYXRhLCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgICAgICBmb3IgKGkgPSAyOyBpIDwgaHVmZm1hbkxlbmd0aDsgKSB7XG4gICAgICAgICAgICAgIHZhciBodWZmbWFuVGFibGVTcGVjID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgICAgIHZhciBjb2RlTGVuZ3RocyA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICAgICAgICAgICAgdmFyIGNvZGVMZW5ndGhTdW0gPSAwO1xuICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgMTY7IGorKywgb2Zmc2V0KyspIHtcbiAgICAgICAgICAgICAgICBjb2RlTGVuZ3RoU3VtICs9IGNvZGVMZW5ndGhzW2pdID0gZGF0YVtvZmZzZXRdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBodWZmbWFuVmFsdWVzID0gbmV3IFVpbnQ4QXJyYXkoY29kZUxlbmd0aFN1bSk7XG4gICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb2RlTGVuZ3RoU3VtOyBqKyssIG9mZnNldCsrKSB7XG4gICAgICAgICAgICAgICAgaHVmZm1hblZhbHVlc1tqXSA9IGRhdGFbb2Zmc2V0XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpICs9IDE3ICsgY29kZUxlbmd0aFN1bTtcblxuICAgICAgICAgICAgICAoaHVmZm1hblRhYmxlU3BlYyA+PiA0ID09PSAwID8gaHVmZm1hblRhYmxlc0RDIDogaHVmZm1hblRhYmxlc0FDKVtcbiAgICAgICAgICAgICAgICBodWZmbWFuVGFibGVTcGVjICYgMTVcbiAgICAgICAgICAgICAgXSA9IGJ1aWxkSHVmZm1hblRhYmxlKGNvZGVMZW5ndGhzLCBodWZmbWFuVmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAweGZmZGQ6IC8vIERSSSAoRGVmaW5lIFJlc3RhcnQgSW50ZXJ2YWwpXG4gICAgICAgICAgICBvZmZzZXQgKz0gMjsgLy8gU2tpcCBtYXJrZXIgbGVuZ3RoLlxuXG4gICAgICAgICAgICByZXNldEludGVydmFsID0gcmVhZFVpbnQxNihkYXRhLCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMHhmZmRhOiAvLyBTT1MgKFN0YXJ0IG9mIFNjYW4pXG4gICAgICAgICAgICAvLyBBIEROTCBtYXJrZXIgKDB4RkZEQyksIGlmIGl0IGV4aXN0cywgaXMgb25seSBhbGxvd2VkIGF0IHRoZSBlbmRcbiAgICAgICAgICAgIC8vIG9mIHRoZSBmaXJzdCBzY2FuIHNlZ21lbnQgYW5kIG1heSBvbmx5IG9jY3VyIG9uY2UgaW4gYW4gaW1hZ2UuXG4gICAgICAgICAgICAvLyBGdXJ0aGVybW9yZSwgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wLCBkbyAqbm90KiBhdHRlbXB0IHRvXG4gICAgICAgICAgICAvLyBwYXJzZSBETkwgbWFya2VycyBkdXJpbmcgcmUtcGFyc2luZyBvZiB0aGUgSlBFRyBzY2FuIGRhdGEuXG4gICAgICAgICAgICBjb25zdCBwYXJzZUROTE1hcmtlciA9ICsrbnVtU09TTWFya2VycyA9PT0gMSAmJiAhZG5sU2NhbkxpbmVzO1xuXG4gICAgICAgICAgICBvZmZzZXQgKz0gMjsgLy8gU2tpcCBtYXJrZXIgbGVuZ3RoLlxuXG4gICAgICAgICAgICB2YXIgc2VsZWN0b3JzQ291bnQgPSBkYXRhW29mZnNldCsrXTtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRzID0gW10sXG4gICAgICAgICAgICAgIGNvbXBvbmVudDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWxlY3RvcnNDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgICAgIHZhciBjb21wb25lbnRJbmRleCA9IGZyYW1lLmNvbXBvbmVudElkc1tpbmRleF07XG4gICAgICAgICAgICAgIGNvbXBvbmVudCA9IGZyYW1lLmNvbXBvbmVudHNbY29tcG9uZW50SW5kZXhdO1xuICAgICAgICAgICAgICBjb21wb25lbnQuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgdmFyIHRhYmxlU3BlYyA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgICAgICBjb21wb25lbnQuaHVmZm1hblRhYmxlREMgPSBodWZmbWFuVGFibGVzRENbdGFibGVTcGVjID4+IDRdO1xuICAgICAgICAgICAgICBjb21wb25lbnQuaHVmZm1hblRhYmxlQUMgPSBodWZmbWFuVGFibGVzQUNbdGFibGVTcGVjICYgMTVdO1xuICAgICAgICAgICAgICBjb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzcGVjdHJhbFN0YXJ0ID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgICB2YXIgc3BlY3RyYWxFbmQgPSBkYXRhW29mZnNldCsrXTtcbiAgICAgICAgICAgIHZhciBzdWNjZXNzaXZlQXBwcm94aW1hdGlvbiA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIHByb2Nlc3NlZCA9IGRlY29kZVNjYW4oXG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICAgICAgZnJhbWUsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50cyxcbiAgICAgICAgICAgICAgICByZXNldEludGVydmFsLFxuICAgICAgICAgICAgICAgIHNwZWN0cmFsU3RhcnQsXG4gICAgICAgICAgICAgICAgc3BlY3RyYWxFbmQsXG4gICAgICAgICAgICAgICAgc3VjY2Vzc2l2ZUFwcHJveGltYXRpb24gPj4gNCxcbiAgICAgICAgICAgICAgICBzdWNjZXNzaXZlQXBwcm94aW1hdGlvbiAmIDE1LFxuICAgICAgICAgICAgICAgIHBhcnNlRE5MTWFya2VyXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIG9mZnNldCArPSBwcm9jZXNzZWQ7XG4gICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICBpZiAoZXggaW5zdGFuY2VvZiBETkxNYXJrZXJFcnJvcikge1xuICAgICAgICAgICAgICAgIHdhcm4oYCR7ZXgubWVzc2FnZX0gLS0gYXR0ZW1wdGluZyB0byByZS1wYXJzZSB0aGUgSlBFRyBpbWFnZS5gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZShkYXRhLCB7IGRubFNjYW5MaW5lczogZXguc2NhbkxpbmVzIH0pO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV4IGluc3RhbmNlb2YgRU9JTWFya2VyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGAke2V4Lm1lc3NhZ2V9IC0tIGlnbm9yaW5nIHRoZSByZXN0IG9mIHRoZSBpbWFnZSBkYXRhLmApO1xuICAgICAgICAgICAgICAgIGJyZWFrIG1hcmtlckxvb3A7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMHhmZmRjOiAvLyBETkwgKERlZmluZSBOdW1iZXIgb2YgTGluZXMpXG4gICAgICAgICAgICAvLyBJZ25vcmUgdGhlIG1hcmtlciwgc2luY2UgaXQncyBiZWluZyBoYW5kbGVkIGluIGBkZWNvZGVTY2FuYC5cbiAgICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDB4ZmZmZjogLy8gRmlsbCBieXRlc1xuICAgICAgICAgICAgaWYgKGRhdGFbb2Zmc2V0XSAhPT0gMHhmZikge1xuICAgICAgICAgICAgICAvLyBBdm9pZCBza2lwcGluZyBhIHZhbGlkIG1hcmtlci5cbiAgICAgICAgICAgICAgb2Zmc2V0LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBDb3VsZCBiZSBpbmNvcnJlY3QgZW5jb2RpbmcgLS0gdGhlIGxhc3QgMHhGRiBieXRlIG9mIHRoZSBwcmV2aW91c1xuICAgICAgICAgICAgLy8gYmxvY2sgY291bGQgaGF2ZSBiZWVuIGVhdGVuIGJ5IHRoZSBlbmNvZGVyLCBoZW5jZSB3ZSBmYWxsYmFjayB0b1xuICAgICAgICAgICAgLy8gYHN0YXJ0UG9zID0gb2Zmc2V0IC0gM2Agd2hlbiBsb29raW5nIGZvciB0aGUgbmV4dCB2YWxpZCBtYXJrZXIuXG4gICAgICAgICAgICBjb25zdCBuZXh0RmlsZU1hcmtlciA9IGZpbmROZXh0RmlsZU1hcmtlcihcbiAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgLyogY3VycmVudFBvcyA9ICovIG9mZnNldCAtIDIsXG4gICAgICAgICAgICAgIC8qIHN0YXJ0UG9zID0gKi8gb2Zmc2V0IC0gM1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChuZXh0RmlsZU1hcmtlciAmJiBuZXh0RmlsZU1hcmtlci5pbnZhbGlkKSB7XG4gICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgXCJKcGVnSW1hZ2UucGFyc2UgLSB1bmV4cGVjdGVkIGRhdGEsIGN1cnJlbnQgbWFya2VyIGlzOiBcIiArXG4gICAgICAgICAgICAgICAgICBuZXh0RmlsZU1hcmtlci5pbnZhbGlkXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIG9mZnNldCA9IG5leHRGaWxlTWFya2VyLm9mZnNldDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID49IGRhdGEubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgIFwiSnBlZ0ltYWdlLnBhcnNlIC0gcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBpbWFnZSBkYXRhIFwiICtcbiAgICAgICAgICAgICAgICAgIFwid2l0aG91dCBmaW5kaW5nIGFuIEVPSSBtYXJrZXIgKDB4RkZEOSkuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWsgbWFya2VyTG9vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBKcGVnRXJyb3IoXG4gICAgICAgICAgICAgIFwiSnBlZ0ltYWdlLnBhcnNlIC0gdW5rbm93biBtYXJrZXI6IFwiICsgZmlsZU1hcmtlci50b1N0cmluZygxNilcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZmlsZU1hcmtlciA9IHJlYWRVaW50MTYoZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICB9XG5cbiAgICAgIHRoaXMud2lkdGggPSBmcmFtZS5zYW1wbGVzUGVyTGluZTtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gZnJhbWUuc2NhbkxpbmVzO1xuICAgICAgdGhpcy5qZmlmID0gamZpZjtcbiAgICAgIHRoaXMuYWRvYmUgPSBhZG9iZTtcbiAgICAgIHRoaXMuY29tcG9uZW50cyA9IFtdO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGZyYW1lLmNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29tcG9uZW50ID0gZnJhbWUuY29tcG9uZW50c1tpXTtcblxuICAgICAgICAvLyBQcmV2ZW50IGVycm9ycyB3aGVuIERRVCBtYXJrZXJzIGFyZSBwbGFjZWQgYWZ0ZXIgU09Ge259IG1hcmtlcnMsXG4gICAgICAgIC8vIGJ5IGFzc2lnbmluZyB0aGUgYHF1YW50aXphdGlvblRhYmxlYCBlbnRyeSBhZnRlciB0aGUgZW50aXJlIGltYWdlXG4gICAgICAgIC8vIGhhcyBiZWVuIHBhcnNlZCAoZml4ZXMgaXNzdWU3NDA2LnBkZikuXG4gICAgICAgIHZhciBxdWFudGl6YXRpb25UYWJsZSA9IHF1YW50aXphdGlvblRhYmxlc1tjb21wb25lbnQucXVhbnRpemF0aW9uSWRdO1xuICAgICAgICBpZiAocXVhbnRpemF0aW9uVGFibGUpIHtcbiAgICAgICAgICBjb21wb25lbnQucXVhbnRpemF0aW9uVGFibGUgPSBxdWFudGl6YXRpb25UYWJsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5wdXNoKHtcbiAgICAgICAgICBpbmRleDogY29tcG9uZW50LmluZGV4LFxuICAgICAgICAgIG91dHB1dDogYnVpbGRDb21wb25lbnREYXRhKGZyYW1lLCBjb21wb25lbnQpLFxuICAgICAgICAgIHNjYWxlWDogY29tcG9uZW50LmggLyBmcmFtZS5tYXhILFxuICAgICAgICAgIHNjYWxlWTogY29tcG9uZW50LnYgLyBmcmFtZS5tYXhWLFxuICAgICAgICAgIGJsb2Nrc1BlckxpbmU6IGNvbXBvbmVudC5ibG9ja3NQZXJMaW5lLFxuICAgICAgICAgIGJsb2Nrc1BlckNvbHVtbjogY29tcG9uZW50LmJsb2Nrc1BlckNvbHVtbixcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLm51bUNvbXBvbmVudHMgPSB0aGlzLmNvbXBvbmVudHMubGVuZ3RoO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LFxuXG4gICAgX2dldExpbmVhcml6ZWRCbG9ja0RhdGEod2lkdGgsIGhlaWdodCwgaXNTb3VyY2VQREYgPSBmYWxzZSkge1xuICAgICAgdmFyIHNjYWxlWCA9IHRoaXMud2lkdGggLyB3aWR0aCxcbiAgICAgICAgc2NhbGVZID0gdGhpcy5oZWlnaHQgLyBoZWlnaHQ7XG5cbiAgICAgIHZhciBjb21wb25lbnQsIGNvbXBvbmVudFNjYWxlWCwgY29tcG9uZW50U2NhbGVZLCBibG9ja3NQZXJTY2FubGluZTtcbiAgICAgIHZhciB4LCB5LCBpLCBqLCBrO1xuICAgICAgdmFyIGluZGV4O1xuICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICB2YXIgb3V0cHV0O1xuICAgICAgdmFyIG51bUNvbXBvbmVudHMgPSB0aGlzLmNvbXBvbmVudHMubGVuZ3RoO1xuICAgICAgdmFyIGRhdGFMZW5ndGggPSB3aWR0aCAqIGhlaWdodCAqIG51bUNvbXBvbmVudHM7XG4gICAgICB2YXIgZGF0YSA9IG5ldyBVaW50OENsYW1wZWRBcnJheShkYXRhTGVuZ3RoKTtcbiAgICAgIHZhciB4U2NhbGVCbG9ja09mZnNldCA9IG5ldyBVaW50MzJBcnJheSh3aWR0aCk7XG4gICAgICB2YXIgbWFzazNMU0IgPSAweGZmZmZmZmY4OyAvLyB1c2VkIHRvIGNsZWFyIHRoZSAzIExTQnNcbiAgICAgIGxldCBsYXN0Q29tcG9uZW50U2NhbGVYO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtQ29tcG9uZW50czsgaSsrKSB7XG4gICAgICAgIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50c1tpXTtcbiAgICAgICAgY29tcG9uZW50U2NhbGVYID0gY29tcG9uZW50LnNjYWxlWCAqIHNjYWxlWDtcbiAgICAgICAgY29tcG9uZW50U2NhbGVZID0gY29tcG9uZW50LnNjYWxlWSAqIHNjYWxlWTtcbiAgICAgICAgb2Zmc2V0ID0gaTtcbiAgICAgICAgb3V0cHV0ID0gY29tcG9uZW50Lm91dHB1dDtcbiAgICAgICAgYmxvY2tzUGVyU2NhbmxpbmUgPSAoY29tcG9uZW50LmJsb2Nrc1BlckxpbmUgKyAxKSA8PCAzO1xuICAgICAgICAvLyBQcmVjYWxjdWxhdGUgdGhlIGB4U2NhbGVCbG9ja09mZnNldGAuIFNpbmNlIGl0IGRvZXNuJ3QgZGVwZW5kIG9uIHRoZVxuICAgICAgICAvLyBjb21wb25lbnQgZGF0YSwgdGhhdCdzIG9ubHkgbmVjZXNzYXJ5IHdoZW4gYGNvbXBvbmVudFNjYWxlWGAgY2hhbmdlcy5cbiAgICAgICAgaWYgKGNvbXBvbmVudFNjYWxlWCAhPT0gbGFzdENvbXBvbmVudFNjYWxlWCkge1xuICAgICAgICAgIGZvciAoeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICBqID0gMCB8ICh4ICogY29tcG9uZW50U2NhbGVYKTtcbiAgICAgICAgICAgIHhTY2FsZUJsb2NrT2Zmc2V0W3hdID0gKChqICYgbWFzazNMU0IpIDw8IDMpIHwgKGogJiA3KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGFzdENvbXBvbmVudFNjYWxlWCA9IGNvbXBvbmVudFNjYWxlWDtcbiAgICAgICAgfVxuICAgICAgICAvLyBsaW5lYXJpemUgdGhlIGJsb2NrcyBvZiB0aGUgY29tcG9uZW50XG4gICAgICAgIGZvciAoeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgIGogPSAwIHwgKHkgKiBjb21wb25lbnRTY2FsZVkpO1xuICAgICAgICAgIGluZGV4ID0gKGJsb2Nrc1BlclNjYW5saW5lICogKGogJiBtYXNrM0xTQikpIHwgKChqICYgNykgPDwgMyk7XG4gICAgICAgICAgZm9yICh4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgIGRhdGFbb2Zmc2V0XSA9IG91dHB1dFtpbmRleCArIHhTY2FsZUJsb2NrT2Zmc2V0W3hdXTtcbiAgICAgICAgICAgIG9mZnNldCArPSBudW1Db21wb25lbnRzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBkZWNvZGVUcmFuc2Zvcm0gY29udGFpbnMgcGFpcnMgb2YgbXVsdGlwbGllciAoLTI1Ni4uMjU2KSBhbmQgYWRkaXRpdmVcbiAgICAgIGxldCB0cmFuc2Zvcm0gPSB0aGlzLl9kZWNvZGVUcmFuc2Zvcm07XG5cbiAgICAgIC8vIEluIFBERiBmaWxlcywgSlBFRyBpbWFnZXMgd2l0aCBDTVlLIGNvbG91ciBzcGFjZXMgYXJlIHVzdWFsbHkgaW52ZXJ0ZWRcbiAgICAgIC8vICh0aGlzIGNhbiBiZSBvYnNlcnZlZCBieSBleHRyYWN0aW5nIHRoZSByYXcgaW1hZ2UgZGF0YSkuXG4gICAgICAvLyBTaW5jZSB0aGUgY29udmVyc2lvbiBhbGdvcml0aG1zIChzZWUgYmVsb3cpIHdlcmUgd3JpdHRlbiBwcmltYXJpbHkgZm9yXG4gICAgICAvLyB0aGUgUERGIHVzZS1jYXNlcywgYXR0ZW1wdGluZyB0byB1c2UgYEpwZWdJbWFnZWAgdG8gcGFyc2Ugc3RhbmRhbG9uZVxuICAgICAgLy8gSlBFRyAoQ01ZSykgaW1hZ2VzIG1heSB0aHVzIHJlc3VsdCBpbiBpbnZlcnRlZCBpbWFnZXMgKHNlZSBpc3N1ZSA5NTEzKS5cbiAgICAgIC8vXG4gICAgICAvLyBVbmZvcnR1bmF0ZWx5IGl0J3Mgbm90IChhbHdheXMpIHBvc3NpYmxlIHRvIHRlbGwsIGZyb20gdGhlIGltYWdlIGRhdGFcbiAgICAgIC8vIGFsb25lLCBpZiBpdCBuZWVkcyB0byBiZSBpbnZlcnRlZC4gVGh1cyBpbiBhbiBhdHRlbXB0IHRvIHByb3ZpZGUgYmV0dGVyXG4gICAgICAvLyBvdXQtb2YtYm94IGJlaGF2aW91ciB3aGVuIGBKcGVnSW1hZ2VgIGlzIHVzZWQgc3RhbmRhbG9uZSwgZGVmYXVsdCB0b1xuICAgICAgLy8gaW52ZXJ0aW5nIEpQRUcgKENNWUspIGltYWdlcyBpZiBhbmQgb25seSBpZiB0aGUgaW1hZ2UgZGF0YSBkb2VzICpub3QqXG4gICAgICAvLyBjb21lIGZyb20gYSBQREYgZmlsZSBhbmQgbm8gYGRlY29kZVRyYW5zZm9ybWAgd2FzIHBhc3NlZCBieSB0aGUgdXNlci5cbiAgICAgIGlmICghaXNTb3VyY2VQREYgJiYgbnVtQ29tcG9uZW50cyA9PT0gNCAmJiAhdHJhbnNmb3JtKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICB0cmFuc2Zvcm0gPSBuZXcgSW50MzJBcnJheShbXG4gICAgICAgICAgLTI1NiwgMjU1LCAtMjU2LCAyNTUsIC0yNTYsIDI1NSwgLTI1NiwgMjU1XSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGRhdGFMZW5ndGg7ICkge1xuICAgICAgICAgIGZvciAoaiA9IDAsIGsgPSAwOyBqIDwgbnVtQ29tcG9uZW50czsgaisrLCBpKyssIGsgKz0gMikge1xuICAgICAgICAgICAgZGF0YVtpXSA9ICgoZGF0YVtpXSAqIHRyYW5zZm9ybVtrXSkgPj4gOCkgKyB0cmFuc2Zvcm1bayArIDFdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIGdldCBfaXNDb2xvckNvbnZlcnNpb25OZWVkZWQoKSB7XG4gICAgICBpZiAodGhpcy5hZG9iZSkge1xuICAgICAgICAvLyBUaGUgYWRvYmUgdHJhbnNmb3JtIG1hcmtlciBvdmVycmlkZXMgYW55IHByZXZpb3VzIHNldHRpbmcuXG4gICAgICAgIHJldHVybiAhIXRoaXMuYWRvYmUudHJhbnNmb3JtQ29kZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm51bUNvbXBvbmVudHMgPT09IDMpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbG9yVHJhbnNmb3JtID09PSAwKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIEFkb2JlIHRyYW5zZm9ybSBtYXJrZXIgaXMgbm90IHByZXNlbnQgYW5kIHRoZSBpbWFnZVxuICAgICAgICAgIC8vIGRpY3Rpb25hcnkgaGFzIGEgJ0NvbG9yVHJhbnNmb3JtJyBlbnRyeSwgZXhwbGljaXRseSBzZXQgdG8gYDBgLFxuICAgICAgICAgIC8vIHRoZW4gdGhlIGNvbG91cnMgc2hvdWxkICpub3QqIGJlIHRyYW5zZm9ybWVkLlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICB0aGlzLmNvbXBvbmVudHNbMF0uaW5kZXggPT09IC8qIFwiUlwiID0gKi8gMHg1MiAmJlxuICAgICAgICAgIHRoaXMuY29tcG9uZW50c1sxXS5pbmRleCA9PT0gLyogXCJHXCIgPSAqLyAweDQ3ICYmXG4gICAgICAgICAgdGhpcy5jb21wb25lbnRzWzJdLmluZGV4ID09PSAvKiBcIkJcIiA9ICovIDB4NDJcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHRocmVlIGNvbXBvbmVudHMgYXJlIGluZGV4ZWQgYXMgUkdCIGluIEFTQ0lJXG4gICAgICAgICAgLy8gdGhlbiB0aGUgY29sb3VycyBzaG91bGQgKm5vdCogYmUgdHJhbnNmb3JtZWQuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgLy8gYHRoaXMubnVtQ29tcG9uZW50cyAhPT0gM2BcbiAgICAgIGlmICh0aGlzLl9jb2xvclRyYW5zZm9ybSA9PT0gMSkge1xuICAgICAgICAvLyBJZiB0aGUgQWRvYmUgdHJhbnNmb3JtIG1hcmtlciBpcyBub3QgcHJlc2VudCBhbmQgdGhlIGltYWdlXG4gICAgICAgIC8vIGRpY3Rpb25hcnkgaGFzIGEgJ0NvbG9yVHJhbnNmb3JtJyBlbnRyeSwgZXhwbGljaXRseSBzZXQgdG8gYDFgLFxuICAgICAgICAvLyB0aGVuIHRoZSBjb2xvdXJzIHNob3VsZCBiZSB0cmFuc2Zvcm1lZC5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIF9jb252ZXJ0WWNjVG9SZ2I6IGZ1bmN0aW9uIGNvbnZlcnRZY2NUb1JnYihkYXRhKSB7XG4gICAgICB2YXIgWSwgQ2IsIENyO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgWSA9IGRhdGFbaV07XG4gICAgICAgIENiID0gZGF0YVtpICsgMV07XG4gICAgICAgIENyID0gZGF0YVtpICsgMl07XG4gICAgICAgIGRhdGFbaV0gPSBZIC0gMTc5LjQ1NiArIDEuNDAyICogQ3I7XG4gICAgICAgIGRhdGFbaSArIDFdID0gWSArIDEzNS40NTkgLSAwLjM0NCAqIENiIC0gMC43MTQgKiBDcjtcbiAgICAgICAgZGF0YVtpICsgMl0gPSBZIC0gMjI2LjgxNiArIDEuNzcyICogQ2I7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgX2NvbnZlcnRZY2NrVG9SZ2I6IGZ1bmN0aW9uIGNvbnZlcnRZY2NrVG9SZ2IoZGF0YSkge1xuICAgICAgdmFyIFksIENiLCBDciwgaztcbiAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgWSA9IGRhdGFbaV07XG4gICAgICAgIENiID0gZGF0YVtpICsgMV07XG4gICAgICAgIENyID0gZGF0YVtpICsgMl07XG4gICAgICAgIGsgPSBkYXRhW2kgKyAzXTtcblxuICAgICAgICBkYXRhW29mZnNldCsrXSA9XG4gICAgICAgICAgLTEyMi42NzE5NTQwNjg5NCArXG4gICAgICAgICAgQ2IgKlxuICAgICAgICAgICAgKC02LjYwNjM1NjY5NDIwMzY0ZS01ICogQ2IgK1xuICAgICAgICAgICAgICAwLjAwMDQzNzEzMDQ3NTkyNjIzMiAqIENyIC1cbiAgICAgICAgICAgICAgNS40MDgwNjEwMDY0NTk5ZS01ICogWSArXG4gICAgICAgICAgICAgIDAuMDAwNDg0NDk3OTcxMjAyODEgKiBrIC1cbiAgICAgICAgICAgICAgMC4xNTQzNjIxNTE4NzExMjYpICtcbiAgICAgICAgICBDciAqXG4gICAgICAgICAgICAoLTAuMDAwOTU3OTY0Mzc4NDQ1NzczICogQ3IgK1xuICAgICAgICAgICAgICAwLjAwMDgxNzA3NjkxMTM0NjYyNSAqIFkgLVxuICAgICAgICAgICAgICAwLjAwNDc3MjcxNDA1NDA4NzQ3ICogayArXG4gICAgICAgICAgICAgIDEuNTMzODAyNTMyMjE3MzQpICtcbiAgICAgICAgICBZICpcbiAgICAgICAgICAgICgwLjAwMDk2MTI1MDE4NDEzMDY4OCAqIFkgLVxuICAgICAgICAgICAgICAwLjAwMjY2MjU3MzMyMjgzOTMzICogayArXG4gICAgICAgICAgICAgIDAuNDgzNTcwODg0NTEyNjUpICtcbiAgICAgICAgICBrICogKC0wLjAwMDMzNjE5NzE3NzYxODM5NCAqIGsgKyAwLjQ4NDc5MTU2MTQ5MDc3Nik7XG5cbiAgICAgICAgZGF0YVtvZmZzZXQrK10gPVxuICAgICAgICAgIDEwNy4yNjgwMzkzOTc3MjQgK1xuICAgICAgICAgIENiICpcbiAgICAgICAgICAgICgyLjE5OTI3MTA0NTI1NzQxZS01ICogQ2IgLVxuICAgICAgICAgICAgICAwLjAwMDY0MDk5MjAxODI5Nzk0NSAqIENyICtcbiAgICAgICAgICAgICAgMC4wMDA2NTkzOTcwMDEyNDU1NzcgKiBZICtcbiAgICAgICAgICAgICAgMC4wMDA0MjYxMDU2NTI5Mzg4MzcgKiBrIC1cbiAgICAgICAgICAgICAgMC4xNzY0OTE3OTI0NjI4NzUpICtcbiAgICAgICAgICBDciAqXG4gICAgICAgICAgICAoLTAuMDAwNzc4MjY5OTQxNTEzNjgzICogQ3IgK1xuICAgICAgICAgICAgICAwLjAwMTMwODcyMjYxNDA4Mjc1ICogWSArXG4gICAgICAgICAgICAgIDAuMDAwNzcwNDgyNjMxODAxMTMyICogayAtXG4gICAgICAgICAgICAgIDAuMTUxMDUxNDkyNzc1NTYyKSArXG4gICAgICAgICAgWSAqXG4gICAgICAgICAgICAoMC4wMDEyNjkzNTM2ODExNDg0MyAqIFkgLVxuICAgICAgICAgICAgICAwLjAwMjY1MDkwMTg5MDEwODk4ICogayArXG4gICAgICAgICAgICAgIDAuMjU4MDI5MTAyMDY4NDUpICtcbiAgICAgICAgICBrICogKC0wLjAwMDMxODkxMzExNzU4ODMyOCAqIGsgLSAwLjIxMzc0MjQwMDMyMzY2NSk7XG5cbiAgICAgICAgZGF0YVtvZmZzZXQrK10gPVxuICAgICAgICAgIC0yMC44MTAwMTI1NDY5NDcgK1xuICAgICAgICAgIENiICpcbiAgICAgICAgICAgICgtMC4wMDA1NzAxMTUxOTY5NzM2NzcgKiBDYiAtXG4gICAgICAgICAgICAgIDIuNjM0MDkwNTEwMDQ1ODllLTUgKiBDciArXG4gICAgICAgICAgICAgIDAuMDAyMDc0MTA4ODExNTAxMiAqIFkgLVxuICAgICAgICAgICAgICAwLjAwMjg4MjYwMjM2ODUzNDQyICogayArXG4gICAgICAgICAgICAgIDAuODE0MjcyOTY4MzU5Mjk1KSArXG4gICAgICAgICAgQ3IgKlxuICAgICAgICAgICAgKC0xLjUzNDk2MDU3NDQwOTc1ZS01ICogQ3IgLVxuICAgICAgICAgICAgICAwLjAwMDEzMjY4OTA0Mzk2MTQ0NiAqIFkgK1xuICAgICAgICAgICAgICAwLjAwMDU2MDgzMzY5MTI0MjgxMiAqIGsgLVxuICAgICAgICAgICAgICAwLjE5NTE1MjAyNzUzNDA0OSkgK1xuICAgICAgICAgIFkgKlxuICAgICAgICAgICAgKDAuMDAxNzQ0MTgxMzI5Mjc1ODIgKiBZIC1cbiAgICAgICAgICAgICAgMC4wMDI1NTI0MzMyMTQzOTM0NyAqIGsgK1xuICAgICAgICAgICAgICAwLjExNjkzNTAyMDQ2NTE0NSkgK1xuICAgICAgICAgIGsgKiAoLTAuMDAwMzQzNTMxOTk2NTEwNTU1ICogayArIDAuMjQxNjUyNjAyMzI0MDcpO1xuICAgICAgfVxuICAgICAgLy8gRW5zdXJlIHRoYXQgb25seSB0aGUgY29udmVydGVkIFJHQiBkYXRhIGlzIHJldHVybmVkLlxuICAgICAgcmV0dXJuIGRhdGEuc3ViYXJyYXkoMCwgb2Zmc2V0KTtcbiAgICB9LFxuXG4gICAgX2NvbnZlcnRZY2NrVG9DbXlrOiBmdW5jdGlvbiBjb252ZXJ0WWNja1RvQ215ayhkYXRhKSB7XG4gICAgICB2YXIgWSwgQ2IsIENyO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgWSA9IGRhdGFbaV07XG4gICAgICAgIENiID0gZGF0YVtpICsgMV07XG4gICAgICAgIENyID0gZGF0YVtpICsgMl07XG4gICAgICAgIGRhdGFbaV0gPSA0MzQuNDU2IC0gWSAtIDEuNDAyICogQ3I7XG4gICAgICAgIGRhdGFbaSArIDFdID0gMTE5LjU0MSAtIFkgKyAwLjM0NCAqIENiICsgMC43MTQgKiBDcjtcbiAgICAgICAgZGF0YVtpICsgMl0gPSA0ODEuODE2IC0gWSAtIDEuNzcyICogQ2I7XG4gICAgICAgIC8vIEsgaW4gZGF0YVtpICsgM10gaXMgdW5jaGFuZ2VkXG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgX2NvbnZlcnRDbXlrVG9SZ2I6IGZ1bmN0aW9uIGNvbnZlcnRDbXlrVG9SZ2IoZGF0YSkge1xuICAgICAgdmFyIGMsIG0sIHksIGs7XG4gICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBkYXRhLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIGMgPSBkYXRhW2ldO1xuICAgICAgICBtID0gZGF0YVtpICsgMV07XG4gICAgICAgIHkgPSBkYXRhW2kgKyAyXTtcbiAgICAgICAgayA9IGRhdGFbaSArIDNdO1xuXG4gICAgICAgIGRhdGFbb2Zmc2V0KytdID1cbiAgICAgICAgICAyNTUgK1xuICAgICAgICAgIGMgKlxuICAgICAgICAgICAgKC0wLjAwMDA2NzQ3MTQ3MDczNjAyNDQxICogYyArXG4gICAgICAgICAgICAgIDAuMDAwODM3OTI2MjEyMTAxMzcyNyAqIG0gK1xuICAgICAgICAgICAgICAwLjAwMDI4OTQ3MTgxODg2NDMyOTQgKiB5ICtcbiAgICAgICAgICAgICAgMC4wMDMyNjQyMzEwNTc1Mzc4MDYgKiBrIC1cbiAgICAgICAgICAgICAgMS4xMTg1NjExODY3MjAzOTM3KSArXG4gICAgICAgICAgbSAqXG4gICAgICAgICAgICAoMC4wMDAwMjYzNzQxMDc2MTYwODk0MDUgKiBtIC1cbiAgICAgICAgICAgICAgMC4wMDAwODYyNjk0OTE1ODYzODU3MiAqIHkgLVxuICAgICAgICAgICAgICAwLjAwMDI3NDg3NjkwNjc0OTk0OTEgKiBrIC1cbiAgICAgICAgICAgICAgMC4wMjE1NTY4ODc5NDk3ODk2NykgK1xuICAgICAgICAgIHkgKlxuICAgICAgICAgICAgKC0wLjAwMDAzODc4MDk5MjEyODY5MzYzICogeSAtXG4gICAgICAgICAgICAgIDAuMDAwMzI2NzgwODI3OTQ4NTI4NiAqIGsgK1xuICAgICAgICAgICAgICAwLjA2ODY3NDIyMzg1OTUzNDUpIC1cbiAgICAgICAgICBrICogKDAuMDAwMzM2MTk3MTc3NjE4MzkzNyAqIGsgKyAwLjc0MzA2NTkxNTEzNDIyNTQpO1xuXG4gICAgICAgIGRhdGFbb2Zmc2V0KytdID1cbiAgICAgICAgICAyNTUgK1xuICAgICAgICAgIGMgKlxuICAgICAgICAgICAgKDAuMDAwMTM1OTYzNzI4MTM1ODg4NDggKiBjICtcbiAgICAgICAgICAgICAgMC4wMDA5MjQ1MzcxMzI1NzM1ODUgKiBtICtcbiAgICAgICAgICAgICAgMC4wMDAxMDU2NzM1OTYxODY4MzU5MyAqIHkgK1xuICAgICAgICAgICAgICAwLjAwMDQ3OTE4NjQ2ODc0MzY1MTIgKiBrIC1cbiAgICAgICAgICAgICAgMC4zMTA5Njg5NTg3NTE1ODc1KSArXG4gICAgICAgICAgbSAqXG4gICAgICAgICAgICAoLTAuMDAwMjM1NDUzNDYxMDgzNzAzNDQgKiBtICtcbiAgICAgICAgICAgICAgMC4wMDAyNzAyODQ1MjUzNTM0NzE0ICogeSArXG4gICAgICAgICAgICAgIDAuMDAyMDIwMDMwODk3NzMwNzE1NiAqIGsgLVxuICAgICAgICAgICAgICAwLjc0ODgwNTIxNjcwMTU0OTQpICtcbiAgICAgICAgICB5ICpcbiAgICAgICAgICAgICgwLjAwMDA2ODM0ODE1OTk4MjM1NjYyICogeSArXG4gICAgICAgICAgICAgIDAuMDAwMTUxNjg0NTIzNjM0NjA5NzMgKiBrIC1cbiAgICAgICAgICAgICAgMC4wOTc1MTkyNzc3NDcyODkzMykgLVxuICAgICAgICAgIGsgKiAoMC4wMDAzMTg5MTMxMTc1ODgzMjgxNCAqIGsgKyAwLjczNjQ4ODM4MDc3MzMxNjgpO1xuXG4gICAgICAgIGRhdGFbb2Zmc2V0KytdID1cbiAgICAgICAgICAyNTUgK1xuICAgICAgICAgIGMgKlxuICAgICAgICAgICAgKDAuMDAwMDEzNTk4NjUwNDExMzg1MzA3ICogYyArXG4gICAgICAgICAgICAgIDAuMDAwMTI0MjM5NTYxNzU0OTA4NTEgKiBtICtcbiAgICAgICAgICAgICAgMC4wMDA0NzUxOTg1MDk3NTgzNTg5ICogeSAtXG4gICAgICAgICAgICAgIDAuMDAwMDAzNjcyOTMxNzQ3NjYzMDQyMiAqIGsgLVxuICAgICAgICAgICAgICAwLjA1NTYyMTg2OTgwMjY0MDM0KSArXG4gICAgICAgICAgbSAqXG4gICAgICAgICAgICAoMC4wMDAxNjE0MTM4MDU5ODcyNDY3NiAqIG0gK1xuICAgICAgICAgICAgICAwLjAwMDk2OTIyMzkxMzA3MjUxODYgKiB5ICtcbiAgICAgICAgICAgICAgMC4wMDA3NzgyNjkyNDUwMDM2MjUzICogayAtXG4gICAgICAgICAgICAgIDAuNDQwMTUyMzIzNjc1MjY0NjMpICtcbiAgICAgICAgICB5ICpcbiAgICAgICAgICAgICg1LjA2ODg4MjkxNDA2ODc2OWUtNyAqIHkgK1xuICAgICAgICAgICAgICAwLjAwMTc3NzgzNjkwMTEzNzUwNzEgKiBrIC1cbiAgICAgICAgICAgICAgMC43NTkxNDU0NjQ5NzQ5NjA5KSAtXG4gICAgICAgICAgayAqICgwLjAwMDM0MzUzMTk5NjUxMDU1NTMgKiBrICsgMC43MDYzNzcwMTg2MTYwMTQ0KTtcbiAgICAgIH1cbiAgICAgIC8vIEVuc3VyZSB0aGF0IG9ubHkgdGhlIGNvbnZlcnRlZCBSR0IgZGF0YSBpcyByZXR1cm5lZC5cbiAgICAgIHJldHVybiBkYXRhLnN1YmFycmF5KDAsIG9mZnNldCk7XG4gICAgfSxcblxuICAgIGdldERhdGEoeyB3aWR0aCwgaGVpZ2h0LCBmb3JjZVJHQiA9IGZhbHNlLCBpc1NvdXJjZVBERiA9IGZhbHNlIH0pIHtcbiAgICAgIGlmICh0aGlzLm51bUNvbXBvbmVudHMgPiA0KSB7XG4gICAgICAgIHRocm93IG5ldyBKcGVnRXJyb3IoXCJVbnN1cHBvcnRlZCBjb2xvciBtb2RlXCIpO1xuICAgICAgfVxuICAgICAgLy8gVHlwZSBvZiBkYXRhOiBVaW50OENsYW1wZWRBcnJheSh3aWR0aCAqIGhlaWdodCAqIG51bUNvbXBvbmVudHMpXG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX2dldExpbmVhcml6ZWRCbG9ja0RhdGEod2lkdGgsIGhlaWdodCwgaXNTb3VyY2VQREYpO1xuXG4gICAgICBpZiAodGhpcy5udW1Db21wb25lbnRzID09PSAxICYmIGZvcmNlUkdCKSB7XG4gICAgICAgIHZhciBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHZhciByZ2JEYXRhID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGRhdGFMZW5ndGggKiAzKTtcbiAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGdyYXlDb2xvciA9IGRhdGFbaV07XG4gICAgICAgICAgcmdiRGF0YVtvZmZzZXQrK10gPSBncmF5Q29sb3I7XG4gICAgICAgICAgcmdiRGF0YVtvZmZzZXQrK10gPSBncmF5Q29sb3I7XG4gICAgICAgICAgcmdiRGF0YVtvZmZzZXQrK10gPSBncmF5Q29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJnYkRhdGE7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubnVtQ29tcG9uZW50cyA9PT0gMyAmJiB0aGlzLl9pc0NvbG9yQ29udmVyc2lvbk5lZWRlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udmVydFljY1RvUmdiKGRhdGEpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm51bUNvbXBvbmVudHMgPT09IDQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzQ29sb3JDb252ZXJzaW9uTmVlZGVkKSB7XG4gICAgICAgICAgaWYgKGZvcmNlUkdCKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udmVydFljY2tUb1JnYihkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnZlcnRZY2NrVG9DbXlrKGRhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcmNlUkdCKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnZlcnRDbXlrVG9SZ2IoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG4gIH07XG5cbiAgcmV0dXJuIEpwZWdJbWFnZTtcbn0pKCk7XG5cbmV4cG9ydCB7IEpwZWdJbWFnZSB9O1xuIiwiXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxmKSB7XG4gIGNvbnN0IGRlY29kZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG4gIHNlbGYub25tZXNzYWdlID0gKHsgZGF0YTogbXNnIH0pID0+IHtcbiAgICBkZWNvZGUobXNnLmJ1ZiwgbXNnLm9wdGlvbnMsIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBjb25zdCBlcnJWYWx1ZSA9IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBlcnI7IC8vIEVycm9yIGlzIG5vdCBjbG9uYWJsZVxuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHsgZXJyOiBlcnJWYWx1ZSB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoeyByZXN1bHQ6IHJlc3VsdCB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn07XG4iLCJpbXBvcnQgeyBKcGVnSW1hZ2UgfSBmcm9tICcuL2JhY2tlbmQvanBnJztcbmltcG9ydCB7IGFycmF5TGlrZVJnYlRvUmdiYSB9IGZyb20gJy4vdXRpbC9jb2xvcic7XG5cbi8qKlxuICogRGVjb2RlIHRoZSBKUEVHIGRhdGFcbiAqXG4gKiBAcGFyYW0gYnVmIEFycmF5TGlrZSBkYXRhIHN0cnVjdHVyZVxuICogQHBhcmFtIG9wdGlvbnMgT2JqZWN0IHsgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIgfVxuICogQHBhcmFtIGNiIENhbGxiYWNrIHRvIGludm9rZSBvbiBjb21wbGV0aW9uXG4gKlxuICogQGNhbGxiYWNrIHsgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIGRhdGE6IFVpbnQ4QXJyYXkgfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZWNvZGUoYnVmLCBvcHRpb25zLCBjYikge1xuXG4gIC8vIHJldHVybnM6IFVpbnQ4Q2xhbXBlZEFycmF5KHdpZHRoICogaGVpZ2h0ICogbnVtQ29tcG9uZW50cylcbiAgZnVuY3Rpb24gZ2V0RGF0YShqLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgZm9yY2VSR0I6IHRydWUsXG4gICAgICBpc1NvdXJjZVBERjogZmFsc2VcbiAgICB9O1xuXG4gICAgcmV0dXJuIGouZ2V0RGF0YShvcHRzKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgaiA9IG5ldyBKcGVnSW1hZ2UoKTtcbiAgICBqLnBhcnNlKGJ1Zik7XG5cbiAgICBjb25zdCB3aWR0aCA9IG9wdGlvbnMud2lkdGggfHwgai53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBvcHRpb25zLmhlaWdodCB8fCBqLmhlaWdodDtcbiAgICBjb25zdCByZ2JEYXRhID0gZ2V0RGF0YShqLCB3aWR0aCwgaGVpZ2h0KTsgICAgLy8gTk9URTogZWFjaCBjb2xvciBpcyBSR0Igd2l0aG91dCBhbHBoYS1jaGFubmVsXG4gICAgY29uc3QgcmdiYURhdGEgPSBhcnJheUxpa2VSZ2JUb1JnYmEocmdiRGF0YSk7IC8vIE5PVEU6IGNvbnZlcnQgdG8gUkdCQVxuXG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICBkYXRhOiByZ2JhRGF0YVxuICAgIH07XG5cbiAgICBjYihudWxsLCByZXN1bHQpO1xuICB9IGNhdGNoKGVycikge1xuICAgIGNiKGVycik7XG4gIH1cbn1cbiIsIlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc2VsZikge1xuICBjb25zdCBlbmNvZGUgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuICBzZWxmLm9ubWVzc2FnZSA9IGZ1bmN0aW9uICh7IGRhdGE6IG1zZyB9KSB7XG4gICAgZW5jb2RlKG1zZy5idWYsIG1zZy5vcHRpb25zLCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY29uc3QgZXJyVmFsdWUgPSBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogZXJyOyAvLyBFcnJvciBpcyBub3QgY2xvbmFibGVcbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7IGVycjogZXJyVmFsdWUgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHsgcmVzdWx0OiByZXN1bHQgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59O1xuIiwiaW1wb3J0IHsgSlBFR0VuY29kZXIgfSBmcm9tICcuL2JhY2tlbmQvanBnLWVuY29kZSc7XG5cbi8qKlxuICogRW5jb2RlIHRoZSBkYXRhIHRvIEpQRUcgZm9ybWF0XG4gKlxuICogQHBhcmFtIGJ1ZiBCdWZmZXJ8VWludDhBcnJheVxuICogQHBhcmFtIG9wdGlvbnMgT2JqZWN0IHsgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIHF1YWxpdHk6IG51bWJlciB9XG4gKiBAcGFyYW0gY2IgQ2FsbGJhY2sgdG8gaW52b2tlIG9uIGNvbXBsZXRpb25cbiAqXG4gKiBAY2FsbGJhY2sgeyB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgZGF0YTogVWludDhBcnJheSB9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGVuY29kZShidWYsIG9wdGlvbnMsIGNiKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBKUEVHRW5jb2RlcihvcHRpb25zLnF1YWxpdHkpO1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICBkYXRhOiBidWYsXG4gICAgICB3aWR0aDogb3B0aW9ucy53aWR0aCxcbiAgICAgIGhlaWdodDogb3B0aW9ucy5oZWlnaHRcbiAgICB9XG5cbiAgICBjb25zdCBlbmNvZGVkID0gZW5jb2Rlci5lbmNvZGUob3B0cyk7XG5cbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBkYXRhOiBlbmNvZGVkLFxuICAgICAgd2lkdGg6IG9wdGlvbnMud2lkdGgsXG4gICAgICBoZWlnaHQ6IG9wdGlvbnMuaGVpZ2h0XG4gICAgfTtcblxuICAgIGNiKG51bGwsIHJlc3VsdCk7XG4gIH0gY2F0Y2goZXJyKSB7XG4gICAgY2IoZXJyKTtcbiAgfVxufVxuIiwiXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzZWxmKSB7XG4gIGNvbnN0IGV4aWYgPSByZXF1aXJlKCcuL2V4aWYnKTtcbiAgc2VsZi5vbm1lc3NhZ2UgPSAoeyBkYXRhOiBtc2cgfSkgPT4ge1xuICAgIGV4aWYobXNnLmJ1Ziwge30sIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBjb25zdCBlcnJWYWx1ZSA9IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBlcnI7IC8vIEVycm9yIGlzIG5vdCBjbG9uYWJsZVxuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHsgZXJyOiBlcnJWYWx1ZSB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoeyByZXN1bHQ6IHJlc3VsdCB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn07XG4iLCJpbXBvcnQgRXhpZlJlYWRlciBmcm9tICcuL2JhY2tlbmQvZXhpZi1yZWFkZXInO1xuXG4vKipcbiAqIFJlYWQgRVhJRiBkYXRhIGZyb20gdGhlIHByb3ZpZGVkIGJ1ZmZlclxuICpcbiAqIEBwYXJhbSBidWYgQXJyYXlCdWZmZXJcbiAqIEBwYXJhbSBvcHRpb25zIE9iamVjdCB7IGhhc01ha2VyTm90ZTogdHJ1ZXxmYWxzZSB9XG4gKiBAcGFyYW0gY2IgQ2FsbGJhY2sgdG8gaW52b2tlIG9uIGNvbXBsZXRpb25cbiAqXG4gKiBAY2FsbGJhY2sgT2JqZWN0IHsgbmFtZTogdmFsdWUsIC4uLiB9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGV4aWYoYnVmLCBvcHRpb25zLCBjYikge1xuICB0cnkge1xuICAgIGNvbnN0IHRhZ3MgPSBFeGlmUmVhZGVyLmxvYWQoYnVmKTtcblxuICAgIC8vIFRoZSBNYWtlck5vdGUgdGFnIGNhbiBiZSByZWFsbHkgbGFyZ2UuIFJlbW92ZSBpdCB0byBsb3dlciBtZW1vcnkgdXNhZ2UuXG4gICAgZGVsZXRlIHRhZ3NbJ01ha2VyTm90ZSddO1xuXG4gICAgY2IobnVsbCwgdGFncyk7XG4gIH0gY2F0Y2goZXJyKSB7XG4gICAgaWYoZXJyLm1lc3NhZ2UgPT09ICdObyBFeGlmIGRhdGEnKSB7XG4gICAgICBjYihudWxsLCB7fSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNiKGVycik7XG4gICAgfVxuICB9XG59XG4iLCJsZXQgaGFzV29ya2VyID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSAmJiAoJ1dvcmtlcicgaW4gd2luZG93KTtcblxuaWYgKGhhc1dvcmtlcikge1xuICB0cnkge1xuICAgIGNvbnN0IHcgPSByZXF1aXJlKCd3ZWJ3b3JraWZ5JykoKCkgPT4ge30pO1xuICAgIHcudGVybWluYXRlKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoYXNXb3JrZXIgPSBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQge1xuICBoYXNXb3JrZXJcbn1cbiIsImltcG9ydCBpbWFnZWluZm8gZnJvbSAnaW1hZ2VpbmZvJztcblxuLyoqXG4gKiBHZXQgaW1hZ2UgaW5mb3JtYXRpb25cbiAqIEBwYXJhbSB7QnVmZmVyfSBidWYgSW1hZ2Ugb3IgaW1hZ2UgcGFydCB0aGF0IGNvbnRhaW5zIGltYWdlIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIENhbGxiYWNrIHRvIGludm9rZSBvbiBjb21wbGV0aW9uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGluZm8oYnVmLCBjYikge1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBjb25zdCBpbmZvID0gaW1hZ2VpbmZvKGJ1Zik7XG4gICAgaWYoIWluZm8pIHtcbiAgICAgIGNiKG5ldyBFcnJvcignQ2Fubm90IGdldCBpbWFnZSBpbmZvJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYihudWxsLCB7XG4gICAgICAgIHR5cGU6IGluZm8udHlwZSxcbiAgICAgICAgbWltZVR5cGU6IGluZm8ubWltZVR5cGUsXG4gICAgICAgIGV4dGVuc2lvbjogaW5mby5mb3JtYXQudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgd2lkdGg6IGluZm8ud2lkdGgsXG4gICAgICAgIGhlaWdodDogaW5mby5oZWlnaHRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgMCk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCB7XG4gIFwiNDc0OTQ2MzgzOTYxXCI6IHtcbiAgICBcIm1pbWVUeXBlXCI6IFwiaW1hZ2UvZ2lmXCIsXG4gICAgXCJleHRlbnNpb25cIjogXCJnaWZcIlxuICB9LFxuICBcIjQ3NDk0NjM4Mzc2MVwiOiB7XG4gICAgXCJtaW1lVHlwZVwiOiBcImltYWdlL2dpZlwiLFxuICAgIFwiZXh0ZW5zaW9uXCI6IFwiZ2lmXCJcbiAgfSxcbiAgXCI4OTUwNGU0NzBkMGExYTBhXCI6IHtcbiAgICBcIm1pbWVUeXBlXCI6IFwiaW1hZ2UvcG5nXCIsXG4gICAgXCJleHRlbnNpb25cIjogXCJwbmdcIlxuICB9LFxuICBcImZmZDhmZlwiOiB7XG4gICAgXCJtaW1lVHlwZVwiOiBcImltYWdlL2pwZWdcIixcbiAgICBcImV4dGVuc2lvblwiOiBcImpwZ1wiXG4gIH0sXG4gIFwiNTc0NTQyNTBcIjoge1xuICAgIFwibWltZVR5cGVcIjogXCJpbWFnZS93ZWJwXCIsXG4gICAgXCJleHRlbnNpb25cIjogXCJ3ZWJwXCJcbiAgfSxcbiAgXCI0OTQ5MmEwMFwiOiB7XG4gICAgXCJtaW1lVHlwZVwiOiBcImltYWdlL3RpZmZcIixcbiAgICBcImV4dGVuc2lvblwiOiBcInRpZmZcIlxuICB9LFxuICBcIjRkNGQwMDJhXCI6IHtcbiAgICBcIm1pbWVUeXBlXCI6IFwiaW1hZ2UvdGlmZlwiLFxuICAgIFwiZXh0ZW5zaW9uXCI6IFwidGlmZlwiXG4gIH0sXG4gIFwiNDI0ZFwiOiB7XG4gICAgXCJtaW1lVHlwZVwiOiBcImltYWdlL2JtcFwiLFxuICAgIFwiZXh0ZW5zaW9uXCI6IFwiYm1wXCJcbiAgfSxcbiAgXCIwMDAwMDAxNDY2NzQ3OTcwNjk3MzZmNmRcIjoge1xuICAgIFwibWltZVR5cGVcIjogXCJ2aWRlby9tcDRcIixcbiAgICBcImV4dGVuc2lvblwiOiBcIm1wNFwiXG4gIH0sXG4gIFwiMDAwMDAwMTg2Njc0Nzk3MDMzNjc3MDM1XCI6IHtcbiAgICBcIm1pbWVUeXBlXCI6IFwidmlkZW8vbXA0XCIsXG4gICAgXCJleHRlbnNpb25cIjogXCJtcDRcIlxuICB9LFxuICBcIjAwMDAwMDE0NjY3NDc5NzA3MTc0MjAyMFwiOiB7XG4gICAgXCJtaW1lVHlwZVwiOiBcInZpZGVvL3F1aWNrdGltZVwiLFxuICAgIFwiZXh0ZW5zaW9uXCI6IFwibW92XCJcbiAgfSxcbiAgXCIxYTQ1ZGZhM1wiOiB7XG4gICAgXCJtaW1lVHlwZVwiOiBcInZpZGVvL3dlYm1cIixcbiAgICBcImV4dGVuc2lvblwiOiBcIndlYm1cIlxuICB9LFxuICBcIjI1NTA0NDQ2XCI6IHtcbiAgICBcIm1pbWVUeXBlXCI6IFwiYXBwbGljYXRpb24vcGRmXCIsXG4gICAgXCJleHRlbnNpb25cIjogXCJwZGZcIlxuICB9XG59O1xuIiwiaW1wb3J0IGRiIGZyb20gJy4vbWFnaWMtZGInO1xuXG4vKipcbiAqIExvb2t1cCB0aGUgbWFnaWMgbnVtYmVyIGluIG1hZ2ljLW51bWJlciBEQlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiBEYXRhIGJ1ZmZlclxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgQ2FsbGJhY2sgdG8gaW52b2tlIG9uIGNvbXBsZXRpb25cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWFnaWMoYnVmLCBjYikge1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBjb25zdCBzYW1wbGVMZW5ndGggPSAyNDtcbiAgICBjb25zdCBzYW1wbGUgPSBidWYuc2xpY2UoMCwgc2FtcGxlTGVuZ3RoKS50b1N0cmluZygnaGV4Jyk7IC8vIGxvb2t1cCBkYXRhXG5cbiAgICBjb25zdCBmb3VuZCA9IE9iamVjdC5rZXlzKGRiKS5maW5kKChpdCkgPT4geyByZXR1cm4gKHNhbXBsZS5pbmRleE9mKGl0KSAhPT0gLTEpOyB9KTtcblxuICAgIGlmKGZvdW5kKSB7XG4gICAgICBjYihudWxsLCBkYltmb3VuZF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYihuZXcgRXJyb3IoJ01hZ2ljIG51bWJlciBub3QgZm91bmQnKSk7XG4gICAgfVxuICB9LCAwKTtcbn1cbiIsIlxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgYnVmZmVyIHRvIEJ1ZmZlclxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxVaW50OENsYW1wZWRBcnJheX0gYnVmIElucHV0IGJ1ZmZlclxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQnVmZmVyKGJ1Zikge1xuICBpZihidWYgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBhcnJheUJ1ZmZlclRvQnVmZmVyKGJ1Zik7XG4gIH0gZWxzZSBpZihCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgIHJldHVybiBidWY7XG4gIH0gZWxzZSBpZihidWYgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IGJ1ZiBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ1Zik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJ1ZjsgLy8gdHlwZSB1bmtub3duLCB0cnVzdCB0aGUgdXNlclxuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYW55IGJ1ZmZlciB0byBBcnJheUJ1ZmZlclxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxVaW50OENsYW1wZWRBcnJheX0gYnVmIElucHV0IGJ1ZmZlclxuICogQHJldHVybnMge0FycmF5QnVmZmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9BcnJheUJ1ZmZlcihidWYpIHtcbiAgaWYoYnVmIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gYnVmO1xuICB9IGVsc2UgaWYoQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICByZXR1cm4gYXJyYXlMaWtlVG9BcnJheUJ1ZmZlcihidWYpO1xuICB9IGVsc2UgaWYoYnVmIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBidWYgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkge1xuICAgIHJldHVybiBhcnJheUxpa2VUb0FycmF5QnVmZmVyKGJ1Zik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJ1ZjsgLy8gdHlwZSB1bmtub3duLCB0cnVzdCB0aGUgdXNlclxuICB9XG59XG5cbi8qKlxuICogQ29udmVydCBhbnkgYnVmZmVyIHRvIGFycmF5LWxpa2UgdHlwZTogVWludDhBcnJheXxVaW50OENsYW1wZWRBcnJheXxCdWZmZXJcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8VWludDhDbGFtcGVkQXJyYXl9IGJ1ZlxuICogQHJldHVybnMge0J1ZmZlcnxVaW50OEFycmF5fVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9BcnJheUxpa2UoYnVmKSB7XG4gIGlmKGJ1ZiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgYnVmIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpIHtcbiAgICByZXR1cm4gYnVmO1xuICB9IGVsc2UgaWYoYnVmIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmKTtcbiAgfSBlbHNlIGlmKEJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYnVmOyAvLyB0eXBlIHVua25vd24sIHRydXN0IHRoZSB1c2VyXG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBCdWZmZXIgdG8gQXJyYXlCdWZmZXJcbiAqXG4gKiBOT1RFOiB3ZSBjYW5ub3QgY29udmVydCBCdWZmZXIgdG8gQXJyYXlCdWZmZXIgdmlhIGBidWYuYnVmZmVyYCBzaW5jZSB0aGUgc2l6ZSBvZiB0aGUgcmV0dXJuZWQgQXJyYXlCdWZmZXIgbWlnaHQgYmUgYmlnZXIgdGhhbiB0aGUgYWN0dWFsLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfFVpbnQ4QXJyYXl8VWludDhDbGFtcGVkQXJyYXl9IGJ1ZlxuICogQHJldHVybnMge0FycmF5QnVmZmVyfVxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VUb0FycmF5QnVmZmVyKGJ1Zikge1xuICBjb25zdCBhcnJCdWYgPSBuZXcgQXJyYXlCdWZmZXIoYnVmLmxlbmd0aCk7XG4gIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShhcnJCdWYpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7ICsraSkge1xuICAgIHZpZXdbaV0gPSBidWZbaV07XG4gIH1cbiAgcmV0dXJuIGFyckJ1Zjtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IEFycmF5QnVmZmVyIHRvIEJ1ZmZlclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyQnVmXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5mdW5jdGlvbiBhcnJheUJ1ZmZlclRvQnVmZmVyKGFyckJ1Zikge1xuICByZXR1cm4gQnVmZmVyLmZyb20obmV3IFVpbnQ4QXJyYXkoYXJyQnVmKSk7XG59XG4iLCJcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGJ1ZmZlciBvZiBSR0IgY29tcG9uZW50cyB0byBSR0JBLlxuICpcbiAqIEBwYXJhbSBidWYge0J1ZmZlcnxVaW50OEFycmF5fFVpbnQ4Q2xhbXBlZEFycmF5fSBhcnJheS1saWtlIHN0cnVjdHVyZSB3aXRoIFJHQiBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcnJheUxpa2VSZ2JUb1JnYmEoYnVmKSB7XG4gIGNvbnN0IGZpbGxlciA9IDB4RkY7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KChidWYubGVuZ3RoIC8gMykgKiA0KTtcblxuICBmb3IobGV0IGkgPSAwLCBwID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkgKz0gMykge1xuICAgIHJlc3VsdFtwKytdID0gYnVmW2ldO1xuICAgIHJlc3VsdFtwKytdID0gYnVmW2kgKyAxXTtcbiAgICByZXN1bHRbcCsrXSA9IGJ1ZltpICsgMl07XG4gICAgcmVzdWx0W3ArK10gPSBmaWxsZXI7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuIiwiaW1wb3J0IHsgaGFzV29ya2VyIH0gZnJvbSAnLi9saWIvaGFzLXdvcmtlcic7XG5cbmltcG9ydCAqIGFzIGJ1ZmZlclV0aWxzIGZyb20gJy4vbGliL3V0aWwvYnVmZmVyJztcblxuaW1wb3J0IGV4aWYgZnJvbSAnLi9saWIvZXhpZic7XG5pbXBvcnQgZGVjb2RlIGZyb20gJy4vbGliL2RlY29kZSc7XG5pbXBvcnQgZW5jb2RlIGZyb20gJy4vbGliL2VuY29kZSc7XG5pbXBvcnQgbWFnaWMgZnJvbSAnLi9saWIvbWFnaWMnO1xuaW1wb3J0IGluZm8gZnJvbSAnLi9saWIvaW5mbyc7XG5cbmltcG9ydCBleGlmV29ya2VyIGZyb20gJy4vbGliL2V4aWYtd29ya2VyJztcbmltcG9ydCBkZWNvZGVXb3JrZXIgZnJvbSAnLi9saWIvZGVjb2RlLXdvcmtlcic7XG5pbXBvcnQgZW5jb2RlV29ya2VyIGZyb20gJy4vbGliL2VuY29kZS13b3JrZXInO1xuXG4vKipcbiAqIERlY29kZVxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl9IGJ1ZlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgUGFyYW1zOiB7IHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyIH1cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIENhbGxiYWNrIHRvIGludm9rZSBvbiBjb21wbGV0aW9uXG4gKlxuICogQGNhbGxiYWNrIHsgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIGRhdGE6IFVpbnQ4QXJyYXkgfVxuICovXG5mdW5jdGlvbiBkZWNvZGVCdWZmZXIoYnVmLCBvcHRpb25zLCBjYikge1xuICBpZih0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB0cnkge1xuICAgIGJ1ZiA9IGJ1ZmZlclV0aWxzLnRvQXJyYXlMaWtlKGJ1Zik7XG5cbiAgICBpZihoYXNXb3JrZXIpIHtcbiAgICAgIGNvbnN0IHdyID0gcmVxdWlyZSgnd2Vid29ya2lmeScpKGRlY29kZVdvcmtlcik7XG5cbiAgICAgIHdyLm9ubWVzc2FnZSA9ICh7IGRhdGE6IG1zZyB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGVyciA9IG1zZy5lcnIgPyBuZXcgRXJyb3IobXNnLmVycikgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNiKGVyciwgbXNnLnJlc3VsdCk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtc2cgPSB7XG4gICAgICAgIGJ1ZjogYnVmLFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICB9O1xuXG4gICAgICBpZiAob3B0aW9ucy50cmFuc2ZlcmFibGUpIHtcbiAgICAgICAgd3IucG9zdE1lc3NhZ2UobXNnLCBbIGJ1ZiBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyLnBvc3RNZXNzYWdlKG1zZyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlY29kZShidWYsIG9wdGlvbnMsIGNiKTtcbiAgICB9XG4gIH0gY2F0Y2goZXJyKSB7XG4gICAgY2IoZXJyKTtcbiAgfVxufVxuXG4vKipcbiAqIEVuY29kZVxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl9IGJ1ZlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgUGFyYW1zIHsgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIHF1YWxpdHk6IG51bWJlciB9XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiBDYWxsYmFjayB0byBpbnZva2Ugb24gY29tcGxldGlvblxuICpcbiAqIEBjYWxsYmFjayB7IHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCBkYXRhOiBVaW50OEFycmF5IH1cbiAqL1xuZnVuY3Rpb24gZW5jb2RlQnVmZmVyKGJ1Ziwgb3B0aW9ucywgY2IpIHtcbiAgaWYodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdHJ5IHtcbiAgICBidWYgPSBidWZmZXJVdGlscy50b0FycmF5TGlrZShidWYpO1xuXG4gICAgaWYoIW9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3dpZHRoJykgfHwgIW9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2hlaWdodCcpKSB7XG4gICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdXaWR0aCAmIGhlaWdodCBvZiB0aGUgYnVmZmVyIGlzIG5vdCBwcm92aWRlZC4nKSk7XG4gICAgfVxuXG4gICAgaWYoaGFzV29ya2VyKSB7XG4gICAgICBjb25zdCB3ciA9IHJlcXVpcmUoJ3dlYndvcmtpZnknKShlbmNvZGVXb3JrZXIpO1xuXG4gICAgICB3ci5vbm1lc3NhZ2UgPSAoeyBkYXRhOiBtc2cgfSkgPT4ge1xuICAgICAgICBjb25zdCBlcnIgPSBtc2cuZXJyID8gbmV3IEVycm9yKG1zZy5lcnIpIDogdW5kZWZpbmVkO1xuICAgICAgICBjYihlcnIsIG1zZy5yZXN1bHQpO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgbXNnID0ge1xuICAgICAgICBidWY6IGJ1ZixcbiAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgfTtcblxuICAgICAgaWYgKG9wdGlvbnMudHJhbnNmZXJhYmxlKSB7XG4gICAgICAgIHdyLnBvc3RNZXNzYWdlKG1zZywgWyBidWYgXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3ci5wb3N0TWVzc2FnZShtc2cpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGUoYnVmLCBvcHRpb25zLCBjYik7XG4gICAgfVxuICB9IGNhdGNoKGVycikge1xuICAgIGNiKGVycik7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgRVhJRlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl9IGJ1ZlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgUGFyYW1zIHsgaGFzTWFrZXJOb3RlOiB0cnVlfGZhbHNlIH1cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIENhbGxiYWNrIHRvIGludm9rZSBvbiBjb21wbGV0aW9uXG4gKlxuICogQGNhbGxiYWNrIE9iamVjdCB7IG5hbWU6IHZhbHVlLCAuLi4gfVxuICovXG5mdW5jdGlvbiBleGlmQnVmZmVyKGJ1Ziwgb3B0aW9ucywgY2IpIHtcbiAgaWYodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdHJ5IHtcbiAgICBidWYgPSBidWZmZXJVdGlscy50b0FycmF5QnVmZmVyKGJ1Zik7XG5cbiAgICBpZihoYXNXb3JrZXIpIHtcbiAgICAgIGNvbnN0IHdyID0gcmVxdWlyZSgnd2Vid29ya2lmeScpKGV4aWZXb3JrZXIpO1xuXG4gICAgICB3ci5vbm1lc3NhZ2UgPSAoeyBkYXRhOiBtc2cgfSkgPT4ge1xuICAgICAgICBjb25zdCBlcnIgPSBtc2cuZXJyID8gbmV3IEVycm9yKG1zZy5lcnIpIDogdW5kZWZpbmVkO1xuICAgICAgICBjYihlcnIsIG1zZy5yZXN1bHQpO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgbXNnID0ge1xuICAgICAgICBidWY6IGJ1ZlxuICAgICAgfTtcblxuICAgICAgaWYgKG9wdGlvbnMudHJhbnNmZXJhYmxlKSB7XG4gICAgICAgIHdyLnBvc3RNZXNzYWdlKG1zZywgWyBidWYgXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3ci5wb3N0TWVzc2FnZShtc2cpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBleGlmKGJ1Ziwgb3B0aW9ucywgY2IpO1xuICAgIH1cbiAgfSBjYXRjaChlcnIpIHtcbiAgICBjYihlcnIpO1xuICB9XG59XG5cbi8qKlxuICogRGV0ZWN0IG1pbWUtdHlwZSBmb3IgdGhlIEJ1ZmZlclxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXlCdWZmZXJ8VWludDhBcnJheX0gYnVmIERhdGEgYnVmZmVyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiBDYWxsYmFjayB0byBpbnZva2Ugb24gY29tcGxldGlvblxuICovXG5mdW5jdGlvbiBtYWdpY0J1ZmZlcihidWYsIGNiKSB7XG4gIHRyeSB7XG4gICAgYnVmID0gYnVmZmVyVXRpbHMudG9CdWZmZXIoYnVmKTtcbiAgICBtYWdpYyhidWYsIGNiKTtcbiAgfSBjYXRjaChlcnIpIHtcbiAgICBjYihlcnIpO1xuICB9XG59XG5cbi8qKlxuICogR2V0IGltYWdlIGluZm9ybWF0aW9uIHdpdGhvdXQgcmVhZGluZyBhbmQgZGVjb2RpbmcgYSBmaWxlXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fSBidWYgRGF0YSBidWZmZXJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIENhbGxiYWNrIHRvIGludm9rZSBvbiBjb21wbGV0aW9uXG4gKi9cbmZ1bmN0aW9uIGluZm9CdWZmZXIoYnVmLCBjYikge1xuICB0cnkge1xuICAgIGJ1ZiA9IGJ1ZmZlclV0aWxzLnRvQnVmZmVyKGJ1Zik7XG4gICAgaW5mbyhidWYsIGNiKTtcbiAgfSBjYXRjaChlcnIpIHtcbiAgICBjYihlcnIpO1xuICB9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBkZWNvZGU6IGRlY29kZUJ1ZmZlcixcbiAgZW5jb2RlOiBlbmNvZGVCdWZmZXIsXG4gIGV4aWY6IGV4aWZCdWZmZXIsXG4gIG1hZ2ljOiBtYWdpY0J1ZmZlcixcbiAgaW5mbzogaW5mb0J1ZmZlcixcbn1cbiJdfQ==
